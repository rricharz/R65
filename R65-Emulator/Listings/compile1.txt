
R65 COMPILE 4.2: program COMPILE1         6/12/23 page 1


   1 (    4) {   ********************************
   2 (    4)     *                              *
   3 (    4)     *  R65 "Tiny" Pascal Compiler  *
   4 (    4)     *            Pass 1            *
   5 (    4)     *                              *
   6 (    4)     ********************************
   7 (    4) 
   8 (    4) First version 1978 by rricharz
   9 (    4) Version 3.7 (20K)  01/08/82 rricharz
  10 (    4) 
  11 (    4) Recovered 2018 by rricharz (r77@bluewin.ch)
  12 (    4) Improved 2018-2023 by rricharz
  13 (    4) Version 4 with cpnt strings and exit statement
  14 (    4) 
  15 (    4) Original derived from the publication by
  16 (    4) Kin-Man Chung and Herbert Yen in
  17 (    4) Byte, Volume 3, Number 9 and Number 10, 1978
  18 (    4) 
  19 (    4) Adapted for the R65 computer system and
  20 (    4) substantially enhanced by rricharz 1978-2023
  21 (    4) 
  22 (    4) This is a Pascal derivative optimized for 8-bit
  23 (    4) microprocessors (integer type is 16 bit) with
  24 (    4) additional features (mem) to interact directly
  25 (    4) with the microprocessor hardware. Only one
  26 (    4) dimensional arrays and no records or user
  27 (    4) defined types. Floating point numbers (real)
  28 (    4) and file io to floppy disks are supported.
  29 (    4) 
  30 (    4) Precompiled libraries are merged in the loader.
  31 (    4) The table of reserved words and the library
  32 (    4) tables are loaded from the same drive as
  33 (    4) the compiler.
  34 (    4) 
  35 (    4) The output of the program is a loader file for
  36 (    4) the Pascal loader (compile2).
  37 (    4) 
  38 (    4) usage:
  39 (    4)  compile1 name[.cy[,drv]] [xxx]
  40 (    4)   where x:       l,p: no hard copy print
  41 (    4)                  i,r: index bound checking
  42 (    4)                  n: no loader file
  43 (    4)   [] means not required
  44 (    4) 
  45 (    4) The compiler uses 2 fixed memory areas to store
  46 (    4) the table of reserved words and the table of
  47 (    4) idents. The top of the Pascal stack (endstk) is
  48 (    4) adjusted accordingly. The reason for this hack
  49 (    4) is speed and convenience. A normal Pascal array
  50 (    4) of chars would store the chars as 16 bit
  51 (    4) numers and would therefore require twice the
  52 (    4) space. An array of packed chars would require
  53 (    4) more coding and slow the scanner module of the
  54 (    4) compiler down.                                }
  55 (    4) 
  56 (    4) program compile1;
  57 (    4) 
  58 (    4) uses syslib, arglib;
  59 ( 1093) 

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         6/12/23 page 2

  60 ( 1093) const version='4.2';
  61 ( 1100) 
  62 ( 1100)     table     =$97ff; {user ident table -1}
  63 ( 1100)     idtab     =$95ff; {resword table -1}
  64 ( 1100)     idlength  =64;    {max. length of ident}
  65 ( 1100)     stacksize =256;   {stack size}
  66 ( 1100)     pagelenght=60;    {no of lines per page}
  67 ( 1100)     nooutput  =@0;
  68 ( 1100)     maxfi     =3;     {max number of ins fls}
  69 ( 1100) 
  70 ( 1100)     nresw=63;   {number of res. words, max 64}
  71 ( 1100)     symbsize=256;     {id table entries}
  72 ( 1100)     reswtabpos=$c600; { up to $c7ff }
  73 ( 1100)     idtabpos=$be00;   { up to $c5ff }
  74 ( 1100) 
  75 ( 1100)     yesoutput=@255;
  76 ( 1100) 
  77 ( 1100) mem endstk  =$000e: integer;
  78 ( 1100)     reswtab =reswtabpos: array[$200] of char&;
  79 ( 1100)     idtab   =idtabpos: array[$800] of char&;
  80 ( 1100) 
  81 ( 1100) var tpos,pc,level,line,offset,dpnt,spnt,fipnt,
  82 ( 1100)     npara,i,stackpnt,stackmax,spntmax,numerr
  83 ( 1100)                               :integer;
  84 ( 1100) 
  85 ( 1100)     scyclus,sdrive,cdrive: integer;
  86 ( 1100) 
  87 ( 1100)     pname: array[15] of char;
  88 ( 1100) 
  89 ( 1100)     value: array[1] of integer;
  90 ( 1100) 
  91 ( 1100)     ch,restype,vartype:char;
  92 ( 1100) 
  93 ( 1100)     token: packed char;
  94 ( 1100) 
  95 ( 1100)     prt,libflg,icheck,ateof,lineflg,nlflg: boolean;
  96 ( 1100) 
  97 ( 1100)     fno,ofno: file;
  98 ( 1100) 
  99 ( 1100)     filstk: array[maxfi] of file;
 100 ( 1100) 
 101 ( 1100)     ident: array[idlength] of char;
 102 ( 1100)     { Only the first 8 characters are
 103 ( 1100)       used to find and differentiate ids }
 104 ( 1100) 
 105 ( 1100)     t0: array[symbsize] of packed char;
 106 ( 1100)            {type of symbol}
 107 ( 1100) 
 108 ( 1100)         {High letter:
 109 ( 1100)          a:array, c:constant, d;const parameter
 110 ( 1100)          e:constant array parameter, f:function
 111 ( 1100)          g:array function, h;8-bit memory var
 112 ( 1100)          i:8-bit array memory variable
 113 ( 1100)          m:16-bit memory variable
 114 ( 1100)          n:16-bit array memory variable
 115 ( 1100)          p:procedure
 116 ( 1100)          q:indexed cpnt
 117 ( 1100)          r,t:function result
 118 ( 1100)          s,u:array function result
 119 ( 1100)          v:variable, w:variable parameter

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         6/12/23 page 3

 120 ( 1100)          x:variable array parameter
 121 ( 1100) 
 122 ( 1100)          Low letter:
 123 ( 1100)          i:integer, c:char, p:packed char
 124 ( 1100)          q:cpnt (pointer to chars)
 125 ( 1100)          r:real(array multiple of two)
 126 ( 1100)          s:const cpnt
 127 ( 1100)          f:file, b:boolean, u:undefined  }
 128 ( 1100) 
 129 ( 1100)     t1: array[symbsize] of integer;
 130 ( 1100)          {level}
 131 ( 1100)     t2: array[symbsize] of integer;
 132 ( 1100)          {val,dis,addr}
 133 ( 1100)     t3: array[symbsize] of integer;
 134 ( 1100)          {stack pointer,size of array}
 135 ( 1100) 
 136 ( 1100)     reswcod:array[nresw] of packed char;
 137 ( 1100) 
 138 ( 1100)     stack: array[stacksize] of integer;
 139 ( 1100) 
 140 ( 1100) 
 141 ( 1100) {       * savebyte *    (global)        }
 142 ( 1100) 
 143 ( 1100) proc savebyte(x: integer);
 144 ( 1100) 
 145 ( 1100) begin
 146 ( 1100)     if ofno<>nooutput then begin
 147 ( 1112)       write(@ofno,
 148 ( 1115)         chr(((x and 255) shr 4)+ord('0')));
 149 ( 1136)       write(@ofno,chr((x and 15)+ord('0')))
 150 ( 1151)     end
 151 ( 1154) end {savebyte};
 152 ( 1154) 
 153 ( 1155) {       * crlf *        (global)        }
 154 ( 1155) 
 155 ( 1155) proc newpage; forward;
 156 ( 1158) 
 157 ( 1158) proc crlf;
 158 ( 1158)   var i: integer;
 159 ( 1161) begin
 160 ( 1161)   writeln;
 161 ( 1163)   line:=succ(line);
 162 ( 1173)   if (line div pagelenght)*pagelength=line
 163 ( 1188)     then newpage;
 164 ( 1200) end {crlf};
 165 ( 1200) 
 166 ( 1201) {       error message   (global)        }
 167 ( 1201) 
 168 ( 1201) proc merror(x: integer; code: packed char);
 169 ( 1201) 
 170 ( 1201) var i: integer;
 171 ( 1204)     answer: char;
 172 ( 1204) 
 173 ( 1204) begin
 174 ( 1204)   crlf; numerr:=succ(numerr);
 175 ( 1214)   for i:=2 to tpos do write(' ');
 176 ( 1240)   write('^'); crlf;
 177 ( 1260)   write('*** (',numerr,',',pc,')   ');
 178 ( 1283)   case x of
 179 ( 1283)     01: write('Ident');

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         6/12/23 page 4

 180 ( 1300)     02: write('Ident ',code,' expected');
 181 ( 1336)     03: write('Var declaration');
 182 ( 1362)     04: write('Const expected');
 183 ( 1387)     05: write('Ident unknown');
 184 ( 1411)     06: write('Cannot be assigned');
 185 ( 1440)     07: write('Symbol table overflow');
 186 ( 1472)     08: write('Stack overflow');
 187 ( 1497)     09: write('Expression');
 188 ( 1518)     10: write('Statement');
 189 ( 1538)     11: write('Declaration');
 190 ( 1560)     12: write('Constant');
 191 ( 1579)     13: write('Forward reference: ',code);
 192 ( 1618)     14: write('Type mismatch: ',code);
 193 ( 1653)     15: write('Array size');
 194 ( 1674)     16: write('Array (8-bit)');
 195 ( 1698)     17: write('Real');
 196 ( 1713)     18: write('File table overflow');
 197 ( 1743)     19: write('Parameter')
 198 ( 1763)   end {case};
 199 ( 1765)   writeln;
 200 ( 1765)   write('Continue?');
 201 ( 1781)   read(@key,answer);
 202 ( 1789)   if answer<>'Y' then begin
 203 ( 1797)     crlf; write(prtoff); setemucom(9); close(fno);
 204 ( 1821)     if (ofno<>nooutput) and (ofno<>yesoutput)
 205 ( 1834)       then close(ofno);
 206 ( 1845)     writeln('Aborting compile1 on request');
 207 ( 1880)     abort
 208 ( 1880)   end
 209 ( 1884)   else crlf;
 210 ( 1891)   if (ofno<>nooutput) and (ofno<>yesoutput)
 211 ( 1904)     then close(ofno);
 212 ( 1915)   ofno:=nooutput;
 213 ( 1917) end {merror};
 214 ( 1921) 
 215 ( 1922) proc error(x: integer);
 216 ( 1922) 
 217 ( 1922) begin
 218 ( 1922)   merror(x,'##')
 219 ( 1934) end;
 220 ( 1940) 
 221 ( 1941) {       * push & pop *  (global) }
 222 ( 1941) 
 223 ( 1941) proc push(x: %integer);
 224 ( 1941) 
 225 ( 1941) begin
 226 ( 1941)   if stackpnt>=stacksize then error(8)
 227 ( 1959)   else stackpnt:=succ(stackpnt);
 228 ( 1972)   if stackpnt>stackmax then stackmax:=stackpnt;
 229 ( 1989)   stack[stackpnt]:=x;
 230 ( 2001) end {push};
 231 ( 2009) 
 232 ( 2010) func pop: integer;
 233 ( 2010) 
 234 ( 2010) begin
 235 ( 2010)   pop:=stack[stackpnt];
 236 ( 2019)   stackpnt:=prec(stackpnt)
 237 ( 2027) end {pop};
 238 ( 2036) 
 239 ( 2037) {       * newpage *     (global) }

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         6/12/23 page 5

 240 ( 2037) 
 241 ( 2037) proc newpage;
 242 ( 2037) 
 243 ( 2037) var i: integer;
 244 ( 2040) 
 245 ( 2040) begin
 246 ( 2040)   if (line<>0) and prt then
 247 ( 2049)     write(@printer,formfeed);
 248 ( 2064)   writeln; { Do not count this line}
 249 ( 2070)   if pname[0]<>'x' then begin
 250 ( 2079)     write('R65 COMPILE ');
 251 ( 2095)     write(version);
 252 ( 2100)     if libflg then write(': library ')
 253 ( 2118)     else write(': program ');
 254 ( 2132)     prtext16(output,pname);
 255 ( 2146)   end;
 256 ( 2146)   write(' ');
 257 ( 2148)   prtdate(output);
 258 ( 2156)   writeln(' page ',(line div pagelenght)+1);
 259 ( 2180)   writeln;
 260 ( 2180) end {newpage};
 261 ( 2186) 
 262 ( 2187) {        * code1 *      (global) }
 263 ( 2187) 
 264 ( 2187) proc code1(x: %integer);  {set one byte p-code}
 265 ( 2187) begin
 266 ( 2187)   savebyte(x); pc:=succ(pc)
 267 ( 2202) end;
 268 ( 2211) 
 269 ( 2212) {       * getchr *      (global) }
 270 ( 2212) 
 271 ( 2212) proc getchr;
 272 ( 2212) 
 273 ( 2212)   proc writenum(i: integer);
 274 ( 2215)   begin
 275 ( 2215)     if i<=999 then write(' ');
 276 ( 2233)     if i<=99 then write(' ');
 277 ( 2245)     if i<=9 then write(' ');
 278 ( 2257)     write(i);
 279 ( 2262)   end;
 280 ( 2262) 
 281 ( 2263) begin
 282 ( 2263)   if ateof then begin
 283 ( 2269)     writeln('Unexpected eof');
 284 ( 2293)     abort;
 285 ( 2297)   end else begin
 286 ( 2300)     read(@fno,ch);
 287 ( 2310)     if ch=cr then begin
 288 ( 2318)       crlf;
 289 ( 2325)       nlflg:=true;
 290 ( 2327)       writenum(line); write(' (');
 291 ( 2344)       if (pc+2)<9999 then write(' ');
 292 ( 2360)       writenum(pc+2); write(') ');
 293 ( 2376)       ch:=' ';
 294 ( 2378)     end {if}
 295 ( 2382)     else if ch=eof then begin
 296 ( 2392)       ateof:=true;
 297 ( 2397)       { we need to suppy one more char }
 298 ( 2401)       { for end. at end of file to work properly }
 299 ( 2401)       ch:=' ';

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         6/12/23 page 6

 300 ( 2403)     end {else if}
 301 ( 2407)     else write(ch);
 302 ( 2415)   end;
 303 ( 2415) end {getchr};
 304 ( 2415) 
 305 ( 2416) {       * splitconv *   (global) }
 306 ( 2416) 
 307 ( 2416) proc splitconv(a: array[1] of %integer;
 308 ( 2416)   var b:array[1] of %integer);
 309 ( 2416) 
 310 ( 2416) begin
 311 ( 2416)   b:=a;
 312 ( 2421) end;
 313 ( 2433) 
 314 ( 2434) {       * init *        (global) }
 315 ( 2434) 
 316 ( 2434) proc init;
 317 ( 2434) 
 318 ( 2434) const char96=chr(20);
 319 ( 2437) 
 320 ( 2437) var i,j,dummy: integer;
 321 ( 2437)     dch: char;
 322 ( 2437)     pch: packed char;
 323 ( 2437)     request: array[15] of char;
 324 ( 2437)     default: boolean;
 325 ( 2437) 
 326 ( 2437) begin {init}
 327 ( 2437)   writeln('R65 PASCAL COMPILER version ', version,
 328 ( 2471)     ', Pass  1');
 329 ( 2489)   ateof:=false;
 330 ( 2491)   cdrive:=fildrv; { drive of compile program }
 331 ( 2502)   fipnt:=-1;
 332 ( 2504)   endstk:=idtabpos-144;
 333 ( 2514)   pc:=2; dpnt:=0; spnt:=0; offset:=2;
 334 ( 2538)   npara:=0; level:=0;
 335 ( 2550)   stackpnt:=0; libflg:=false;
 336 ( 2562)   stackmax:=0;spntmax:=0; numerr:=0;
 337 ( 2580)   t0[0]:='vi'; t1[0]:=0; t2[0]:=0; t3[0]:=0;
 338 ( 2613)   { prepare resword table }
 339 ( 2617)   writeln('Reading list of reserved words');
 340 ( 2654)   asetfile('RESWORDS:W      ',0,cdrive,'W');
 341 ( 2686)   openr(fno);
 342 ( 2692)   for i:=0 to nresw do begin
 343 ( 2709)     read(@fno,pch,dch);
 344 ( 2726)     reswcod[i]:=pch;
 345 ( 2731)     for j:=0 to 7 do reswtab[8*i+j]:=' ';
 346 ( 2770)     j:=0;
 347 ( 2793)     while (j<8) and (dch<>cr) do begin
 348 ( 2815)       read(@fno,dch);
 349 ( 2825)       if (dch<>cr) then
 350 ( 2833)         reswtab[8*i+j]:=dch;
 351 ( 2848)       j:=succ(j)
 352 ( 2859)     end;
 353 ( 2868)     while (dch<>cr) and (dch<>eof) do
 354 ( 2885)       read(@fno,dch)
 355 ( 2894)   end;
 356 ( 2903)   close(fno);
 357 ( 2923) 
 358 ( 2923)   writeln;
 359 ( 2923) 

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         6/12/23 page 7

 360 ( 2929)   sdrive:=1; {default drive for source }
 361 ( 2935)   scyclus:=0;
 362 ( 2937)   agetstring(pname,default,scyclus,sdrive);
 363 ( 2981) 
 364 ( 2981)   agetstring(request,default,dummy,dummy);
 365 ( 3021)   icheck:=false;
 366 ( 3023)   prt:=true; ofno:=yesoutput; lineflg:=false;
 367 ( 3041)   if not default then begin
 368 ( 3050)     if request[0]<>'/' then argerror(103);
 369 ( 3073)     for i:=1 to 8 do
 370 ( 3081)       case request[i] of
 371 ( 3094)         'P': prt:=false;
 372 ( 3107)         'L': lineflg:=true;
 373 ( 3123)         'I','R': icheck:=true;
 374 ( 3146)         'N': ofno:=nooutput;
 375 ( 3162)         ' ': begin end
 376 ( 3176)         else argerror(104)
 377 ( 3181)       end; {case}
 378 ( 3203)   end;
 379 ( 3203) 
 380 ( 3203)   asetfile(pname,scyclus,sdrive,'P');
 381 ( 3225)   openr(fno);
 382 ( 3231)   scyclus:=filcyc; { may have changed }
 383 ( 3239) 
 384 ( 3239)   {save cyclus and drive for compile2}
 385 ( 3239)   arglist[8]:=scyclus;
 386 ( 3241)   arglist[9]:=sdrive;
 387 ( 3255)   numarg:=1;
 388 ( 3269) 
 389 ( 3273)   if prt then begin
 390 ( 3277)     write(prton);
 391 ( 3283)     setemucom(8);
 392 ( 3291)   end
 393 ( 3291) 
 394 ( 3291)   line:=0; newpage; crlf; line:=1;
 395 ( 3307)   write('   1 (    4) '); getchr
 396 ( 3325) end {init};
 397 ( 3329) 
 398 ( 3330) 
 399 ( 3330) { ############################# }
 400 ( 3330) {       *scan*              (global)    }
 401 ( 3330) { ############################# }
 402 ( 3330) { scan input and make tokens }
 403 ( 3330) 
 404 ( 3330) proc scan;
 405 ( 3330) 
 406 ( 3330) var count,ll,hh,i,i1,co: integer;
 407 ( 3333)     name: array[7] of char;
 408 ( 3333) 
 409 ( 3333) {       * compresw*     (of scan)       }
 410 ( 3333) 
 411 ( 3333) func compresw(index: integer);
 412 ( 3333) 
 413 ( 3333) var addr,ci,i: integer;
 414 ( 3336) 
 415 ( 3336) begin
 416 ( 3336)   addr:=8*index; i:=0;
 417 ( 3351)   repeat
 418 ( 3355)     ci:=ord(ident[i+1])-ord(reswtab[addr+i]);
 419 ( 3380)     i:=succ(i)

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         6/12/23 page 8

 420 ( 3385)   until (ci<>0) or (i>=8);
 421 ( 3408)   compresw:=ci
 422 ( 3412) end {compresw};
 423 ( 3420) 
 424 ( 3421) {       * clear *       (of scan)              }
 425 ( 3421) 
 426 ( 3421) proc clear; {clears 8 chars of identifier}
 427 ( 3421) 
 428 ( 3421) var i: integer;
 429 ( 3424) 
 430 ( 3424) begin
 431 ( 3424)   for i:=1 to 8 do ident[i]:=' '
 432 ( 3447) end;
 433 ( 3467) 
 434 ( 3468) {       * pack *        (of scan)              }
 435 ( 3468) 
 436 ( 3468) proc pack;  {packs token and ch to token }
 437 ( 3468) 
 438 ( 3468) begin
 439 ( 3468)   token:=packed(low(token),ch); getchr
 440 ( 3487) end;
 441 ( 3491) 
 442 ( 3492) {       * setval *      (of scan)              }
 443 ( 3492) 
 444 ( 3492) proc setval;
 445 ( 3492) 
 446 ( 3492) var r: real;
 447 ( 3495)     n,n1: integer;
 448 ( 3495)     ems: boolean;
 449 ( 3495) 
 450 ( 3495)   func times10(r:real):real;
 451 ( 3495)   { slightly more accurate than 10.0*r }
 452 ( 3495)   var r2,r4:real;
 453 ( 3498)   begin
 454 ( 3498)     r2:=r+r;
 455 ( 3506)     r4:=r2+r2;
 456 ( 3525)     times10:=r2+r4+r4;
 457 ( 3551)   end;
 458 ( 3564) 
 459 ( 3565) begin
 460 ( 3565)   r:=0.0;
 461 ( 3573)   repeat
 462 ( 3579)     r:=times10(r)+conv(ord(ch)-ord('0'));
 463 ( 3600)     getchr;
 464 ( 3612)   until (ch<'0') or (ch>'9');
 465 ( 3626)   if ch<>'.' then begin {numeric integer}
 466 ( 3640)     token:='nu';
 467 ( 3643)     value[0]:=trunc(r+0.5);
 468 ( 3662)   end
 469 ( 3667)   else begin {numeric real}
 470 ( 3670)     n:=0; getchr;
 471 ( 3680)     while (ch<='9') and (ch>='0') do begin
 472 ( 3698)       r:=times10(r)+conv(ord(ch)-ord('0'));
 473 ( 3719)       n:=prec(n); getchr
 474 ( 3736)     end;
 475 ( 3740)     if ch='e' then begin
 476 ( 3750)       ems:=false; getchr;
 477 ( 3763)       case ch of
 478 ( 3763)         '+': getchr;
 479 ( 3778)         '-': begin ems:=true; getchr end

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         6/12/23 page 9

 480 ( 3798)       end;
 481 ( 3800)       if (ch>'9') or (ch<'0') then error(17)
 482 ( 3820)       else begin
 483 ( 3829)         n1:=ord(ch)-ord('0');
 484 ( 3835)         getchr;
 485 ( 3844)         if (ch<='9') and (ch>='0') then begin
 486 ( 3859)           n1:=10*n1+ord(ch)-ord('0');
 487 ( 3876)           getchr
 488 ( 3881)         end;
 489 ( 3885)         if ems then n:=n-n1 else n:=n+n1
 490 ( 3912)       end
 491 ( 3912)     end;
 492 ( 3921)     while n>0 do begin
 493 ( 3931)       n:=prec(n);
 494 ( 3935)       r:=times10(r);
 495 ( 3954)     end;
 496 ( 3960)     while n<0 do begin
 497 ( 3973)       n:=succ(n); r:=0.1*r;
 498 ( 3988)     end;
 499 ( 4001)     splitconv(r,value);
 500 ( 4028)     token:='ru'
 501 ( 4028)   end
 502 ( 4031) end {setval};
 503 ( 4035) 
 504 ( 4036) {       * setid *       (of scan)              }
 505 ( 4036) 
 506 ( 4036) proc setid; {sets one char to ident}
 507 ( 4036) 
 508 ( 4036) begin
 509 ( 4036)   if count<=idlength then begin
 510 ( 4048)     ident[count]:=ch; count:=succ(count)
 511 ( 4063)   end;
 512 ( 4072)   getchr;
 513 ( 4076) end {setid};
 514 ( 4076) 
 515 ( 4077) begin { ***** body of scan ***** }
 516 ( 4077)   count:=1; while ch=' ' do getchr;
 517 ( 4099)   tpos:=curpos;
 518 ( 4105) 
 519 ( 4109)   { delayed because of token lookahead }
 520 ( 4109)   if nlflg then begin
 521 ( 4113)     if lineflg and (pc>2) then begin
 522 ( 4128)       code1($59);
 523 ( 4139)       code1((line) and 255);
 524 ( 4152)       code1((line) shr 8);
 525 ( 4165)     end;
 526 ( 4165)     nlflg:=false;
 527 ( 4167)   end;
 528 ( 4171) 
 529 ( 4171)   if (ch<'a') or (ch>'z') then begin {main if}
 530 ( 4189)     if (ch<'0') or (ch>'9') then begin {symb}
 531 ( 4207)       token:=packed(' ',ch); getchr;
 532 ( 4222)       case low(token) of
 533 ( 4226)         '<': if (ch='=') or (ch='>') then pack;
 534 ( 4256)         '>',':': if (ch='=') then pack;
 535 ( 4287)         '{': begin repeat
 536 ( 4297)                getchr until ch='}'; getchr; scan
 537 ( 4315)              end;
 538 ( 4319)         '$': begin {hex constant}
 539 ( 4329)                token:='nu'; value[0]:=0;

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         6/12/23 page 10

 540 ( 4340)                while ((ch>='0')and(ch<='9'))
 541 ( 4358)                      or((ch>='a')and(ch<='f'))
 542 ( 4373)                      do begin
 543 ( 4378)                  if ch>'9' then
 544 ( 4384)                    value[0]:=(value[0] shl 4)
 545 ( 4398)                      +ord(ch)-ord('a')+10
 546 ( 4407)                  else
 547 ( 4409)                    value[0]:=(value[0] shl 4)
 548 ( 4427)                      +ord(ch)-ord('0');
 549 ( 4435)                  getchr
 550 ( 4440)                end {do}
 551 ( 4444)              end; {hex constant}
 552 ( 4450)         chr(39): begin {string}
 553 ( 4457)                token:='st';
 554 ( 4460)                repeat setid until ch=chr(39);
 555 ( 4474)                value[0]:=prec(count); getchr
 556 ( 4490)               end
 557 ( 4494)       end {case of token}
 558 ( 4496)     end {special symbols}
 559 ( 4496)     else setval {numeric value}
 560 ( 4503)   end {main if}
 561 ( 4503)   else begin {ident}
 562 ( 4506)     clear;
 563 ( 4510)     repeat
 564 ( 4510)       setid
 565 ( 4510)       until (ch<'0') or (ch>'z') or
 566 ( 4528)         ((ch>'9') and (ch<'A')) or
 567 ( 4544)         ((ch>'Z') and (ch<'a'));
 568 ( 4560)     ll:=0; hh:=nresw; {look up in resword table}
 569 ( 4576)     repeat
 570 ( 4576)       i:=(ll+hh) shr 1; co:=compresw(i);
 571 ( 4604)       if (co<0) then hh:=prec(i)
 572 ( 4618)       else ll:=succ(i);
 573 ( 4634)       until (co=0) or (ll>hh);
 574 ( 4655)     if (co=0) then
 575 ( 4666)       token:=reswcod[i] {reserved word found}
 576 ( 4673)     else token:='id' {ident}
 577 ( 4687)   end {odent}
 578 ( 4691) end {scan};
 579 ( 4691) 
 580 ( 4692) { * testto/parse * }
 581 ( 4692) 
 582 ( 4692) { parce source for specific token; else error }
 583 ( 4692) 
 584 ( 4692) proc testto(x: packed char); { current token }
 585 ( 4692) begin
 586 ( 4692)   if token<>x then merror(2,x)
 587 ( 4711) end;
 588 ( 4721) 
 589 ( 4722) proc parse(x: packed char); { next token }
 590 ( 4722) begin
 591 ( 4722)   scan; testto(x);
 592 ( 4741) end;
 593 ( 4741) 
 594 ( 4742) { * getlib * }
 595 ( 4742) 
 596 ( 4742) proc getlib;  { read library data }
 597 ( 4742) 
 598 ( 4742) var i,j,nent,addr,size,num,x,base: integer;
 599 ( 4745)     libfil: file;

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         6/12/23 page 11

 600 ( 4745)     ch,ltyp2,dummy: char;
 601 ( 4745)     name: array[7] of char;
 602 ( 4745) 
 603 ( 4745) begin
 604 ( 4745)   scan; if token=' ,' then scan;
 605 ( 4766)   testto('id');
 606 ( 4775)   base:=pc-2;
 607 ( 4781)   if (ofno<>nooutput) then write(@ofno,'L');
 608 ( 4804)   for i:=0 to 7 do begin
 609 ( 4821)     name[i]:=ident[succ(i)];
 610 ( 4830)     if ofno<>nooutput then
 611 ( 4844)       write(@ofno,ident[succ(i)])
 612 ( 4858)   end;
 613 ( 4864)   write(prtoff);
 614 ( 4881)   asetfile(name&'        ',0,cdrive,'L');
 615 ( 4911)   openr(libfil);  { get table file }
 616 ( 4917)   read(@libfil,nent,size);
 617 ( 4932)   {including cr,lf}
 618 ( 4933)   for i:=succ(spnt) to spnt+nent do begin
 619 ( 4960)     if spnt>symbsize then error(7);
 620 ( 4979)     spnt:=succ(spnt); addr:=8*i+1;
 621 ( 4997)     for j:=0 to 7 do begin
 622 ( 5019)       read(@libfil,ch);
 623 ( 5029)       idtab[addr+j]:=ch
 624 ( 5039)     end;
 625 ( 5050)     read(@libfil,ch);
 626 ( 5074)     read(@libfil,t0[i],dummy,t1[i],t2[i],t3[i]);
 627 ( 5123)     t1[i]:=t1[i]+level;
 628 ( 5136)     ltyp2:=high(t0[i]);
 629 ( 5153)     if (ltyp2='p')or(ltyp2='f')
 630 ( 5171)       or(ltyp2='g') then begin
 631 ( 5181)       t2[i]:=t2[i]+base;
 632 ( 5196)       if t3[i]<>0 then begin {stack data}
 633 ( 5219)         read(@libfil,num);
 634 ( 5229)         push(num); t3[i]:=stackpnt;
 635 ( 5244)         for j:=1 to num do begin
 636 ( 5271)           read(@libfil,x);
 637 ( 5281)           push(x);
 638 ( 5292)         end {for j};
 639 ( 5292)       end {stack data}
 640 ( 5306)     end {if ltyp2}
 641 ( 5306)   end {for i}
 642 ( 5306)   level:=succ(level); pc:=pc+size; offset:=pc;
 643 ( 5342)   close(libfil);
 644 ( 5356)   if spnt>spntmax then spntmax:=spnt;
 645 ( 5368)   if stackpnt>stackmax then stackmax:=stackpnt;
 646 ( 5388)   if prt then write(prton);
 647 ( 5406) end {getlib};
 648 ( 5406) 
 649 ( 5407) 
 650 ( 5407) { #################################### }
 651 ( 5407) {       * block * (global): handle one block }
 652 ( 5407) { #################################### }
 653 ( 5407) 
 654 ( 5407) 
 655 ( 5407) proc block(bottom: integer);
 656 ( 5407) 
 657 ( 5407) var l,f9,i,n,stackpn1,forwpn,find,cproc,
 658 ( 5410)     spnt1,dpnt1,parlevel: integer;
 659 ( 5410)     fortab: array[8] of integer;

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         6/12/23 page 12

 660 ( 5410) 
 661 ( 5410) { * find ident *    (of block) }
 662 ( 5410) { this is a fast version for compiler speed }
 663 ( 5410) 
 664 ( 5410) func findid; {search in table for id }
 665 ( 5410) 
 666 ( 5410) var k,i: integer;
 667 ( 5413)     id1: char;
 668 ( 5413) 
 669 ( 5413) begin
 670 ( 5413) 
 671 ( 5413)   i:=1; k:=8*spnt+9; id1:=ident[1];
 672 ( 5437) 
 673 ( 5445)   repeat
 674 ( 5445)     k:=k-8;
 675 ( 5451)     while (idtab[k]<>id1) and (k>0) do k:=k-8;
 676 ( 5487)     if k>0 then begin
 677 ( 5502)        i:=1;
 678 ( 5507)        repeat i:=succ(i)
 679 ( 5511)          until (i>8) or
 680 ( 5527)              (idtab[k+i-1]<>ident[i]);
 681 ( 5553)     end;
 682 ( 5557)     until (i>8) or (k<=0);
 683 ( 5571)   if k<=0 then begin
 684 ( 5582)     findid:=0;
 685 ( 5587)   end
 686 ( 5591)   else
 687 ( 5591)     findid:=(k-1) shr 3;
 688 ( 5603) end;
 689 ( 5608) 
 690 ( 5609) { * code2 *    (of block) }
 691 ( 5609) 
 692 ( 5609) proc code2(x,y: integer);
 693 ( 5609) begin
 694 ( 5609)   code1(x); code1(y);
 695 ( 5634) end;
 696 ( 5634) 
 697 ( 5635) { * code3 *    (of block) }
 698 ( 5635) 
 699 ( 5635) proc code3(x: integer; y1: %integer);
 700 ( 5635) 
 701 ( 5635) var y: integer;
 702 ( 5638) 
 703 ( 5638) begin {code3}
 704 ( 5638)   y:=y1;
 705 ( 5640)   if (x=34) and (y>=0) and (y<256) then
 706 ( 5671)     code2(32,y)
 707 ( 5677)   else begin
 708 ( 5690)     if (x=35) and (y>-128) and (y<=127) then
 709 ( 5713)       begin
 710 ( 5714)         if (y<0) then y:=y+256;
 711 ( 5734)         code2(33,y);
 712 ( 5751)       end
 713 ( 5751)     else begin
 714 ( 5754)       if (x>=36) and (x<=38) then y:=y-pc-1;
 715 ( 5783)       code1(x); code1(y and 255);
 716 ( 5811)       code1(y shr 8);
 717 ( 5824)     end
 718 ( 5824)   end
 719 ( 5824) end {code3};

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         6/12/23 page 13

 720 ( 5824) 
 721 ( 5825) { * testtype *      (of block) }
 722 ( 5825) 
 723 ( 5825) proc testtype(ttype: char);
 724 ( 5825) 
 725 ( 5825) begin
 726 ( 5825)   if restype<>ttype then
 727 ( 5834)     if (restype<>'u') and (ttype<>'u') then
 728 ( 5856)       merror(14,packed(ttype,restype));
 729 ( 5877) end;
 730 ( 5877) 
 731 ( 5878) { * putsym *   (of block) }
 732 ( 5878) 
 733 ( 5878) proc putsym(ltyp1,ltyp2: char);
 734 ( 5878) 
 735 ( 5878) var i,addr: integer;
 736 ( 5881) begin
 737 ( 5881)   if spnt>symbsize then error(7)
 738 ( 5896)   else spnt:=succ(spnt);
 739 ( 5909)   if spnt>spntmax then spntmax:=spnt;
 740 ( 5926)   t0[spnt]:=packed(ltyp1,ltyp2);
 741 ( 5947)   t3[spnt]:=0;
 742 ( 5957)   addr:=8*spnt;
 743 ( 5963)   for i:=1 to 8 do idtab[addr+i]:=ident[i];
 744 ( 6002)   if ltyp1='v' then begin
 745 ( 6034)     t2[spnt]:=dpnt; dpnt:=succ(dpnt);
 746 ( 6053)   end;
 747 ( 6058)   t1[spnt]:=level
 748 ( 6062) end {putsym};
 749 ( 6070) 
 750 ( 6071) { * checkindex *  (of block) }
 751 ( 6071) 
 752 ( 6071) proc checkindex(lowlim,highlim: integer);
 753 ( 6071) begin
 754 ( 6071)   if icheck then begin
 755 ( 6080)     code3($40,lowlim-1);
 756 ( 6098)     code2(highlim and 255, highlim shr 8)
 757 ( 6111)   end
 758 ( 6118) end;
 759 ( 6118) 
 760 ( 6119) { * getcon *      (of block) }
 761 ( 6119) 
 762 ( 6119) func getcon;
 763 ( 6119) 
 764 ( 6119) var idpnt,val,ii: integer;
 765 ( 6122)     rval: real;
 766 ( 6122)     sign: char;
 767 ( 6122) begin
 768 ( 6122)   restype:='i';
 769 ( 6126)   if token=' -' then begin
 770 ( 6138)     sign:='-'; scan
 771 ( 6147)   end else begin
 772 ( 6154)     sign:='+'; if token=' +' then scan
 773 ( 6168)   end;
 774 ( 6175)   case token of
 775 ( 6175)     'nu': val:=value[0];
 776 ( 6189)     'ru': begin val:=value[0];
 777 ( 6210)             restype:='r' end;
 778 ( 6224)     'st': if value[0]=1 then begin
 779 ( 6244)             restype:='c';

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         6/12/23 page 14

 780 ( 6249)             val:=ord(ident[1])
 781 ( 6255)           end else if value[0]=2 then begin
 782 ( 6275)             val:=(ord(ident[1]) shl 8) +
 783 ( 6287)               ord(ident[2]);
 784 ( 6293)             restype:='p';
 785 ( 6300)           end else if value[0]>2 then begin
 786 ( 6316)             val:=pc;
 787 ( 6319)             for ii:=1 to value[0] do
 788 ( 6335)                         code1(ord(ident[ii]));
 789 ( 6362)             code1(0); value[0]:=0; restype:='s';
 790 ( 6394)           end else error(15);
 791 ( 6409)     'cr': begin parse(' ('); scan; val:=getcon;
 792 ( 6439)             if (val>127) or (val<0) then
 793 ( 6457)               error(12);
 794 ( 6469)             testtype('i');
 795 ( 6477)             restype:='c'; parse(' )');
 796 ( 6492)           end;
 797 ( 6492)     'tr': begin val:=1; restype:='b' end;
 798 ( 6515)     'fa': begin val:=0; restype:='b' end;
 799 ( 6538)     'cp': begin
 800 ( 6549)             scan; val:=getcon;
 801 ( 6559)             testtype('i'); restype:='q';
 802 ( 6573)           end;
 803 ( 6577)     ' @': begin scan; val:=getcon;
 804 ( 6598)             if restype<>'q' then testtype('i');
 805 ( 6620)             restype:='f'
 806 ( 6620)           end
 807 ( 6622)     else begin
 808 ( 6629)       testto('id'); idpnt:=findid;
 809 ( 6644)       if (idpnt>0) and (high(t0[idpnt])='c')
 810 ( 6666)       then begin
 811 ( 6668)         val:=t2[idpnt];
 812 ( 6675)         restype:=low(t0[idpnt]);
 813 ( 6691)         if restype='r' then
 814 ( 6702)           value[1]:=t3[idpnt];
 815 ( 6712)       end
 816 ( 6720)       else begin error(4); val:=0;
 817 ( 6733)         restype:='i'
 818 ( 6737)       end
 819 ( 6739)     end
 820 ( 6743)   end {case};
 821 ( 6745)   if sign='-' then
 822 ( 6751)     case restype of
 823 ( 6755)       'i': getcon:=-val;
 824 ( 6766)       'r': begin value[0]:=val;
 825 ( 6787)              splitconv(value,rval);
 826 ( 6819)              splitconv(-rval,value);
 827 ( 6844)              getcon:=value[0]
 828 ( 6846)            end
 829 ( 6846)       else error(12)
 830 ( 6859)     end {case}
 831 ( 6867)   else getcon:=val;
 832 ( 6870) end {getcon};
 833 ( 6878) 
 834 ( 6879) { * deccon *         ( of block ) }
 835 ( 6879) 
 836 ( 6879) proc deccon;    { declare constant }
 837 ( 6879) begin
 838 ( 6879)   if token=' ;' then scan;
 839 ( 6899)   testto('id');

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         6/12/23 page 15

 840 ( 6908)   putsym('c','i');
 841 ( 6918)   parse(' ='); scan;
 842 ( 6931)   t2[spnt]:=getcon;
 843 ( 6941)   if (restype='r') then t3[spnt]:=value[1];
 844 ( 6961)   if restype<>'i' then
 845 ( 6975)     t0[spnt]:=packed('c',restype);
 846 ( 6990)   scan
 847 ( 6994) end {deccon};
 848 ( 6998) 
 849 ( 6999) { * decvar *          ( of block ) }
 850 ( 6999) 
 851 ( 6999) proc decvar(typ1,typ2: char);
 852 ( 6999) begin
 853 ( 6999)   if token=' ,' then scan;
 854 ( 7019)   testto('id');
 855 ( 7028)   putsym(typ1,typ2);
 856 ( 7042)   scan;
 857 ( 7046) end {decvar};
 858 ( 7046) 
 859 ( 7047) { * gettype *         ( of block ) }
 860 ( 7047) 
 861 ( 7047) proc gettype(var typ2: char;
 862 ( 7047)   var aflag,uflag: boolean; var n: integer);
 863 ( 7047) 
 864 ( 7047) begin
 865 ( 7047)   aflag:=false; n:=0; uflag:=false;
 866 ( 7066)   scan;
 867 ( 7074)   if token='ar' then begin
 868 ( 7082)     parse(' ['); scan;
 869 ( 7098)     n:=getcon; testtype('i');
 870 ( 7116)     if (n<1) then begin error(15); n:=1 end;
 871 ( 7140)     parse(' ]'); parse('of'); scan;
 872 ( 7162)     aflag:=true
 873 ( 7162)   end;
 874 ( 7168)   if token=' %' then begin
 875 ( 7176)     scan; uflag:=true
 876 ( 7183)   end;
 877 ( 7189)   case token of
 878 ( 7189)     'in': typ2:='i';
 879 ( 7203)     'ch': typ2:='c';
 880 ( 7220)     'pa': begin parse ('ch'); typ2:='p' end;
 881 ( 7250)     'bo': typ2:='b';
 882 ( 7263)     'rl': begin typ2:='r'; aflag:=true;
 883 ( 7286)             n:=prec(2*succ(n)) end;
 884 ( 7303)     'cp': typ2:='q';
 885 ( 7316)     'fl': typ2:='f'
 886 ( 7331)     else begin error(11); typ2:='i';end
 887 ( 7354)   end {case}
 888 ( 7356) end {gettype};
 889 ( 7356) 
 890 ( 7357) { * variable *        ( of block) }
 891 ( 7357) 
 892 ( 7357) proc variable;  { variable declarations }
 893 ( 7357) 
 894 ( 7357) var typ1,typ2: char;
 895 ( 7360)     i,l: integer;
 896 ( 7360)     aflag,uflag: boolean;
 897 ( 7360) 
 898 ( 7360) begin
 899 ( 7360)   scan;

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         6/12/23 page 16

 900 ( 7366)   repeat {main loop}
 901 ( 7366)     l:=0;
 902 ( 7368)     repeat decvar('v','i'); l:=succ(l);
 903 ( 7386)     until token<> ' ,';
 904 ( 7398)     testto(' :');
 905 ( 7411)     gettype(typ2,aflag,uflag,n);
 906 ( 7447)     if uflag then error(11);
 907 ( 7462)     if aflag then typ1:='a' else typ1:='v';
 908 ( 7480)     if typ1='a' then begin {array}
 909 ( 7494)        dpnt:=dpnt-l; {variable has been assumed}
 910 ( 7507)        for i:=succ(spnt-l) to spnt do begin
 911 ( 7534)          t2[i]:=dpnt; t3[i]:=n;
 912 ( 7550)          dpnt:=succ(dpnt+n);
 913 ( 7567)       end
 914 ( 7572)     end {array};
 915 ( 7586)     for i:=succ(spnt-l) to spnt do
 916 ( 7600)       t0[i]:=packed(typ1,typ2);
 917 ( 7626)     parse(' ;');scan
 918 ( 7653)   until token<>'id' {end main loop}
 919 ( 7664) end {variable};
 920 ( 7668) 
 921 ( 7669) { * fixup *           ( of block ) }
 922 ( 7669) 
 923 ( 7669) proc fixup(x: integer);
 924 ( 7669) begin
 925 ( 7669)   if ofno<>nooutput then begin
 926 ( 7681)     write(@ofno,'F');
 927 ( 7692)     savebyte(succ(x-offset) and 255);
 928 ( 7711)     savebyte(succ(x-offset) shr 8);
 929 ( 7730)     savebyte((pc-x-1) and 255);
 930 ( 7751)     savebyte((pc-x-1) shr 8);
 931 ( 7772)   end;
 932 ( 7772) end;
 933 ( 7772) 
 934 ( 7773) { * function *        ( of block ) }
 935 ( 7773) 
 936 ( 7773) proc function;
 937 ( 7773) 
 938 ( 7773) var n: integer;
 939 ( 7776)     typ1,typ2: char;
 940 ( 7776)     aflag,uflag: boolean;
 941 ( 7776) begin
 942 ( 7776)   if token<>' :' then begin
 943 ( 7786)     aflag:=false; uflag:=false; typ2:='i' end
 944 ( 7803)   else begin
 945 ( 7810)     gettype(typ2,aflag,uflag,n);
 946 ( 7846)     scan
 947 ( 7846)   end;
 948 ( 7850)   if aflag then begin
 949 ( 7854)     typ1:='s'; t3[succ(cproc)]:=n;
 950 ( 7868)     t2[succ(cproc)]:=t2[succ(cproc)]-n
 951 ( 7890)   end
 952 ( 7890)   else typ1:='r';
 953 ( 7904)   t0[succ(cproc)]:=packed(typ1,typ2);
 954 ( 7922)   if uflag then typ2:='u';
 955 ( 7935)   if aflag then typ1:='g'
 956 ( 7946)   else typ1:='f';
 957 ( 7957)   t0[cproc]:=packed(typ1,typ2);
 958 ( 7974) end {function};
 959 ( 7978) 

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         6/12/23 page 17

 960 ( 7979) { * parameter *       ( of block ) }
 961 ( 7979) 
 962 ( 7979) proc parameter;
 963 ( 7979) 
 964 ( 7979) var counter1,counter2,i,n,bs: integer;
 965 ( 7982)     aflag,uflag: boolean;
 966 ( 7982)     vtype1,vtype2: char;
 967 ( 7982)     vtype: packed char;
 968 ( 7982) 
 969 ( 7982) begin
 970 ( 7982)   push(0); { dummy size, fixed later }
 971 ( 7992)   if find=0 then t3[spnt-npara]:=stackpnt
 972 ( 8011)   else bs:=stackpnt;
 973 ( 8022)   counter1:=0
 974 ( 8030)   repeat {main loop}
 975 ( 8036)     counter2:=0;
 976 ( 8038)     vtype1:='d'; vtype2:='i';
 977 ( 8050)     scan;
 978 ( 8058)     if token='co' then scan
 979 ( 8066)     else if token='va' then begin
 980 ( 8084)       scan; vtype1:='w' end; {variable param}
 981 ( 8097)     end;
 982 ( 8097)     repeat {inner loop}
 983 ( 8097)       decvar(vtype1,vtype2);
 984 ( 8111)       t2[spnt]:=parlevel;
 985 ( 8115)       parlevel:=succ(parlevel);
 986 ( 8127)       npara:=succ(npara);
 987 ( 8136)       counter2:=succ(counter2);
 988 ( 8145)       until token<>' ,';
 989 ( 8157)     uflag:=false;aflag:=false; n:=0;
 990 ( 8175)     if token<>' :' then
 991 ( 8186)       vtype2:='i' {assume integer }
 992 ( 8192)     else begin
 993 ( 8199)       gettype(vtype2,aflag,uflag,n);
 994 ( 8235)       if n>63 then error(15);
 995 ( 8253)       scan
 996 ( 8253)     end;
 997 ( 8257)     if aflag then begin
 998 ( 8261)       vtype1:=succ(vtype1);
 999 ( 8268)       parlevel:=parlevel-counter2;
1000 ( 8277)     end;
1001 ( 8286)     vtype:=packed(vtype1,vtype2);
1002 ( 8295)     for i:=1 to counter2 do begin
1003 ( 8318)       if uflag then push(packed(vtype1,'u'))
1004 ( 8332)       else push(vtype);
1005 ( 8351)       if aflag then begin
1006 ( 8355)         push(n); t3[spnt-counter2+i]:=n;
1007 ( 8382)         t2[spnt-counter2+i]:=parlevel;
1008 ( 8404)         parlevel:=succ(parlevel)+n;
1009 ( 8417)       end {then};
1010 ( 8426)       t0[spnt-counter2+i]:=vtype;
1011 ( 8440)     end {for};
1012 ( 8448)     if aflag then counter2:=2*counter2;
1013 ( 8471)     counter1:=counter1+counter2;
1014 ( 8484)     until token<>' ;'; {outer loop}
1015 ( 8504)   testto(' )'); scan;
1016 ( 8517)   if find=0 then
1017 ( 8523)     stack[t3[spnt-npara]]:=counter1
1018 ( 8540)   else begin {information is allready there}
1019 ( 8551)     stack[bs]:=counter1;

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         6/12/23 page 18

1020 ( 8555)     n:=t3[fortab[find]]; {existing stack data}
1021 ( 8579)     for i:=0 to stackpnt-bs do
1022 ( 8589)       if stack[bs+1]<>stack[n+1]
1023 ( 8620)         then merror(13,'pa'); {parameter wrong}
1024 ( 8654)     stackpnt:=prec(bs) {clear the new info}
1025 ( 8658)   end  {else}
1026 ( 8663) end {parameter};
1027 ( 8663) 
1028 ( 8664) { * memory *              ( of block) }
1029 ( 8664) 
1030 ( 8664) proc memory;
1031 ( 8664) 
1032 ( 8664) var typ1,typ2:char;
1033 ( 8667)     i,l,n: integer;
1034 ( 8667)     aflag,uflag: boolean;
1035 ( 8667) 
1036 ( 8667) begin
1037 ( 8667)   scan;
1038 ( 8673)   repeat {main loop}
1039 ( 8673)     l:=0;
1040 ( 8675)     repeat
1041 ( 8679)       decvar('m','i');
1042 ( 8689)       l:=succ(l); testto(' ='); scan;
1043 ( 8711)       n:=getcon; testtype('i');
1044 ( 8729)       scan; t2[spnt]:=n;
1045 ( 8737)     until token<>' ,';
1046 ( 8752)     testto(' :');
1047 ( 8765)     gettype(typ2,aflag,uflag,n);
1048 ( 8801)     if uflag then error(11);
1049 ( 8816)     scan;
1050 ( 8820)     if token=' &' then begin {8-bit}
1051 ( 8831)       typ1:='h'; scan
1052 ( 8837)     end
1053 ( 8841)     else typ1:='m';
1054 ( 8846)     if aflag then typ1:=succ(typ1);
1055 ( 8861)     for i:=succ(spnt-l) to spnt do begin
1056 ( 8893)       t0[i]:=packed(typ1,typ2);
1057 ( 8906)       t3[i]:=n;
1058 ( 8914)     end;
1059 ( 8922)     testto(' ;'); scan;
1060 ( 8949)   until token<>'id';
1061 ( 8956) end {memory};
1062 ( 8960) 
1063 ( 8961) 
1064 ( 8961) {######################################}
1065 ( 8961) { * statement *           ( of block ) }
1066 ( 8961) {######################################}
1067 ( 8961) 
1068 ( 8961) proc statmnt;
1069 ( 8961) 
1070 ( 8961) var idpnt,relad,k2,savpc,bottom1: integer;
1071 ( 8964)     device,wln: boolean;
1072 ( 8964)     savtp1,vartyp2: char;
1073 ( 8964)     wl: boolean;
1074 ( 8964) 
1075 ( 8964) { * code4 *               ( of statement ) }
1076 ( 8964) 
1077 ( 8964) proc code4(x,y1,z1: integer); {set 4-byte code}
1078 ( 8964) 
1079 ( 8964) var y,z: integer;

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         6/12/23 page 19

1080 ( 8967) 
1081 ( 8967) begin
1082 ( 8967)   y:=y1; z:=z1;
1083 ( 8977)   if y<0 then y:=y+256;
1084 ( 9002)   if x=43 then z:=z-pc-2;
1085 ( 9028)   code1(x);code1(y);code1(z and 255);
1086 ( 9066)   code1(z shr 8)
1087 ( 9072) end {code4};
1088 ( 9079) 
1089 ( 9080) { * testferror *         ( of statement) ) }
1090 ( 9080) 
1091 ( 9080) proc testferror;
1092 ( 9080) begin
1093 ( 9080)   code1($4f);
1094 ( 9093) end;
1095 ( 9093) 
1096 ( 9094) { * gpval *              ( of statement ) }
1097 ( 9094) 
1098 ( 9094) proc gpval(idpnt: integer;
1099 ( 9094)   dir: boolean; typ: char);
1100 ( 9094) 
1101 ( 9094) var d: integer;
1102 ( 9097) 
1103 ( 9097) begin {gpval}
1104 ( 9097)   if dir then d:=1 else d:=0;
1105 ( 9117)   case typ of
1106 ( 9121)   'h':  begin code3($22,t2[idpnt]);
1107 ( 9148)           if dir then code1($3f);
1108 ( 9163)           code1($17+d) end;
1109 ( 9176)   'm':  begin code3($22,t2[idpnt]);
1110 ( 9202)           code1($3d+d) end;
1111 ( 9215)   'i':  begin
1112 ( 9225)           if dir then code1($3f);
1113 ( 9240)           code3($22,t2[idpnt]);
1114 ( 9256)           code1(3);
1115 ( 9264)           if dir then code1($3f);
1116 ( 9279)           code1($17+d) end;
1117 ( 9292)   'n':  begin if dir then code1($3f);
1118 ( 9317)           code3($22,1); code1($12);
1119 ( 9335)           code3($22,t2[idpnt]);
1120 ( 9351)           code1(3); code1($3d+d) end
1121 ( 9372)   else begin
1122 ( 9375)     if typ='q' then begin
1123 ( 9382)       code4($55,level-t1[idpnt],2*t2[idpnt]);
1124 ( 9417)     end else
1125 ( 9417)       code4($27+2*d+relad,level-t1[idpnt],
1126 ( 9443)         2*t2[idpnt]);
1127 ( 9465)     end
1128 ( 9465)   end {case}
1129 ( 9467) end;
1130 ( 9467) 
1131 ( 9468) { FORWARD decl. of mainexp (of statement) }
1132 ( 9468) 
1133 ( 9468) proc mainexp(reqtype: char;
1134 ( 9468)   var arsize: integer); forward;
1135 ( 9471) 
1136 ( 9471) { * express *           ( of statement ) }
1137 ( 9471) 
1138 ( 9471) proc express; {requests a normal 16-bit result }
1139 ( 9471) 

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         6/12/23 page 20

1140 ( 9471) var resultsize: integer;
1141 ( 9474) 
1142 ( 9474) begin {express}
1143 ( 9474)   mainexp('n',resultsize);
1144 ( 9492)   if resultsize<>0 then error(15)
1145 ( 9504) end {express};
1146 ( 9510) 
1147 ( 9511) { * arrayexp *          ( of mainexp) }
1148 ( 9511) 
1149 ( 9511) proc arrayexp(size: integer; eltype: char);
1150 ( 9511) 
1151 ( 9511) var resultsize: integer;
1152 ( 9514) 
1153 ( 9514) begin
1154 ( 9514)   mainexp(eltype,resultsize);
1155 ( 9534)   if resultsize<>size then error(15);
1156 ( 9554)   testtype(eltype);
1157 ( 9564) end;
1158 ( 9564) 
1159 ( 9565) { * getvar *            ( of statement ) }
1160 ( 9565) 
1161 ( 9565) proc getvar;
1162 ( 9565) begin
1163 ( 9565)   vartyp2:=high(t0[idpnt]);
1164 ( 9578)   vartype:=low(t0[idpnt]);
1165 ( 9591)   scan;
1166 ( 9600)   if (vartype='q') and (token=' [') and
1167 ( 9615)     ((vartyp2='v') or (vartyp2='d')) then begin
1168 ( 9632)     vartyp2:='q'; vartype:='c';
1169 ( 9643)   end;
1170 ( 9647)   case vartyp2 of
1171 ( 9647)   'a','x','s','i','n','q':
1172 ( 9690)       begin
1173 ( 9693)         if token=' [' then begin
1174 ( 9701)           scan; express; relad:=1;
1175 ( 9714)           if vartyp2='r' then begin
1176 ( 9725)             relad:=3;
1177 ( 9730)             code3($22,1); code1($12)
1178 ( 9746)           end;
1179 ( 9752)           if (vartyp2='q') and (t3[idpnt]=0) then
1180 ( 9770)             checkindex(0,63)
1181 ( 9778)           else
1182 ( 9784)             checkindex(0,t3[idpnt]);
1183 ( 9803)           testtype('i'); testto(' ]'); scan;
1184 ( 9824)         end else relad:=2;
1185 ( 9829)       end;
1186 ( 9833)   'v','w','r','h','m': relad:=0;
1187 ( 9873)   'c','d','e','t','u': error(6)
1188 ( 9917)   else error(1)
1189 ( 9928)   end {case}
1190 ( 9936) end {getvar};
1191 ( 9936) 
1192 ( 9937) { * prcall *            ( of statement ) }
1193 ( 9937) 
1194 ( 9937) proc prcall (idpn1: integer);
1195 ( 9937) 
1196 ( 9937) var bstack,numpar,i,n,n2: integer;
1197 ( 9940) 
1198 ( 9940) { body of prcall follows later }
1199 ( 9940) 

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         6/12/23 page 21

1200 ( 9940) { * prcall1 *           ( of prcall ) }
1201 ( 9940) 
1202 ( 9940) proc prcall1;
1203 ( 9940) var ressize:integer;
1204 ( 9943) 
1205 ( 9943)   proc prcall3;
1206 ( 9943)   begin {prcall3}
1207 ( 9946)     testto('id');
1208 ( 9957)     idpnt:=findid;
1209 ( 9963)     if idpnt=0 then error(5);
1210 ( 9985)     getvar;
1211 ( 9989)     if chr(stack[i] and 255)<>vartype then
1212 (10001)       if chr(stack[i] and 255)<>'u' then
1213 (10023)         merror(14,'01');
1214 (10038)       push(idpnt);
1215 (10048)   end {prcall3};
1216 (10048) 
1217 (10049) begin {prcall1}
1218 (10049)   case chr(stack[i] shr 8) of
1219 (10062)     'd':  begin
1220 (10070)             if chr(stack[i] and 255) = 'q' then
1221 (10084)               mainexp('q',ressize)
1222 (10090)             else
1223 (10104)               express;
1224 (10111)             if chr(stack[i] and 255)<>'u' then
1225 (10125)               testtype(chr(stack[i] and 255));
1226 (10147)           end;
1227 (10147)     'e':  begin
1228 (10157)             arrayexp(stack[succ(i)],
1229 (10162)               chr(stack[i]));
1230 (10181)             i:=succ(i);
1231 (10185)           end;
1232 (10190)     'w':  begin
1233 (10200)             prcall3;
1234 (10204)             if relad<>0 then merror(14,'02');
1235 (10225)             gpval(idpnt,false,vartyp2);
1236 (10241)           end;
1237 (10241)     'x':  begin
1238 (10251)             prcall3;
1239 (10255)             if relad<>2 then merror(14,'03');
1240 (10276)             if vartyp2='i' then error(16);
1241 (10294)             i:=succ(i);
1242 (10298)             if stack[i]<>t3[idpnt] then
1243 (10315)               error(15);
1244 (10331)             if vartyp2='n' then begin
1245 (10338)               code3($22,t2[idpnt]);
1246 (10357)               code1($3d);
1247 (10365)             end else code4($27,level-t1[idpnt],
1248 (10378)               2*t2[idpnt]);
1249 (10400)             code2($3b,stack[i]);
1250 (10416)           end
1251 (10416)     else merror(14,'04')
1252 (10424)   end {case}
1253 (10432) end {prcall1};
1254 (10432) 
1255 (10433) proc prcall2;
1256 (10433) begin
1257 (10433)   if n>0 then code3(35,-2*n);
1258 (10464)   n:=0
1259 (10464) end {prcall2};

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         6/12/23 page 22

1260 (10470) 
1261 (10471) begin {body of prcall}
1262 (10471)   if t3[idpn1]<>0 then begin
1263 (10484)     bstack:=t3[idpn1];
1264 (10491)     numpar:=stack[bstack];
1265 (10503)     parse(' ('); scan;
1266 (10524)     for i:=succ(bstack) to bstack+numpar do
1267 (10537)     begin
1268 (10551)       prcall1;
1269 (10555)       if i<bstack+numpar then begin
1270 (10569)         testto(' ,'); scan
1271 (10581)       end
1272 (10585)     end;
1273 (10585)     testto(' )');
1274 (10608)   end {then};
1275 (10608)   code4(43,level-t1[idpn1],t2[idpn1]);
1276 (10637)   if t3[idpn1]<>0 then begin
1277 (10648)     n:=0; i:=bstack+numpar;
1278 (10661)     repeat
1279 (10670)       case chr(stack[i] shr 8) of
1280 (10681)       'd':  n:=succ(n);
1281 (10693)       'w':  begin
1282 (10708)               prcall2; idpnt:=pop;
1283 (10718)               gpval(idpnt,true,
1284 (10728)                   high(t0[idpnt]));
1285 (10743)             end;
1286 (10743)       chr(0): begin
1287 (10753)             n2:=stack[i];
1288 (10757)             i:=i-1;
1289 (10771)             case chr(stack[i] shr 8) of
1290 (10787)               'e':  n:=succ(n+n2);
1291 (10804)               'x':  begin
1292 (10819)                       prcall2;
1293 (10823)                       idpnt:=pop;
1294 (10829)                       if high(t0[idpnt])='n'
1295 (10842)                       then begin
1296 (10845)                         code3($22,t2[idpnt]+
1297 (10854)                           2*t3[idpnt]);
1298 (10876)                         code1($3e)
1299 (10878)                       end else
1300 (10884)                         code4(41,
1301 (10889)                           level-t1[idpnt],
1302 (10897)                           2*(t2[idpnt]+
1303 (10908)                           t3[idpnt]));
1304 (10928)                       code2($3c,t3[idpnt])
1305 (10934)                     end
1306 (10944)               end {case}
1307 (10946)             end
1308 (10946)       end; {case}
1309 (10948)       i:=prec(i);
1310 (10952)     until i=bstack;
1311 (10961)     prcall2
1312 (10969)   end
1313 (10973) end {prcall};
1314 (10973) 
1315 (10974) 
1316 (10974) {###################################}
1317 (10974) { * mainexp *       ( of statement) }
1318 (10974) {###################################}
1319 (10974) {  see forward declaration above    }

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         6/12/23 page 23

1320 (10974) 
1321 (10974) proc mainexp(reqtype: char;
1322 (10974)   var arsize: integer);
1323 (10974) 
1324 (10974) { variables of mainexp}
1325 (10974) var opcode,roff: integer;
1326 (10977)     savtype: char;
1327 (10977) 
1328 (10977) { * argument *         ( of mainexp ) }
1329 (10977) 
1330 (10977) proc argument(rtype: char);
1331 (10977) begin
1332 (10977)   parse(' ('); scan; express;
1333 (10999)   testtype(rtype);
1334 (11009)   testto(' )'); scan
1335 (11018) end; {argument}
1336 (11023) 
1337 (11023) {#######################################}
1338 (11023) { * simexp *             ( of mainexp ) }
1339 (11023) {#######################################}
1340 (11023) 
1341 (11023) proc simexp(var arsize1: integer);
1342 (11023) 
1343 (11023) var opcode: integer;
1344 (11026)     sign: char;
1345 (11026) 
1346 (11026) {body of simexp  follows later }
1347 (11026) 
1348 (11026) {#######################################}
1349 (11026) { * term *               ( of simexp )  }
1350 (11026) {#######################################}
1351 (11026) 
1352 (11026) proc term(var arsize2: integer);
1353 (11026) 
1354 (11026) var opcode: integer;
1355 (11029) 
1356 (11029) { body of term follows later }
1357 (11029) 
1358 (11029) {#######################################}
1359 (11029) { * factor *             ( of term )    }
1360 (11029) {#######################################}
1361 (11029) 
1362 (11029) proc factor(var arsize3: integer);
1363 (11029) 
1364 (11029) var i, idpnt: integer;
1365 (11032)     h: char;
1366 (11032) 
1367 (11032) { * index *              ( of factor )  }
1368 (11032) 
1369 (11032) proc index(chk: boolean);
1370 (11032) 
1371 (11032) var savtype: char;
1372 (11035) 
1373 (11035) begin {index}
1374 (11035)   scan; savtype:=restype;
1375 (11041)   express; testtype('i'); testto(' ]');
1376 (11070)   if savtype='r' then begin
1377 (11077)     code3($22,1); code1($12);
1378 (11098)   end;
1379 (11098)   if chk then begin

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         6/12/23 page 24

1380 (11102)     if (savtype='q') and (t3[idpnt]=0) then
1381 (11123)       { is an arrayed cpnt }
1382 (11124)       checkindex(0,63)
1383 (11131)     else
1384 (11137)       checkindex(0,t3[idpnt]);
1385 (11156)   end;
1386 (11156)   restype:=savtype; scan
1387 (11164) end;
1388 (11168) 
1389 (11169) 
1390 (11169) begin { *** body of factor *** }
1391 (11169)   arsize3:=0;
1392 (11173)   case token of
1393 (11177)     'id': begin {identifier }
1394 (11189)             idpnt:=findid;
1395 (11195)             if idpnt=0 then error(5);
1396 (11217)             restype:=low(t0[idpnt]);
1397 (11225)             h:=high(t0[idpnt]);
1398 (11238)             case h of
1399 (11243)               'v','w','d':
1400 (11265)                     begin
1401 (11268)                       scan;
1402 (11272)                       if (restype='q') and (token=' [')
1403 (11286)                       then begin
1404 (11288)                         code4(39,level-t1[idpnt],
1405 (11301)                           2*t2[idpnt]);
1406 (11323)                         index(true);
1407 (11331)                         code1($03);
1408 (11339)                         code1($54);
1409 (11347)                         restype:='c';
1410 (11349)                       end else
1411 (11353)                         code4(39,level-t1[idpnt],
1412 (11366)                           2*t2[idpnt]);
1413 (11388)                     end;
1414 (11388)               'h':  begin code3($22,t2[idpnt]);
1415 (11414)                       code1($17); scan end;
1416 (11426)               'i':  begin code3($22,t2[idpnt]);
1417 (11452)                       scan;
1418 (11456)                       if token=' [' then begin
1419 (11464)                         index(true); code1($03);
1420 (11483)                         code1($17)
1421 (11485)                       end else begin
1422 (11494)                         error(16)
1423 (11496)                       end
1424 (11502)                     end;
1425 (11502)               'm':  begin code3($22,t2[idpnt]);
1426 (11528)                       code1($3d); scan
1427 (11536)                     end;
1428 (11540)               'n':  begin code3($22,t2[idpnt]);
1429 (11566)                       scan;
1430 (11570)                       if token=' [' then begin
1431 (11578)                         index(true);
1432 (11589)                         code3($22,1);code1($12);
1433 (11607)                         code1($03); code1($3d);
1434 (11623)                         if restype='r' then
1435 (11629)                         begin
1436 (11630)                           code2($3b,1);
1437 (11643)                           arsize3:=1
1438 (11643)                         end
1439 (11645)                       end else begin

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         6/12/23 page 25

1440 (11652)                         code1($3d);
1441 (11660)                         code2($3b,t3[idpnt]);
1442 (11676)                         arsize3:=t3[idpnt];
1443 (11680)                       end
1444 (11688)                     end;
1445 (11688)               'r','t': begin
1446 (11705)                       code3(35,2);
1447 (11715)                       idpnt:=prec(idpnt);
1448 (11719)                       prcall(idpnt); scan;
1449 (11738)                       restype:=low(t0[idpnt]);
1450 (11746)                     end;
1451 (11751)               'c':  if low(t0[idpnt])<>'r' then begin
1452 (11773)                       code3(34,t2[idpnt]);
1453 (11792)                       scan;
1454 (11796)                       if restype='s' then begin
1455 (11803)                         if token=' [' then begin
1456 (11814)                           index(true);
1457 (11825)                           code1($03);
1458 (11833)                           code1($58);
1459 (11841)                           code1($54);
1460 (11849)                           restype:='c';
1461 (11851)                         end else begin
1462 (11858)                           code1($58);
1463 (11866)                           restype:='q';
1464 (11868)                         end;
1465 (11872)                       end;
1466 (11872)                       {scan;}
1467 (11872)                     end else begin
1468 (11875)                       code2($3a,2);
1469 (11885)                       code2(t2[idpnt] and 255,
1470 (11895)                         t2[idpnt] shr 8);
1471 (11913)                       code2(t3[idpnt] and 255,
1472 (11923)                         t3[idpnt] shr 8);
1473 (11941)                       arsize3:=1; scan
1474 (11947)                     end;
1475 (11951)               'a','e','x':
1476 (11972)                     begin scan;
1477 (11979)                       if token=' [' then begin
1478 (11987)                         index(true);
1479 (11998)                         code4($28,
1480 (12000)                             level-t1[idpnt],
1481 (12008)                             2*t2[idpnt]);
1482 (12030)                         if restype='r' then
1483 (12036)                         begin
1484 (12037)                           code2($3b,1);
1485 (12050)                           arsize3:=1
1486 (12050)                         end
1487 (12052)                       end else begin
1488 (12059)                         code4($27,
1489 (12061)                             level-t1[idpnt],
1490 (12069)                             2*t2[idpnt]);
1491 (12091)                         code2($3b,t3[idpnt]);
1492 (12107)                         arsize3:=t3[idpnt];
1493 (12111)                       end
1494 (12119)                     end;
1495 (12119)               's','u':
1496 (12133)                     begin
1497 (12136)                       code3(35,2*t3[idpnt]+2);
1498 (12158)                       idpnt:=prec(idpnt);
1499 (12162)                       prcall(idpnt); scan;

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         6/12/23 page 26

1500 (12181)                       restype:=low(t0[idpnt]);
1501 (12189)                       idpnt:=succ(idpnt);
1502 (12198)                       arsize3:=t3[idpnt]
1503 (12203)                     end
1504 (12207)               else error(1)
1505 (12220)             end {case}
1506 (12228)           end; {identifier}
1507 (12231)     'nu': begin code3(34,value[0]); scan;
1508 (12257)             restype:='i'
1509 (12257)           end;
1510 (12263)     'ru': begin code2($3a,2);
1511 (12284)             code2(value[0] and 255,
1512 (12292)               value[0] shr 8);
1513 (12308)             code2(value[1] and 255,
1514 (12316)               value[1] shr 8);
1515 (12332)             scan; restype:='r';
1516 (12338)             arsize3:=1
1517 (12342)           end;
1518 (12348)     'st': begin
1519 (12359)           if (reqtype='n') and (value[0]<3)
1520 (12374)             then begin
1521 (12376)               if value[0]<2 then begin
1522 (12388)                 code3(34,ord(ident[1]));
1523 (12405)                 restype:='c'
1524 (12405)               end else begin
1525 (12414)                 code3(34,packed(ident[1],
1526 (12418)                   ident[2]));
1527 (12435)                 restype:='p'
1528 (12435)               end
1529 (12437)             end else begin
1530 (12444)               case reqtype of
1531 (12444)                 'c','u','n','q':
1532 (12473)                     begin
1533 (12476)                       if (vartype='q') or
1534 (12483)                          (reqtype='q') then begin
1535 (12491)                         arsize3:=0;
1536 (12496)                         restype:='q';
1537 (12502)                         code2($56,value[0]);
1538 (12520)                       end else begin
1539 (12523)                         arsize3:=prec(value[0]);
1540 (12529)                         restype:='c';
1541 (12536)                         code2($39,value[0]);
1542 (12554)                       end;
1543 (12554)                       for i:=1 to value[0] do
1544 (12562)                         code1(ord(ident[i]));
1545 (12589)                       if (vartype='q') or
1546 (12610)                          (reqtype='q') then code1(0);
1547 (12629)                     end;
1548 (12629)                 'p': begin
1549 (12639)                       if odd(value[0]) then
1550 (12645)                         error(15);
1551 (12657)                       value[0]:=value[0] shr 1;
1552 (12667)                       arsize3:=prec(value[0]);
1553 (12678)                       restype:='p';
1554 (12685)                       code2($3a,value[0]);
1555 (12703)                       for i:=1 to value[0] do
1556 (12711)                         begin
1557 (12724)                         code1(ident[2*i]);
1558 (12741)                         code1(ident[2*i-1]);
1559 (12761)                       end

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         6/12/23 page 27

1560 (12761)                     end
1561 (12761)                 else merror(14,'05')
1562 (12783)               end {case}
1563 (12791)             end;
1564 (12791)             scan
1565 (12791)           end;
1566 (12795)     'od': begin
1567 (12806)             argument('i'); code1(7);
1568 (12822)             restype:='b'
1569 (12822)           end;
1570 (12828)     'me': begin
1571 (12839)             parse(' ['); index(false);
1572 (12856)             code1(23); restype:='i';
1573 (12866)           end;
1574 (12870)     ' (': begin
1575 (12881)             scan; mainexp(reqtype,arsize3);
1576 (12903)             testto(' )'); scan
1577 (12912)           end; {no type change}
1578 (12919)     'no': begin
1579 (12927)             scan; factor(arsize3);
1580 (12943)             if (arsize3<>0) then error(15);
1581 (12961)             code1($11);
1582 (12969)             if restype<>'i' then
1583 (12975)               testtype('b')
1584 (12981)           end;
1585 (12987)     'cr': begin
1586 (12998)             argument('i'); code1(52);
1587 (13014)             restype:='c'
1588 (13014)           end;
1589 (13020)     'hi': begin
1590 (13031)             argument('p'); code1(51);
1591 (13047)             restype:='c'
1592 (13047)           end;
1593 (13053)     'lo': begin
1594 (13064)             argument('p'); code1(52);
1595 (13080)             restype:='c'
1596 (13080)           end;
1597 (13086)     'su': begin
1598 (13097)             argument('u'); code1($14);
1599 (13113)           end;
1600 (13113)     'pc': begin
1601 (13124)             argument('u'); code1($15)
1602 (13134)           end;
1603 (13140)     'cp': begin
1604 (13151)             argument('i'); restype:='q';
1605 (13161)           end;
1606 (13165)     'ni': begin
1607 (13176)             code3(34,0); scan; restype:='q';
1608 (13192)           end;
1609 (13196)     'ox': begin
1610 (13207)             argument('u');
1611 (13215)             restype:='i'
1612 (13215)           end;
1613 (13221)     ' @': begin
1614 (13232)             scan; factor(arsize3);
1615 (13248)             if arsize3<>0 then error(15);
1616 (13266)             if restype<>'q' then testtype('i');
1617 (13284)             restype:='f'
1618 (13284)           end;
1619 (13290)     'tr': begin

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         6/12/23 page 28

1620 (13301)             code3(34,1); scan;
1621 (13315)             restype:='b';
1622 (13317)           end;
1623 (13321)     'fa': begin
1624 (13332)             code3(34,0); scan;
1625 (13346)             restype:='b'
1626 (13346)           end;
1627 (13352)     'tc': begin
1628 (13363)             parse(' ('); scan;
1629 (13376)             arrayexp(1,'r');
1630 (13386)             testto(' )'); scan;
1631 (13399)             code1($47); restype:='i';
1632 (13409)           end;
1633 (13413)     'cv': begin
1634 (13424)             argument('i');
1635 (13432)             code1($46); arsize3:=1;
1636 (13442)             restype:='r'
1637 (13446)           end;
1638 (13452)     'pa': begin
1639 (13463)             parse(' ('); scan; express;
1640 (13480)             testtype('c');
1641 (13488)             if token=' ,' then begin
1642 (13496)               scan; express; testtype('c');
1643 (13515)               code1(53)
1644 (13517)             end;
1645 (13523)             testto(' )'); scan; restype:='p'
1646 (13536)           end
1647 (13538)     else error(1)
1648 (13547)   end {case of token}
1649 (13555) end {factor};
1650 (13555) 
1651 (13556) begin  { *** body of term *** }
1652 (13556)   factor(arsize2);
1653 (13570)   repeat
1654 (13570)     case token of
1655 (13570)       ' *': opcode:=5;
1656 (13584)       'di': opcode:=6;
1657 (13601)       'an': opcode:=15;
1658 (13618)       'sh': opcode:=18;
1659 (13635)       'sr': opcode:=19;
1660 (13652)       ' /': opcode:=$45
1661 (13667)       else opcode:=0
1662 (13676)     end {case};
1663 (13684)     if opcode>0 then begin
1664 (13691)       if (restype='r') and
1665 (13701)             (arsize2=1) then begin
1666 (13709)         scan; factor(arsize2);
1667 (13728)         if (restype<>'r') or (arsize2<>1) then
1668 (13742)           merror(14,'06');
1669 (13757)         case opcode of
1670 (13757)           5: code1($44);
1671 (13776)           $45: code1($45)
1672 (13788)           else error(17)
1673 (13799)         end{case}
1674 (13807)       end else begin
1675 (13810)         if opcode=$45 then error(9);
1676 (13828)         if arsize2<>0 then error(15);
1677 (13846)         if (restype='b') and (opcode=15)
1678 (13859)           then begin
1679 (13861)           scan; factor(arsize2);

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         6/12/23 page 29

1680 (13880)           if arsize2<>0 then error(15);
1681 (13898)           testtype('b');
1682 (13906)           code1(opcode)
1683 (13906)         end else begin
1684 (13919)           testtype('i'); scan;
1685 (13931)           factor(arsize2);
1686 (13943)           if arsize2<>0 then error(15);
1687 (13961)           testtype('i'); code1(opcode);
1688 (13979)         end
1689 (13979)       end
1690 (13979)     end;
1691 (13979)   until opcode=0;
1692 (13985) end {term};
1693 (13989) 
1694 (13990) 
1695 (13990) begin { *** body of simexp *** }
1696 (13990)   sign:=' ';
1697 (13994)   if token=' +' then begin
1698 (14006)     sign:='+'; scan
1699 (14015)   end else if token=' -' then begin
1700 (14030)     sign:='-'; scan
1701 (14039)   end;
1702 (14043)   term(arsize1);
1703 (14055)   if sign<>' ' then begin
1704 (14062)     if (restype='r')and (arsize1=1) then begin
1705 (14080)       if sign='-' then code1($4e)
1706 (14095)     end else begin
1707 (14104)       testtype('i');
1708 (14112)       if arsize1<>0 then error(15);
1709 (14130)       if sign='-' then code1(2);
1710 (14148)     end
1711 (14148)   end;
1712 (14148)   repeat
1713 (14148)     case token of
1714 (14148)       ' &': opcode:=1;
1715 (14162)       ' +': opcode:=3;
1716 (14179)       ' -': opcode:=4;
1717 (14196)       'or': opcode:=14;
1718 (14213)       'xo': opcode:=16
1719 (14228)       else opcode:=0
1720 (14237)     end {case};
1721 (14245)     if opcode>1 then begin {if 1}
1722 (14255)       if (restype='r') and (arsize1=1)
1723 (14268)         then begin {real}
1724 (14273)         scan; term(arsize1);
1725 (14289)         if (restype<>'r') or (arsize1<>1) then
1726 (14303)           error(17);
1727 (14315)         case opcode of
1728 (14315)           3:  code1($42);
1729 (14334)           4:  code1($43)
1730 (14346)           else error(17)
1731 (14357)         end {case}
1732 (14365)       end {real}
1733 (14365)       else begin {not real}
1734 (14368)         if (arsize1<>0) then error(15);
1735 (14386)         if (restype='b') and (opcode>=14)
1736 (14399)           then begin {boolean}
1737 (14404)           scan; term(arsize1);
1738 (14420)           if arsize1<>0 then error(15);
1739 (14438)           testtype('b'); code1(opcode)

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         6/12/23 page 30

1740 (14446)         end {boolean}
1741 (14456)         else begin {not boolean}
1742 (14459)           testtype('i'); scan;
1743 (14471)           term(arsize1);
1744 (14483)           if arsize1<>0 then error(15);
1745 (14501)           testtype('i'); code1(opcode);
1746 (14519)         end {not boolean}
1747 (14519)       end {not real}
1748 (14519)     end {if 1}
1749 (14519)     else if opcode=1 then begin {else 1}
1750 (14532)       sign:=restype;
1751 (14532)       scan; term(opcode);
1752 (14556)       arsize1:=arsize1+opcode+1;
1753 (14567)       testtype(sign)
1754 (14572)     end {else 1}
1755 (14582)   until opcode=0
1756 (14586) end {simexp};
1757 (14592) 
1758 (14593) 
1759 (14593) begin { *** body of mainexp *** }
1760 (14593)   roff:=0;
1761 (14597)   simexp(arsize);
1762 (14613)   if (restype='r') and (arsize=1) then
1763 (14627)     roff:=$40;
1764 (14633)   case token of
1765 (14637)     ' =': opcode:=8;
1766 (14651)     ' <': opcode:=10;
1767 (14668)     ' >': opcode:=12;
1768 (14685)     '<>': opcode:=9;
1769 (14702)     '<=': opcode:=13;
1770 (14719)     '>=': opcode:=11
1771 (14734)     else opcode:=0
1772 (14743)   end {case};
1773 (14751)   if opcode>0 then begin
1774 (14758)     if (arsize<>0) and (roff=0) then
1775 (14775)       error(15);
1776 (14787)     scan; savtype:=restype; simexp(arsize);
1777 (14811)     if ((roff=0) and (arsize<>0))
1778 (14825)       or((roff<>0) and (arsize>1)) then
1779 (14841)       error(15);
1780 (14853)     testtype(savtype); code1(opcode+roff);
1781 (14878)     arsize:=0; restype:='b'
1782 (14884)   end
1783 (14886) end {mainexp};
1784 (14890) 
1785 (14891) 
1786 (14891) {#########################################}
1787 (14891) { * assign *             ( of statement ) }
1788 (14891) {#########################################}
1789 (14891) 
1790 (14891) proc assign;
1791 (14891) 
1792 (14891) var savetype: char;
1793 (14894) 
1794 (14894)   proc assign1;
1795 (14894)   begin
1796 (14894)     testto(':='); scan; express;
1797 (14916)     if (vartype='q') and (restype='s') then begin
1798 (14931)       code1($58); restype:='q';
1799 (14944)     end;

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         6/12/23 page 31

1800 (14948)     gpval(idpnt,true,vartyp2);
1801 (14964)   end {assign1};
1802 (14964) 
1803 (14965) begin {assign}
1804 (14965)   idpnt:=findid;
1805 (14973)   if idpnt=0 then error(5);
1806 (14995)   if t0[idpnt]='pr' then begin
1807 (15007)     prcall(idpnt);scan end
1808 (15024)   else begin
1809 (15027)     getvar; savetype:=vartype;
1810 (15031)     if relad<2 then begin
1811 (15046)       assign1; testtype(vartype)
1812 (15053)     end else begin
1813 (15066)       if vartyp2='i' then error(16); {8-bit mem}
1814 (15084)       testto(':='); scan;
1815 (15097)       if relad=3 then begin
1816 (15104)         arrayexp(1,vartype); relad:=1;
1817 (15121)         code1($53);
1818 (15133)         if vartyp2='n' then begin
1819 (15140)           code1($3f);
1820 (15151)           code3($22,1);code1($12);
1821 (15169)           code3($22,t2[idpnt]+2);
1822 (15188)           code1($3);code1($3e)
1823 (15198)         end else
1824 (15204)           code4($2a,level-t1[idpnt],
1825 (15217)             2*t2[idpnt]+2);
1826 (15242)         code2($3c,1)
1827 (15246)       end else begin
1828 (15255)         arrayexp(t3[idpnt],vartype);
1829 (15273)         if vartyp2='n' then begin
1830 (15280)           code3($22,t2[idpnt]+2*t3[idpnt]);
1831 (15311)           code1($3e);
1832 (15319)         end else
1833 (15319)           code4($29,level-t1[idpnt],
1834 (15332)             2*(t2[idpnt]+t3[idpnt]));
1835 (15363)         code2($3c,t3[idpnt]);
1836 (15379)       end
1837 (15379)     end
1838 (15379)   end
1839 (15379) end {assign};
1840 (15379) 
1841 (15380) { * case1 *             ( of statement ) }
1842 (15380) 
1843 (15380) proc case1;
1844 (15380) 
1845 (15380) var i1,i2,casave: integer;
1846 (15383)     savetype: char;
1847 (15383) 
1848 (15383)   proc case2;
1849 (15383) 
1850 (15383)     proc case3;
1851 (15386)     begin
1852 (15386)       scan; code1(22); code3(34,getcon);
1853 (15417)       testtype(savetype);
1854 (15427)       code1(8); scan
1855 (15435)     end;
1856 (15439) 
1857 (15440)   begin {case2}
1858 (15440)     i1:=0; case3;
1859 (15452)     while token=' ,' do begin

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         6/12/23 page 32

1860 (15463)       push(pc); code3(38,0); i1:=succ(i1);
1861 (15487)       case3
1862 (15492)     end;
1863 (15496)     testto(' :'); savpc:=pc; code3(37,0);
1864 (15526)     for k2:=1 to i1 do fixup(pop);
1865 (15557)     push(savpc);
1866 (15581)     scan; statmnt
1867 (15585)   end {case2};
1868 (15589) 
1869 (15590) begin {case1}
1870 (15590)   scan; express; testto('of');
1871 (15609)   savetype:=restype; i2:=1; case2;
1872 (15627)   while token=' ;' do begin
1873 (15638)     casave:=pc; code3(36,0); fixup(pop);
1874 (15668)     push(casave); i2:=succ(i2); case2
1875 (15687)   end;
1876 (15691)   if token='el' then begin
1877 (15702)     casave:=pc; code3(36,0); fixup(pop);
1878 (15735)     push(casave); scan; statmnt
1879 (15749)   end;
1880 (15753)   testto('en'); for k2:=1 to i2 do fixup(pop);
1881 (15793)   code3(35,-2); scan
1882 (15818) end {case1};
1883 (15822) 
1884 (15823) { * openrw *              ( of statement ) }
1885 (15823) 
1886 (15823) proc openrw(x: integer);
1887 (15823) begin
1888 (15823)   parse(' ('); parse('id');
1889 (15846)   idpnt:=findid;
1890 (15852)   if idpnt=0 then error(5);
1891 (15874)   getvar; code1(x);
1892 (15888)   testferror;
1893 (15892)   if relad=2 then error(15);
1894 (15910)   if vartype<>'f' then merror(14,'07');
1895 (15931)   gpval(idpnt,true,vartyp2);
1896 (15947)   testto(' )'); scan
1897 (15956) end {openrw};
1898 (15960) 
1899 (15961) { * gpsec *               ( of statement )  }
1900 (15961) 
1901 (15961) proc gpsec(code);   { get/put sector }
1902 (15961) 
1903 (15961)   proc gpsec1;
1904 (15964)   begin
1905 (15964)     scan; express; testtype('i');
1906 (15985)     testto(' ,');
1907 (15994)   end;
1908 (15994) 
1909 (15995) begin {gpsec}
1910 (15995)   parse(' ('); gpsec1; gpsec1; gpsec1;
1911 (16018)   code1(code);
1912 (16028)   parse('id'); idpnt:=findid;
1913 (16043)   if idpnt=0 then error(5);
1914 (16065)   getvar; code3(34,$db); { get file error code }
1915 (16079)   if relad=2 then error(15);
1916 (16097)   code1(23); if vartype<>'i' then merror(14,'08');
1917 (16126)   gpval(idpnt,true,vartyp2);
1918 (16142)   testto(' )');
1919 (16151) end {gpsec};

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         6/12/23 page 33

1920 (16151) 
1921 (16152) 
1922 (16152) begin {body of statement }
1923 (16152)   if token=' ;' then scan;
1924 (16169)   case token of
1925 (16169)     'id': assign;
1926 (16185) 
1927 (16188)     'if': begin {if}
1928 (16196)             scan; express; testtype('b');
1929 (16212)             testto('th'); scan;  savpc:=pc;
1930 (16225)             code3(37,0); statmnt;
1931 (16247)             if token='el' then begin {else}
1932 (16258)               k2:=pc; code3(36,0);
1933 (16276)               fixup(savpc); scan; statmnt;
1934 (16294)               fixup(k2)
1935 (16294)             end else fixup(savpc)
1936 (16307)           end; {if}
1937 (16320) 
1938 (16320)     'be':  begin {begin}
1939 (16328)             repeat
1940 (16328)               scan; statmnt
1941 (16332)             until token<>(' ;');
1942 (16343)             testto('en'); scan
1943 (16356)           end; {begin}
1944 (16363) 
1945 (16363)     'rp': begin {repeat}
1946 (16371)             savpc:=pc;
1947 (16371)             repeat
1948 (16379)               scan; statmnt
1949 (16383)             until token='un';
1950 (16394)             scan; express; testtype('b');
1951 (16414)             code3(37,savpc)
1952 (16416)           end {repeat};
1953 (16426) 
1954 (16429)     're': begin {read}
1955 (16437)             parse(' ('); scan;
1956 (16450)             if token=' @' then begin
1957 (16458)               scan; express; testtype('f');
1958 (16477)               device:=true;
1959 (16479)               code1(44); testto(' ,')
1960 (16494)             end
1961 (16500)             else begin
1962 (16503)               device:=false; code1(26)
1963 (16511)             end;
1964 (16517)             repeat
1965 (16517)               begin {main loop of read}
1966 (16517)                 if token=' ,' then scan;
1967 (16532)                 testto('id'); idpnt:=findid;
1968 (16547)                 if idpnt=0 then error(5);
1969 (16569)                 getvar;
1970 (16573)                 if relad=2 then error(15);
1971 (16591)                 case vartype of
1972 (16591)                   'i':  code1(28);
1973 (16610)                   'c':  code1(27);
1974 (16628)                   'p':  begin
1975 (16638)                         code1(27); code1(27);
1976 (16654)                         code1(53)
1977 (16656)                         end
1978 (16662)                   else error(114)
1979 (16667)                 end {case};

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         6/12/23 page 34

1980 (16675)                 gpval(idpnt,true,vartyp2)
1981 (16681)               end {mainloop of read}
1982 (16691)             until token<>' ,';
1983 (16698)             testto(' )'); scan;
1984 (16715)             if device then code1(45);
1985 (16730)           end {read};
1986 (16730) 
1987 (16733)     'wr','wl':
1988 (16746)           begin {write,writeln}
1989 (16749)             if token='wl' then wln:=true
1990 (16760)             else wln:=false;
1991 (16771)             scan;
1992 (16779)             if token=' (' then begin
1993 (16787)               scan;
1994 (16794)               if token=' @' then begin
1995 (16802)                 scan; express;
1996 (16813)                 if restype='q' then restype:='f';
1997 (16825)                 testtype('f');
1998 (16837)                 device:=true; code1(44);
1999 (16851)                 testto(' ,');
2000 (16860)               end else device:=false;
2001 (16865)               repeat
2002 (16869)                 if token=' ,' then scan;
2003 (16884)                 if (token=' )') and device
2004 (16892)                        and wln then
2005 (16897)                    {empty writeln except device}
2006 (16902)                    k2:=k2 {do nothing}
2007 (16905)                 else if token='st' then begin
2008 (16924)                   {string}
2009 (16927)                   code1(50);
2010 (16935)                   for k2:=1 to value[0]-1 do
2011 (16949)                     code1(ord(ident[k2])
2012 (16963)                         and 127);
2013 (16976)                   code1(ord(ident[value[0]])
2014 (16996)                       or 128);
2015 (17009)                   scan
2016 (17009)                 end else begin
2017 (17016)                   {expression}
2018 (17016)                   express;
2019 (17020)                   case restype of
2020 (17020)                     'i':  code1(30);
2021 (17039)                     'c':  code1(29);
2022 (17057)                     'q':  code1($57);
2023 (17075)                     's':  begin
2024 (17085)                             code1($58);
2025 (17093)                             code1($57);
2026 (17101)                           end;
2027 (17101)                     'p':  begin
2028 (17111)                             code1(22);
2029 (17119)                             code1(51);
2030 (17127)                             code1(29);
2031 (17135)                             code1(52);
2032 (17143)                             code1(29);
2033 (17151)                           end
2034 (17151)                     else merror(14,'09')
2035 (17159)                   end {case}
2036 (17167)                 end {expression}
2037 (17167)               until token<>' ,';
2038 (17174)               if wln then begin {writeln(..)}
2039 (17185)                 code2(32,13); code1(29);

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         6/12/23 page 35

2040 (17203)                 code2(32,10); code1(29);
2041 (17221)               end;
2042 (17221)               if device then code1(45);
2043 (17236)               testto(' )'); scan
2044 (17245)             end {if}
2045 (17249)             else if wln then begin {writeln}
2046 (17259)               code2(32,13); code1(29);
2047 (17277)               code2(32,10); code1(29);
2048 (17295)             end
2049 (17295)           end {write, writeln};
2050 (17295) 
2051 (17298)     'cs': case1; {case statement}
2052 (17313) 
2053 (17313)     'wh': begin {while}
2054 (17321)             scan; savpc:=pc; express;
2055 (17337)             testtype('b');
2056 (17345)             k2:=pc; code3(37,0);
2057 (17363)             testto('do'); scan; statmnt;
2058 (17380)             code3(36,savpc); fixup(k2)
2059 (17392)           end {while};
2060 (17402) 
2061 (17405)     'fo': begin {for}
2062 (17413)             parse('id'); assign;
2063 (17426)             if t0[idpnt]='pr' then error(1);
2064 (17449)             savtp1:=low(t0[idpnt]);
2065 (17457)             case token of
2066 (17462)               'to': k2:=1;
2067 (17476)               'dw': k2:=0
2068 (17491)               else merror(2,'to')
2069 (17505)             end {case of token};
2070 (17513)             scan; express; testtype(savtp1);
2071 (17531)             bottom1:=pc; code1(22);
2072 (17547)             gpval(idpnt,false,vartyp2);
2073 (17563)             code1(13-k2-k2);
2074 (17581)             savpc:=pc; code3(37,0);
2075 (17599)             testto('do'); scan; statmnt;
2076 (17616)             gpval(idpnt,false,vartyp2);
2077 (17632)             code1(21-k2);
2078 (17645)             gpval(idpnt,true,vartyp2);
2079 (17661)             code3(36,bottom1); fixup(savpc);
2080 (17683)             code3(35,-2);
2081 (17694)           end {for};
2082 (17694) 
2083 (17697)     'me': begin {mem}
2084 (17705)             parse(' ['); scan; express;
2085 (17722)             testtype('i');
2086 (17730)             testto(' ]'); parse(':=');
2087 (17748)             scan; express; code1(24);
2088 (17764)             testtype('i');
2089 (17772)           end {mem};
2090 (17772) 
2091 (17775)     'ca': begin {call}
2092 (17783)             parse(' ('); scan; express;
2093 (17800)             testtype('i');
2094 (17808)             testto(' )'); code1(25); scan
2095 (17825)           end {call};
2096 (17829) 
2097 (17832)     'op': openrw(47);
2098 (17848) 
2099 (17851)     'ow': openrw(48);

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         6/12/23 page 36

2100 (17867) 
2101 (17870)     'ob': openrw(80);
2102 (17886) 
2103 (17889)     'gb': begin
2104 (17897)             parse(' ('); scan; express;
2105 (17914)             testtype('f'); testto(' ,');
2106 (17931)             scan; express; testtype('i');
2107 (17947)             testto(' ,'); scan; testto('id');
2108 (17969)             idpnt:=findid;
2109 (17975)             if idpnt=0 then error(5);
2110 (17997)             getvar;
2111 (18001)             if relad<>0 then error(15);
2112 (18019)             code1($51); testferror;
2113 (18031)             gpval(idpnt,true,vartyp2);
2114 (18047)             testto(' )'); scan
2115 (18056)           end;
2116 (18060) 
2117 (18063)     'pb': begin
2118 (18071)             parse(' ('); scan; express;
2119 (18088)             testtype('f'); testto(' ,');
2120 (18105)             scan; express; testtype('i');
2121 (18121)             testto(' ,'); scan; express;
2122 (18138)             code1($52);testferror;
2123 (18150)             testto(' )');
2124 (18159)             scan
2125 (18159)           end;
2126 (18163) 
2127 (18166)     'ru': begin
2128 (18174)             code1($41); scan;
2129 (18186)           end;
2130 (18186) 
2131 (18189)     'fi': begin
2132 (18197)             code1(46); scan
2133 (18205)           end;
2134 (18209) 
2135 (18212)     'ge': gpsec(55);
2136 (18228) 
2137 (18231)     'pu': gpsec(56);
2138 (18247) 
2139 (18250)     'ex': begin {exit}
2140 (18258)             if level>0 then code1(1) else code1(0);
2141 (18287)             scan;
2142 (18291)           end;
2143 (18291) 
2144 (18294)     'cl': begin {close}
2145 (18302)             parse(' (');
2146 (18311)             repeat
2147 (18311)               scan; express; code1(49);
2148 (18327)               testtype('f');
2149 (18335)               testferror
2150 (18335)             until token<>' ,';
2151 (18346)             testto(' )'); scan;
2152 (18363)           end {close}
2153 (18363) 
2154 (18363)     else if (token<>'en') and (token<>' ;')
2155 (18381)       and (token<>'un') then begin
2156 (18392)       error(10); scan
2157 (18403)     end
2158 (18407)   end {case of statements}
2159 (18409) end;

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         6/12/23 page 37

2160 (18409) 
2161 (18410) { * findforw *          ( of block ) }
2162 (18410) 
2163 (18410) func findforw;
2164 (18410) 
2165 (18410) var i,j,sav1: integer;
2166 (18413) 
2167 (18413)   func found(start: integer):boolean;
2168 (18413)   var ii,i9: integer;
2169 (18416)   begin {compare}
2170 (18416)     ii:= 0;
2171 (18420)     repeat
2172 (18424)       ii:=succ(ii);
2173 (18428)     until (ii >= 8) or
2174 (18440)       (ident[ii] <> idtab[start+ii]);
2175 (18463)     found:=(ii >= 8);
2176 (18474)   end {compare};
2177 (18478) 
2178 (18479) 
2179 (18479) begin {findforw}
2180 (18479)   i:=succ(forwpn);
2181 (18485)   repeat
2182 (18490)     i:=prec(i)
2183 (18490)   until (i=0) or found(8*fortab[i]);
2184 (18525)   findforw:=i;
2185 (18529)   if i>0 then
2186 (18543)     if i=forwpn then forwpn:=forwpn-1
2187 (18563)     else begin
2188 (18573)       sav1:=fortab[i];
2189 (18577)       for j:=1 to forwpn-1 do
2190 (18597)       fortab[j]:=fortab[succ(j)];
2191 (18616)       fortab[forwpn]:=sav1;
2192 (18642)       findforw:=forwpn;
2193 (18650)       forwpn:=forwpn-1
2194 (18662)     end
2195 (18664) end {findforw};
2196 (18669) 
2197 (18670) 
2198 (18670) begin { *** body of block *** }
2199 (18670)   dpnt:=3; t2[bottom]:=pc;
2200 (18682)   code3(36,0);
2201 (18700)   stackpn1:=stackpnt; forwpn:=0;
2202 (18710) 
2203 (18714)   if token='co' then begin    { * const * }
2204 (18725)     scan;
2205 (18729)     repeat
2206 (18729)       deccon; testto(' ;'); scan
2207 (18742)     until token <> 'id';
2208 (18753)   end {const};
2209 (18757) 
2210 (18757)   if token='me' then memory;  { * mem * }
2211 (18772) 
2212 (18772)   if token='va' then variable;{ * var * }
2213 (18787) 
2214 (18787)   while (token='pr')or (token='fu') do begin
2215 (18807)     parlevel:=0;
2216 (18809)     case token of
2217 (18813)     'pr': begin               { * proc * }
2218 (18825)             parse('id'); npara:=0;
2219 (18836)             putsym('p','r'); cproc:=spnt;

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         6/12/23 page 38

2220 (18850)             level:=succ(level);
2221 (18862)           end;
2222 (18867)     'fu': begin               { * func * }
2223 (18878)             parse('id'); npara:=1;
2224 (18889)             putsym('f','i');
2225 (18903)             cproc:=spnt; level:=succ(level);
2226 (18915)             putsym('f','i');
2227 (18930)             t2[spnt]:=parlevel;
2228 (18934)             parlevel:=succ(parlevel);
2229 (18946)           end
2230 (18951)     end; {case of token}
2231 (18953)     if forwpn=0 then find:=0
2232 (18963)     else find:=findforw;
2233 (18978)     if find<>0 then begin
2234 (18989)       spnt:=spnt-npara-1;
2235 (19003)       cproc:=fortab[find];
2236 (19012)       fixup(t2[cproc]);
2237 (19034)     end;
2238 (19034)     scan; spnt1:=spnt;
2239 (19038)     dpnt1:=dpnt;
2240 (19046)     if token=' (' then parameter;
2241 (19069)     if t0[cproc]='fi' then function;
2242 (19088)     testto(' ;');
2243 (19097)     for i:=1 to npara do
2244 (19103)     t2[succ(spnt-i)]:=t2[succ(spnt-i)]
2245 (19135)           -parlevel;
2246 (19140)     scan;
2247 (19167)     if token='fw' then begin
2248 (19175)       if forwpn=8 then merror(13,'ov');
2249 (19199)       forwpn:=succ(forwpn);
2250 (19203)       fortab[forwpn]:=cproc;
2251 (19212)       t2[cproc]:=pc;
2252 (19224)       code3(36,0);
2253 (19242)       scan
2254 (19242)     end else block(cproc);
2255 (19259)     level:=prec(level);
2256 (19263)     dpnt:=dpnt1; spnt:=spnt1;
2257 (19276)     case high(t0[spnt]) of
2258 (19292)       'r':  t0[spnt]:=packed('t',low(t0[spnt]));
2259 (19316)       's':  t0[spnt]:=packed('u',low(t0[spnt]))
2260 (19344)     end {case};
2261 (19352)     testto(' ;'); scan
2262 (19361)   end {procedure of function};
2263 (19365) 
2264 (19368)   testto('be');     { * begin * }
2265 (19377)   if forwpn<>0 then merror(13,'ur');
2266 (19398)   fixup(t2[bottom]);
2267 (19412)   t2[bottom]:=pc;
2268 (19416)   scan;
2269 (19428)   code3(35,2*dpnt);
2270 (19443)   repeat
2271 (19443)     statmnt
2272 (19443)   until token='en';
2273 (19454)   scan;
2274 (19462)   if level>0 then code1(1) else code1(0);
2275 (19491)   stackpnt:=stackpn1;
2276 (19491) end {block};
2277 (19499) 
2278 (19500) { * savtable *    ( global) }
2279 (19500) 

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         6/12/23 page 39

2280 (19500) proc savtable; { save lib table in @ofno }
2281 (19500) 
2282 (19500) var i,j,num: integer;
2283 (19503)     vtype1: char;
2284 (19503) 
2285 (19503) begin
2286 (19503)   writeln(@ofno,spnt,',',pc+2);
2287 (19532)   for i:=1 to spnt do begin {for every entry }
2288 (19551)     for j:=1 to 8 do begin
2289 (19568)       write(@ofno,idtab[8*i+j])
2290 (19588)     end;
2291 (19592)     writeln(@ofno,',',t0[i],',',t1[i],',',
2292 (19639)       t2[i],',',t3[i]);
2293 (19666)     vtype1:=high(t0[i]);
2294 (19674)     if ((vtype1='p') or (vtype1='f') or
2295 (19693)       (vtype1='g')) and (t3[i]<>0) then begin
2296 (19714)       num:=stack[t3[i]];
2297 (19725)       write(@ofno,num);
2298 (19744)       for j:=1 to num do
2299 (19750)         write(@ofno,',',stack[t3[i]+j]);
2300 (19789)       write(@ofno,cr,lf);
2301 (19815)     end {then};
2302 (19815)   end {for}
2303 (19815) end {savtable};
2304 (19829) 
2305 (19830) { * main program * }
2306 (19830) 
2307 (19830) begin {main}
2308 (19830)   nlflg:=false;
2309 (19835)   init;scan;
2310 (19847)   case token of
2311 (19847)     'pg': begin
2312 (19859)             libflg:=false;
2313 (19861)             asetfile(pname,scyclus,sdrive,'Q');
2314 (19887)           end;
2315 (19887)     'li': begin
2316 (19898)             libflg:=true;
2317 (19900)             asetfile(pname,scyclus,sdrive,'T');
2318 (19926)           end
2319 (19926)     else
2320 (19926)       merror(2,'pg')
2321 (19934)   end {case}
2322 (19942)   parse('id');
2323 (19951)   i:=0;
2324 (19953)   repeat
2325 (19957)     i:=succ(i);
2326 (19961)   until (i>7) or (pname[i] = ':') or
2327 (19984)       (pname[i]<>uppercase(ident[i+1]));
2328 (20013)   if i<8 then
2329 (20023)     merror(2,packed(pname[0],pname[1]));
2330 (20048)     { name differs from filename }
2331 (20048)   parse(' ;');
2332 (20057)   if ofno<>nooutput then openw(ofno);
2333 (20073)   scan;
2334 (20077)   if (token='us') and (libflg=false) then begin
2335 (20093)     repeat
2336 (20096)       getlib; scan
2337 (20100)     until token<>' ,';
2338 (20111)     testto(' ;'); scan
2339 (20124)   end;

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         6/12/23 page 40

2340 (20128)   block(0); testto(' .');
2341 (20145)   if ofno<>nooutput then begin
2342 (20152)     write(@ofno,'E');
2343 (20163)     savebyte(pc and 255);
2344 (20176)     savebyte(pc shr 8);
2345 (20189)     close(ofno);
2346 (20195)     if libflg then begin
2347 (20199)       asetfile(pname,scyclus,sdrive,'L');
2348 (20224)       openw(ofno);
2349 (20230)       savtable;
2350 (20234)       close(ofno)
2351 (20234)     end
2352 (20240)   end else
2353 (20240)     runerr:=$87; {no loader file}
2354 (20249)   writeln;
2355 (20249)   writeln;
2356 (20255)   writeln('End compile');
2357 (20279)   writeln;
2358 (20279)   writeln('Code lenght:          ',pc);
2359 (20319)   writeln('Compiler stack size:  ',stackmax);
2360 (20353)   writeln('Ident stack size:     ',spntmax);
2361 (20387)   write('Pascal errors:        ');
2362 (20410)   if numerr>0 then write(invvid);
2363 (20423)   writeln(numerr,norvid);
2364 (20437)   if prt then begin
2365 (20441)     write(prtoff);
2366 (20447)     setemucom(9);
2367 (20455)   end;
2368 (20455)   close(fno);
2369 (20461)   { check whether second pass is not required }
2370 (20461)   if (runerr=0) and libflg then runerr:=-1;
2371 (20477) end {main}.
2372 (20482) 

End compile

Code lenght:          20481
Compiler stack size:  134
Ident stack size:     211
Pascal errors:        0
