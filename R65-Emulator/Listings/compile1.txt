
R65 COMPILE 4.2: program COMPILE1         10/2/24 page 1


   1 (    4) {   ********************************
   2 (    4)     *                              *
   3 (    4)     *  R65 "Tiny" Pascal Compiler  *
   4 (    4)     *            Pass 1            *
   5 (    4)     *                              *
   6 (    4)     ********************************
   7 (    4) 
   8 (    4) First version 1978 by rricharz
   9 (    4) Version 3.7 (20K)  01/08/82 rricharz
  10 (    4) 
  11 (    4) Recovered 2018 by rricharz (r77@bluewin.ch)
  12 (    4) Improved 2018-2023 by rricharz
  13 (    4) Version 4 with cpnt strings and exit statement
  14 (    4) 
  15 (    4) Original derived from the publication by
  16 (    4) Kin-Man Chung and Herbert Yen in
  17 (    4) Byte, Volume 3, Number 9 and Number 10, 1978
  18 (    4) 
  19 (    4) Adapted for the R65 computer system and
  20 (    4) substantially enhanced by rricharz 1978-2023
  21 (    4) 
  22 (    4) This is a Pascal derivative optimized for 8-bit
  23 (    4) microprocessors (integer type is 16 bit) with
  24 (    4) additional features (mem) to interact directly
  25 (    4) with the microprocessor hardware. Only one
  26 (    4) dimensional arrays and no records or user
  27 (    4) defined types. Floating point numbers (real)
  28 (    4) and file io to floppy disks are supported.
  29 (    4) 
  30 (    4) Precompiled libraries are merged in the loader.
  31 (    4) The table of reserved words and the library
  32 (    4) tables are loaded from the same drive as
  33 (    4) the compiler.
  34 (    4) 
  35 (    4) The output of the program is a loader file for
  36 (    4) the Pascal loader (compile2).
  37 (    4) 
  38 (    4) usage:
  39 (    4)  compile1 name[.cy[,drv]] [xxx]
  40 (    4)   where x:       l,p: no hard copy print
  41 (    4)                  i,r: index bound checking
  42 (    4)                  n: no loader file
  43 (    4)   [] means not required
  44 (    4) 
  45 (    4) The compiler uses 2 fixed memory areas to store
  46 (    4) the table of reserved words and the table of
  47 (    4) idents. The top of the Pascal stack (endstk) is
  48 (    4) adjusted accordingly. The reason for this hack
  49 (    4) is speed and convenience. A normal Pascal array
  50 (    4) of chars would store the chars as 16 bit
  51 (    4) numers and would therefore require twice the
  52 (    4) space. An array of packed chars would require
  53 (    4) more coding and slow the scanner module of the
  54 (    4) compiler down.                                }
  55 (    4) 
  56 (    4) program compile1;
  57 (    4) 
  58 (    4) uses syslib, arglib;
  59 ( 1093) 

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 2

  60 ( 1093) const version='4.2';
  61 ( 1100) 
  62 ( 1100)     table     =$97ff; {user ident table -1}
  63 ( 1100)     idtab     =$95ff; {resword table -1}
  64 ( 1100)     idlength  =64;    {max. length of ident}
  65 ( 1100)     stacksize =256;   {stack size}
  66 ( 1100)     pagelenght=60;    {no of lines per page}
  67 ( 1100)     nooutput  =@0;
  68 ( 1100)     maxfi     =3;     {max number of ins fls}
  69 ( 1100) 
  70 ( 1100)     nresw=63;   {number of res. words, max 64}
  71 ( 1100)     symbsize=256;     {id table entries}
  72 ( 1100)     reswtabpos=$c600; { up to $c7ff }
  73 ( 1100)     idtabpos=$be00;   { up to $c5ff }
  74 ( 1100) 
  75 ( 1100)     yesoutput=@255;
  76 ( 1100) 
  77 ( 1100) mem endstk  =$000e: integer;
  78 ( 1100)     reswtab =reswtabpos: array[$200] of char&;
  79 ( 1100)     idtab   =idtabpos: array[$800] of char&;
  80 ( 1100) 
  81 ( 1100) var tpos,pc,level,line,offset,dpnt,spnt,fipnt,
  82 ( 1100)     npara,i,stackpnt,stackmax,spntmax,numerr,
  83 ( 1100)     line1                          :integer;
  84 ( 1100) 
  85 ( 1100)     scyclus,sdrive,cdrive: integer;
  86 ( 1100) 
  87 ( 1100)     pname: array[15] of char;
  88 ( 1100) 
  89 ( 1100)     value: array[1] of integer;
  90 ( 1100) 
  91 ( 1100)     ch,restype,vartype:char;
  92 ( 1100) 
  93 ( 1100)     token: packed char;
  94 ( 1100) 
  95 ( 1100)     prt,libflg,icheck,ateof,lineflg,nlflg: boolean;
  96 ( 1100) 
  97 ( 1100)     fno,ofno,savefno: file;
  98 ( 1100) 
  99 ( 1100)     filstk: array[maxfi] of file;
 100 ( 1100) 
 101 ( 1100)     ident: array[idlength] of char;
 102 ( 1100)     { Only the first 8 characters are
 103 ( 1100)       used to find and differentiate ids }
 104 ( 1100) 
 105 ( 1100)     t0: array[symbsize] of packed char;
 106 ( 1100)            {type of symbol}
 107 ( 1100) 
 108 ( 1100)         {High letter:
 109 ( 1100)          a:array, c:constant, d;const parameter
 110 ( 1100)          e:constant array parameter, f:function
 111 ( 1100)          g:array function, h;8-bit memory var
 112 ( 1100)          i:8-bit array memory variable
 113 ( 1100)          m:16-bit memory variable
 114 ( 1100)          n:16-bit array memory variable
 115 ( 1100)          p:procedure
 116 ( 1100)          q:indexed cpnt
 117 ( 1100)          r,t:function result
 118 ( 1100)          s,u:array function result
 119 ( 1100)          v:variable, w:variable parameter

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 3

 120 ( 1100)          x:variable array parameter
 121 ( 1100) 
 122 ( 1100)          Low letter:
 123 ( 1100)          i:integer, c:char, p:packed char
 124 ( 1100)          q:cpnt (pointer to chars)
 125 ( 1100)          r:real(array multiple of two)
 126 ( 1100)          s:const cpnt
 127 ( 1100)          f:file, b:boolean, u:undefined  }
 128 ( 1100) 
 129 ( 1100)     t1: array[symbsize] of integer;
 130 ( 1100)          {level}
 131 ( 1100)     t2: array[symbsize] of integer;
 132 ( 1100)          {val,dis,addr}
 133 ( 1100)     t3: array[symbsize] of integer;
 134 ( 1100)          {stack pointer,size of array}
 135 ( 1100) 
 136 ( 1100)     reswcod:array[nresw] of packed char;
 137 ( 1100) 
 138 ( 1100)     stack: array[stacksize] of integer;
 139 ( 1100) 
 140 ( 1100) 
 141 ( 1100) {       * savebyte *    (global)        }
 142 ( 1100) 
 143 ( 1100) proc savebyte(x: integer);
 144 ( 1100) 
 145 ( 1100) begin
 146 ( 1100)     if ofno<>nooutput then begin
 147 ( 1112)       write(@ofno,
 148 ( 1115)         chr(((x and 255) shr 4)+ord('0')));
 149 ( 1136)       write(@ofno,chr((x and 15)+ord('0')))
 150 ( 1151)     end
 151 ( 1154) end {savebyte};
 152 ( 1154) 
 153 ( 1155) {       * crlf *        (global)        }
 154 ( 1155) 
 155 ( 1155) proc newpage; forward;
 156 ( 1158) 
 157 ( 1158) proc crlf;
 158 ( 1158)   var i: integer;
 159 ( 1161) begin
 160 ( 1161)   writeln;
 161 ( 1163)   line:=succ(line); line1:=succ(line1);
 162 ( 1182)   if ((line + line1) div pagelenght)
 163 ( 1198)     *pagelength=line then newpage;
 164 ( 1214) end {crlf};
 165 ( 1214) 
 166 ( 1215) {       error message   (global)        }
 167 ( 1215) 
 168 ( 1215) proc merror(x: integer; code: packed char);
 169 ( 1215) 
 170 ( 1215) var i: integer;
 171 ( 1218)     answer: char;
 172 ( 1218) 
 173 ( 1218) begin
 174 ( 1218)   crlf; numerr:=succ(numerr);
 175 ( 1228)   for i:=2 to tpos do write(' ');
 176 ( 1254)   write('^'); crlf;
 177 ( 1274)   write('*** (',numerr,',',pc,')   ');
 178 ( 1297)   case x of
 179 ( 1297)     01: write('Ident');

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 4

 180 ( 1314)     02: write('Ident ',code,' expected');
 181 ( 1350)     03: write('Var declaration');
 182 ( 1376)     04: write('Const expected');
 183 ( 1401)     05: write('Ident unknown');
 184 ( 1425)     06: write('Cannot be assigned');
 185 ( 1454)     07: write('Symbol table overflow');
 186 ( 1486)     08: write('Stack overflow');
 187 ( 1511)     09: write('Expression');
 188 ( 1532)     10: write('Statement');
 189 ( 1552)     11: write('Declaration');
 190 ( 1574)     12: write('Constant');
 191 ( 1593)     13: write('Forward reference: ',code);
 192 ( 1632)     14: write('Type mismatch: ',code);
 193 ( 1667)     15: write('Array size');
 194 ( 1688)     16: write('Array (8-bit)');
 195 ( 1712)     17: write('Real');
 196 ( 1727)     18: write('File table overflow');
 197 ( 1757)     19: write('Parameter');
 198 ( 1777)     20: write('Compiler directive syntax');
 199 ( 1813)     21: write('Nested include files')
 200 ( 1844)   end {case};
 201 ( 1846)   writeln;
 202 ( 1846)   write('Continue?');
 203 ( 1862)   read(@key,answer);
 204 ( 1870)   if answer<>'Y' then begin
 205 ( 1878)     crlf; write(prtoff); setemucom(9); close(fno);
 206 ( 1902)     if (ofno<>nooutput) and (ofno<>yesoutput)
 207 ( 1915)       then close(ofno);
 208 ( 1926)     writeln('Aborting compile1 on request');
 209 ( 1961)     abort
 210 ( 1961)   end
 211 ( 1965)   else crlf;
 212 ( 1972)   if (ofno<>nooutput) and (ofno<>yesoutput)
 213 ( 1985)     then close(ofno);
 214 ( 1996)   ofno:=nooutput;
 215 ( 1998) end {merror};
 216 ( 2002) 
 217 ( 2003) proc error(x: integer);
 218 ( 2003) 
 219 ( 2003) begin
 220 ( 2003)   merror(x,'##')
 221 ( 2015) end;
 222 ( 2021) 
 223 ( 2022) {       * push & pop *  (global) }
 224 ( 2022) 
 225 ( 2022) proc push(x: %integer);
 226 ( 2022) 
 227 ( 2022) begin
 228 ( 2022)   if stackpnt>=stacksize then error(8)
 229 ( 2040)   else stackpnt:=succ(stackpnt);
 230 ( 2053)   if stackpnt>stackmax then stackmax:=stackpnt;
 231 ( 2070)   stack[stackpnt]:=x;
 232 ( 2082) end {push};
 233 ( 2090) 
 234 ( 2091) func pop: integer;
 235 ( 2091) 
 236 ( 2091) begin
 237 ( 2091)   pop:=stack[stackpnt];
 238 ( 2100)   stackpnt:=prec(stackpnt)
 239 ( 2108) end {pop};

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 5

 240 ( 2117) 
 241 ( 2118) {       * newpage *     (global) }
 242 ( 2118) 
 243 ( 2118) proc newpage;
 244 ( 2118) 
 245 ( 2118) var i: integer;
 246 ( 2121) 
 247 ( 2121) begin
 248 ( 2121)   if ((line+line1)<>0) and prt then
 249 ( 2135)     write(@printer,formfeed);
 250 ( 2150)   writeln; { Do not count this line}
 251 ( 2156)   if pname[0]<>'x' then begin
 252 ( 2165)     write('R65 COMPILE ');
 253 ( 2181)     write(version);
 254 ( 2186)     if libflg then write(': library ')
 255 ( 2204)     else write(': program ');
 256 ( 2218)     prtext16(output,pname);
 257 ( 2232)   end;
 258 ( 2232)   write(' ');
 259 ( 2234)   prtdate(output);
 260 ( 2242)   writeln(' page ',
 261 ( 2249)     ((line+line1) div pagelenght)+1);
 262 ( 2271)   writeln;
 263 ( 2271) end {newpage};
 264 ( 2277) 
 265 ( 2278) {        * code1 *      (global) }
 266 ( 2278) 
 267 ( 2278) proc code1(x: %integer);  {set one byte p-code}
 268 ( 2278) begin
 269 ( 2278)   savebyte(x); pc:=succ(pc)
 270 ( 2293) end;
 271 ( 2302) 
 272 ( 2303) {       * getchr *      (global) }
 273 ( 2303) 
 274 ( 2303) proc writenum(i: integer);
 275 ( 2303) begin
 276 ( 2303)   if i<=999 then write(' ');
 277 ( 2321)   if i<=99 then write(' ');
 278 ( 2333)   if i<=9 then write(' ');
 279 ( 2345)   write(i);
 280 ( 2350) end;
 281 ( 2350) 
 282 ( 2351) proc nextline;
 283 ( 2351) begin
 284 ( 2351)   nlflg:=true;
 285 ( 2358)   if savefno=@0 then writenum(line)
 286 ( 2372)   else begin
 287 ( 2385)     write('{I} ');
 288 ( 2390)     line:=line-1; { do not count line }
 289 ( 2401)     writenum(line1);
 290 ( 2411)   end;
 291 ( 2411)   write(' (');
 292 ( 2414)   if (pc+2)<9999 then write(' ');
 293 ( 2430)   writenum(pc+2); write(') ');
 294 ( 2446) end;
 295 ( 2446) 
 296 ( 2447) proc getchr;
 297 ( 2447) 
 298 ( 2447) begin
 299 ( 2447)   if ateof then begin

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 6

 300 ( 2456)     if savefno<>@0 then begin
 301 ( 2466)       { end of include file }
 302 ( 2469)       close(fno);
 303 ( 2475)       fno:=savefno;
 304 ( 2475)       savefno:=@0;
 305 ( 2485)       ateof:=false;
 306 ( 2491)     end else begin
 307 ( 2498)       writeln('Unexpected eof');
 308 ( 2519)       abort
 309 ( 2519)     end
 310 ( 2523)   end else begin
 311 ( 2526)     read(@fno,ch);
 312 ( 2536)     if ch=cr then begin
 313 ( 2544)       crlf;
 314 ( 2551)       nextline;
 315 ( 2555)       ch:=' ';
 316 ( 2557)     end {if}
 317 ( 2561)     else if ch=eof then begin
 318 ( 2571)       ateof:=true;
 319 ( 2576)       { we need to suppy one more char }
 320 ( 2580)       { for end. at end of file to work properly }
 321 ( 2580)       ch:=' ';
 322 ( 2582)     end {else if}
 323 ( 2586)     else write(ch);
 324 ( 2594)   end;
 325 ( 2594) end {getchr};
 326 ( 2594) 
 327 ( 2595) {       * splitconv *   (global) }
 328 ( 2595) 
 329 ( 2595) proc splitconv(a: array[1] of %integer;
 330 ( 2595)   var b:array[1] of %integer);
 331 ( 2595) 
 332 ( 2595) begin
 333 ( 2595)   b:=a;
 334 ( 2600) end;
 335 ( 2612) 
 336 ( 2613) {       * init *        (global) }
 337 ( 2613) 
 338 ( 2613) proc init;
 339 ( 2613) 
 340 ( 2613) const char96=chr(20);
 341 ( 2616) 
 342 ( 2616) var i,j,dummy: integer;
 343 ( 2616)     dch: char;
 344 ( 2616)     pch: packed char;
 345 ( 2616)     request: array[15] of char;
 346 ( 2616)     default: boolean;
 347 ( 2616) 
 348 ( 2616) begin {init}
 349 ( 2616)   writeln('R65 PASCAL COMPILER version ', version,
 350 ( 2650)     ', Pass  1');
 351 ( 2668)   ateof:=false; savefno:=@0;
 352 ( 2676)   cdrive:=fildrv; { drive of compile program }
 353 ( 2687)   fipnt:=-1;
 354 ( 2689)   endstk:=idtabpos-144;
 355 ( 2699)   pc:=2; dpnt:=0; spnt:=0; offset:=2;
 356 ( 2723)   npara:=0; level:=0;
 357 ( 2735)   stackpnt:=0; libflg:=false;
 358 ( 2747)   stackmax:=0;spntmax:=0; numerr:=0;
 359 ( 2765)   t0[0]:='vi'; t1[0]:=0; t2[0]:=0; t3[0]:=0;

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 7

 360 ( 2798)   { prepare resword table }
 361 ( 2802)   writeln('Reading list of reserved words');
 362 ( 2839)   asetfile('RESWORDS:W      ',0,cdrive,'W');
 363 ( 2871)   openr(fno);
 364 ( 2877)   for i:=0 to nresw do begin
 365 ( 2894)     read(@fno,pch,dch);
 366 ( 2911)     reswcod[i]:=pch;
 367 ( 2916)     for j:=0 to 7 do reswtab[8*i+j]:=' ';
 368 ( 2955)     j:=0;
 369 ( 2978)     while (j<8) and (dch<>cr) do begin
 370 ( 3000)       read(@fno,dch);
 371 ( 3010)       if (dch<>cr) then
 372 ( 3018)         reswtab[8*i+j]:=dch;
 373 ( 3033)       j:=succ(j)
 374 ( 3044)     end;
 375 ( 3053)     while (dch<>cr) and (dch<>eof) do
 376 ( 3070)       read(@fno,dch)
 377 ( 3079)   end;
 378 ( 3088)   close(fno);
 379 ( 3108) 
 380 ( 3108)   writeln;
 381 ( 3108) 
 382 ( 3114)   sdrive:=1; {default drive for source }
 383 ( 3120)   scyclus:=0;
 384 ( 3122)   agetstring(pname,default,scyclus,sdrive);
 385 ( 3166) 
 386 ( 3166)   agetstring(request,default,dummy,dummy);
 387 ( 3206)   icheck:=false;
 388 ( 3208)   prt:=true; ofno:=yesoutput; lineflg:=false;
 389 ( 3226)   if not default then begin
 390 ( 3235)     if request[0]<>'/' then argerror(103);
 391 ( 3258)     for i:=1 to 8 do
 392 ( 3266)       case request[i] of
 393 ( 3279)         'P': prt:=false;
 394 ( 3292)         'L': lineflg:=true;
 395 ( 3308)         'I','R': icheck:=true;
 396 ( 3331)         'N': ofno:=nooutput;
 397 ( 3347)         ' ': begin end
 398 ( 3361)         else argerror(104)
 399 ( 3366)       end; {case}
 400 ( 3388)   end;
 401 ( 3388) 
 402 ( 3388)   asetfile(pname,scyclus,sdrive,'P');
 403 ( 3410)   openr(fno);
 404 ( 3416)   scyclus:=filcyc; { may have changed }
 405 ( 3424) 
 406 ( 3424)   {save cyclus and drive for compile2}
 407 ( 3424)   arglist[8]:=scyclus;
 408 ( 3426)   arglist[9]:=sdrive;
 409 ( 3440)   numarg:=1;
 410 ( 3454) 
 411 ( 3458)   if prt then begin
 412 ( 3462)     write(prton);
 413 ( 3468)     setemucom(8);
 414 ( 3476)   end
 415 ( 3476) 
 416 ( 3476)   line:=0; line1:=0;
 417 ( 3484)   newpage; crlf; line:=1;
 418 ( 3498)   write('   1 (    4) '); getchr
 419 ( 3516) end {init};

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 8

 420 ( 3520) 
 421 ( 3521) 
 422 ( 3521) { ############################# }
 423 ( 3521) {       *scan*              (global)    }
 424 ( 3521) { ############################# }
 425 ( 3521) { scan input and make tokens }
 426 ( 3521) 
 427 ( 3521) proc scan;
 428 ( 3521) 
 429 ( 3521) var count,ll,hh,i,i1,co: integer;
 430 ( 3524)     name: array[7] of char;
 431 ( 3524) 
 432 ( 3524) {       * compresw*     (of scan)       }
 433 ( 3524) 
 434 ( 3524) func compresw(index: integer);
 435 ( 3524) 
 436 ( 3524) var addr,ci,i: integer;
 437 ( 3527) 
 438 ( 3527) begin
 439 ( 3527)   addr:=8*index; i:=0;
 440 ( 3542)   repeat
 441 ( 3546)     ci:=ord(ident[i+1])-ord(reswtab[addr+i]);
 442 ( 3571)     i:=succ(i)
 443 ( 3576)   until (ci<>0) or (i>=8);
 444 ( 3599)   compresw:=ci
 445 ( 3603) end {compresw};
 446 ( 3611) 
 447 ( 3612) {       * clear *       (of scan)              }
 448 ( 3612) 
 449 ( 3612) proc clear; {clears 8 chars of identifier}
 450 ( 3612) 
 451 ( 3612) var i: integer;
 452 ( 3615) 
 453 ( 3615) begin
 454 ( 3615)   for i:=1 to 8 do ident[i]:=' '
 455 ( 3638) end;
 456 ( 3658) 
 457 ( 3659) {       * pack *        (of scan)              }
 458 ( 3659) 
 459 ( 3659) proc pack;  {packs token and ch to token }
 460 ( 3659) 
 461 ( 3659) begin
 462 ( 3659)   token:=packed(low(token),ch); getchr
 463 ( 3678) end;
 464 ( 3682) 
 465 ( 3683) {       * setval *      (of scan)              }
 466 ( 3683) 
 467 ( 3683) proc setval;
 468 ( 3683) 
 469 ( 3683) var r: real;
 470 ( 3686)     n,n1: integer;
 471 ( 3686)     ems: boolean;
 472 ( 3686) 
 473 ( 3686)   func times10(r:real):real;
 474 ( 3686)   { slightly more accurate than 10.0*r }
 475 ( 3686)   var r2,r4:real;
 476 ( 3689)   begin
 477 ( 3689)     r2:=r+r;
 478 ( 3697)     r4:=r2+r2;
 479 ( 3716)     times10:=r2+r4+r4;

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 9

 480 ( 3742)   end;
 481 ( 3755) 
 482 ( 3756) begin
 483 ( 3756)   r:=0.0;
 484 ( 3764)   repeat
 485 ( 3770)     r:=times10(r)+conv(ord(ch)-ord('0'));
 486 ( 3791)     getchr;
 487 ( 3803)   until (ch<'0') or (ch>'9');
 488 ( 3817)   if ch<>'.' then begin {numeric integer}
 489 ( 3831)     token:='nu';
 490 ( 3834)     value[0]:=trunc(r+0.5);
 491 ( 3853)   end
 492 ( 3858)   else begin {numeric real}
 493 ( 3861)     n:=0; getchr;
 494 ( 3871)     while (ch<='9') and (ch>='0') do begin
 495 ( 3889)       r:=times10(r)+conv(ord(ch)-ord('0'));
 496 ( 3910)       n:=prec(n); getchr
 497 ( 3927)     end;
 498 ( 3931)     if ch='e' then begin
 499 ( 3941)       ems:=false; getchr;
 500 ( 3954)       case ch of
 501 ( 3954)         '+': getchr;
 502 ( 3969)         '-': begin ems:=true; getchr end
 503 ( 3989)       end;
 504 ( 3991)       if (ch>'9') or (ch<'0') then error(17)
 505 ( 4011)       else begin
 506 ( 4020)         n1:=ord(ch)-ord('0');
 507 ( 4026)         getchr;
 508 ( 4035)         if (ch<='9') and (ch>='0') then begin
 509 ( 4050)           n1:=10*n1+ord(ch)-ord('0');
 510 ( 4067)           getchr
 511 ( 4072)         end;
 512 ( 4076)         if ems then n:=n-n1 else n:=n+n1
 513 ( 4103)       end
 514 ( 4103)     end;
 515 ( 4112)     while n>0 do begin
 516 ( 4122)       n:=prec(n);
 517 ( 4126)       r:=times10(r);
 518 ( 4145)     end;
 519 ( 4151)     while n<0 do begin
 520 ( 4164)       n:=succ(n); r:=0.1*r;
 521 ( 4179)     end;
 522 ( 4192)     splitconv(r,value);
 523 ( 4219)     token:='ru'
 524 ( 4219)   end
 525 ( 4222) end {setval};
 526 ( 4226) 
 527 ( 4227) {       * directive *   (of scan               }
 528 ( 4227) 
 529 ( 4227) proc directive;
 530 ( 4227) var i,icyclus:integer;
 531 ( 4230)     name: array[15] of char;
 532 ( 4230) begin
 533 ( 4230)   getchr;
 534 ( 4236)   case ch of
 535 ( 4236)     'I': begin
 536 ( 4247)            if savefno<>@0 then error(21);
 537 ( 4265)            getchr; if ch<>' ' then error(20);
 538 ( 4287)            i:=0; getchr;
 539 ( 4297)            while (ch<>'}') and (i<16) do begin

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 10

 540 ( 4315)              name[i]:=ch; i:=i+1; getchr;
 541 ( 4342)            end;
 542 ( 4342)            while (i<16) do begin
 543 ( 4355)              name[i]:=' '; i:=i+1;
 544 ( 4371)            end;
 545 ( 4376)            icyclus:=0;
 546 ( 4381)            asetfile(name,icyclus,sdrive,'P');
 547 ( 4407)            savefno:=fno;
 548 ( 4407)            openr(fno);
 549 ( 4421)            line1:=0;
 550 ( 4423)            crlf;
 551 ( 4431)            nextline;
 552 ( 4435)            getchr; scan;
 553 ( 4443)          end
 554 ( 4443)     else error(20)
 555 ( 4448)   end {case}
 556 ( 4456) end;
 557 ( 4456) 
 558 ( 4457) {       * setid *       (of scan)              }
 559 ( 4457) 
 560 ( 4457) proc setid; {sets one char to ident}
 561 ( 4457) 
 562 ( 4457) begin
 563 ( 4457)   if count<=idlength then begin
 564 ( 4469)     ident[count]:=ch; count:=succ(count)
 565 ( 4484)   end;
 566 ( 4493)   getchr;
 567 ( 4497) end {setid};
 568 ( 4497) 
 569 ( 4498) begin { ***** body of scan ***** }
 570 ( 4498)   count:=1; while ch=' ' do getchr;
 571 ( 4520)   tpos:=curpos;
 572 ( 4526) 
 573 ( 4530)   { delayed because of token lookahead }
 574 ( 4530)   if nlflg then begin
 575 ( 4534)     if lineflg and (pc>2) then begin
 576 ( 4549)       code1($59);
 577 ( 4560)       code1((line) and 255);
 578 ( 4573)       code1((line) shr 8);
 579 ( 4586)     end;
 580 ( 4586)     nlflg:=false;
 581 ( 4588)   end;
 582 ( 4592) 
 583 ( 4592)   if (ch<'a') or (ch>'z') then begin {main if}
 584 ( 4610)     if (ch<'0') or (ch>'9') then begin {symb}
 585 ( 4628)       token:=packed(' ',ch); getchr;
 586 ( 4643)       case low(token) of
 587 ( 4647)         '<': if (ch='=') or (ch='>') then pack;
 588 ( 4677)         '>',':': if (ch='=') then pack;
 589 ( 4708)         '{': begin
 590 ( 4718)                if ch='$' then directive
 591 ( 4725)                else begin
 592 ( 4735)                  if ch<>'}' then
 593 ( 4741)                  repeat getchr until ch='}';
 594 ( 4755)                  getchr; scan
 595 ( 4763)                end
 596 ( 4767)              end;
 597 ( 4767)         '$': begin {hex constant}
 598 ( 4777)                token:='nu'; value[0]:=0;
 599 ( 4788)                while ((ch>='0')and(ch<='9'))

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 11

 600 ( 4806)                      or((ch>='a')and(ch<='f'))
 601 ( 4821)                      do begin
 602 ( 4826)                  if ch>'9' then
 603 ( 4832)                    value[0]:=(value[0] shl 4)
 604 ( 4846)                      +ord(ch)-ord('a')+10
 605 ( 4855)                  else
 606 ( 4857)                    value[0]:=(value[0] shl 4)
 607 ( 4875)                      +ord(ch)-ord('0');
 608 ( 4883)                  getchr
 609 ( 4888)                end {do}
 610 ( 4892)              end; {hex constant}
 611 ( 4898)         chr(39): begin {string}
 612 ( 4905)                token:='st';
 613 ( 4908)                repeat setid until ch=chr(39);
 614 ( 4922)                value[0]:=prec(count); getchr
 615 ( 4938)               end
 616 ( 4942)       end {case of token}
 617 ( 4944)     end {special symbols}
 618 ( 4944)     else setval {numeric value}
 619 ( 4951)   end {main if}
 620 ( 4951)   else begin {ident}
 621 ( 4954)     clear;
 622 ( 4958)     repeat
 623 ( 4958)       setid
 624 ( 4958)       until (ch<'0') or (ch>'z') or
 625 ( 4976)         ((ch>'9') and (ch<'A')) or
 626 ( 4992)         ((ch>'Z') and (ch<'a'));
 627 ( 5008)     ll:=0; hh:=nresw; {look up in resword table}
 628 ( 5024)     repeat
 629 ( 5024)       i:=(ll+hh) shr 1; co:=compresw(i);
 630 ( 5052)       if (co<0) then hh:=prec(i)
 631 ( 5066)       else ll:=succ(i);
 632 ( 5082)       until (co=0) or (ll>hh);
 633 ( 5103)     if (co=0) then
 634 ( 5114)       token:=reswcod[i] {reserved word found}
 635 ( 5121)     else token:='id' {ident}
 636 ( 5135)   end {odent}
 637 ( 5139) end {scan};
 638 ( 5139) 
 639 ( 5140) { * testto/parse * }
 640 ( 5140) 
 641 ( 5140) { parce source for specific token; else error }
 642 ( 5140) 
 643 ( 5140) proc testto(x: packed char); { current token }
 644 ( 5140) begin
 645 ( 5140)   if token<>x then merror(2,x)
 646 ( 5159) end;
 647 ( 5169) 
 648 ( 5170) proc parse(x: packed char); { next token }
 649 ( 5170) begin
 650 ( 5170)   scan; testto(x);
 651 ( 5189) end;
 652 ( 5189) 
 653 ( 5190) { * getlib * }
 654 ( 5190) 
 655 ( 5190) proc getlib;  { read library data }
 656 ( 5190) 
 657 ( 5190) var i,j,nent,addr,size,num,x,base: integer;
 658 ( 5193)     libfil: file;
 659 ( 5193)     ch,ltyp2,dummy: char;

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 12

 660 ( 5193)     name: array[7] of char;
 661 ( 5193) 
 662 ( 5193) begin
 663 ( 5193)   scan; if token=' ,' then scan;
 664 ( 5214)   testto('id');
 665 ( 5223)   base:=pc-2;
 666 ( 5229)   if (ofno<>nooutput) then write(@ofno,'L');
 667 ( 5252)   for i:=0 to 7 do begin
 668 ( 5269)     name[i]:=ident[succ(i)];
 669 ( 5278)     if ofno<>nooutput then
 670 ( 5292)       write(@ofno,ident[succ(i)])
 671 ( 5306)   end;
 672 ( 5312)   write(prtoff);
 673 ( 5329)   asetfile(name&'        ',0,cdrive,'L');
 674 ( 5359)   openr(libfil);  { get table file }
 675 ( 5365)   read(@libfil,nent,size);
 676 ( 5380)   {including cr,lf}
 677 ( 5381)   for i:=succ(spnt) to spnt+nent do begin
 678 ( 5408)     if spnt>symbsize then error(7);
 679 ( 5427)     spnt:=succ(spnt); addr:=8*i+1;
 680 ( 5445)     for j:=0 to 7 do begin
 681 ( 5467)       read(@libfil,ch);
 682 ( 5477)       idtab[addr+j]:=ch
 683 ( 5487)     end;
 684 ( 5498)     read(@libfil,ch);
 685 ( 5522)     read(@libfil,t0[i],dummy,t1[i],t2[i],t3[i]);
 686 ( 5571)     t1[i]:=t1[i]+level;
 687 ( 5584)     ltyp2:=high(t0[i]);
 688 ( 5601)     if (ltyp2='p')or(ltyp2='f')
 689 ( 5619)       or(ltyp2='g') then begin
 690 ( 5629)       t2[i]:=t2[i]+base;
 691 ( 5644)       if t3[i]<>0 then begin {stack data}
 692 ( 5667)         read(@libfil,num);
 693 ( 5677)         push(num); t3[i]:=stackpnt;
 694 ( 5692)         for j:=1 to num do begin
 695 ( 5719)           read(@libfil,x);
 696 ( 5729)           push(x);
 697 ( 5740)         end {for j};
 698 ( 5740)       end {stack data}
 699 ( 5754)     end {if ltyp2}
 700 ( 5754)   end {for i}
 701 ( 5754)   level:=succ(level); pc:=pc+size; offset:=pc;
 702 ( 5790)   close(libfil);
 703 ( 5804)   if spnt>spntmax then spntmax:=spnt;
 704 ( 5816)   if stackpnt>stackmax then stackmax:=stackpnt;
 705 ( 5836)   if prt then write(prton);
 706 ( 5854) end {getlib};
 707 ( 5854) 
 708 ( 5855) 
 709 ( 5855) { #################################### }
 710 ( 5855) {       * block * (global): handle one block }
 711 ( 5855) { #################################### }
 712 ( 5855) 
 713 ( 5855) 
 714 ( 5855) proc block(bottom: integer);
 715 ( 5855) 
 716 ( 5855) var l,f9,i,n,stackpn1,forwpn,find,cproc,
 717 ( 5858)     spnt1,dpnt1,parlevel: integer;
 718 ( 5858)     fortab: array[8] of integer;
 719 ( 5858) 

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 13

 720 ( 5858) { * find ident *    (of block) }
 721 ( 5858) { this is a fast version for compiler speed }
 722 ( 5858) 
 723 ( 5858) func findid; {search in table for id }
 724 ( 5858) 
 725 ( 5858) var k,i: integer;
 726 ( 5861)     id1: char;
 727 ( 5861) 
 728 ( 5861) begin
 729 ( 5861) 
 730 ( 5861)   i:=1; k:=8*spnt+9; id1:=ident[1];
 731 ( 5885) 
 732 ( 5893)   repeat
 733 ( 5893)     k:=k-8;
 734 ( 5899)     while (idtab[k]<>id1) and (k>0) do k:=k-8;
 735 ( 5935)     if k>0 then begin
 736 ( 5950)        i:=1;
 737 ( 5955)        repeat i:=succ(i)
 738 ( 5959)          until (i>8) or
 739 ( 5975)              (idtab[k+i-1]<>ident[i]);
 740 ( 6001)     end;
 741 ( 6005)     until (i>8) or (k<=0);
 742 ( 6019)   if k<=0 then begin
 743 ( 6030)     findid:=0;
 744 ( 6035)   end
 745 ( 6039)   else
 746 ( 6039)     findid:=(k-1) shr 3;
 747 ( 6051) end;
 748 ( 6056) 
 749 ( 6057) { * code2 *    (of block) }
 750 ( 6057) 
 751 ( 6057) proc code2(x,y: integer);
 752 ( 6057) begin
 753 ( 6057)   code1(x); code1(y);
 754 ( 6082) end;
 755 ( 6082) 
 756 ( 6083) { * code3 *    (of block) }
 757 ( 6083) 
 758 ( 6083) proc code3(x: integer; y1: %integer);
 759 ( 6083) 
 760 ( 6083) var y: integer;
 761 ( 6086) 
 762 ( 6086) begin {code3}
 763 ( 6086)   y:=y1;
 764 ( 6088)   if (x=34) and (y>=0) and (y<256) then
 765 ( 6119)     code2(32,y)
 766 ( 6125)   else begin
 767 ( 6138)     if (x=35) and (y>-128) and (y<=127) then
 768 ( 6161)       begin
 769 ( 6162)         if (y<0) then y:=y+256;
 770 ( 6182)         code2(33,y);
 771 ( 6199)       end
 772 ( 6199)     else begin
 773 ( 6202)       if (x>=36) and (x<=38) then y:=y-pc-1;
 774 ( 6231)       code1(x); code1(y and 255);
 775 ( 6259)       code1(y shr 8);
 776 ( 6272)     end
 777 ( 6272)   end
 778 ( 6272) end {code3};
 779 ( 6272) 

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 14

 780 ( 6273) { * testtype *      (of block) }
 781 ( 6273) 
 782 ( 6273) proc testtype(ttype: char);
 783 ( 6273) 
 784 ( 6273) begin
 785 ( 6273)   if restype<>ttype then
 786 ( 6282)     if (restype<>'u') and (ttype<>'u') then
 787 ( 6304)       merror(14,packed(ttype,restype));
 788 ( 6325) end;
 789 ( 6325) 
 790 ( 6326) { * putsym *   (of block) }
 791 ( 6326) 
 792 ( 6326) proc putsym(ltyp1,ltyp2: char);
 793 ( 6326) 
 794 ( 6326) var i,addr: integer;
 795 ( 6329) begin
 796 ( 6329)   if spnt>symbsize then error(7)
 797 ( 6344)   else spnt:=succ(spnt);
 798 ( 6357)   if spnt>spntmax then spntmax:=spnt;
 799 ( 6374)   t0[spnt]:=packed(ltyp1,ltyp2);
 800 ( 6395)   t3[spnt]:=0;
 801 ( 6405)   addr:=8*spnt;
 802 ( 6411)   for i:=1 to 8 do idtab[addr+i]:=ident[i];
 803 ( 6450)   if ltyp1='v' then begin
 804 ( 6482)     t2[spnt]:=dpnt; dpnt:=succ(dpnt);
 805 ( 6501)   end;
 806 ( 6506)   t1[spnt]:=level
 807 ( 6510) end {putsym};
 808 ( 6518) 
 809 ( 6519) { * checkindex *  (of block) }
 810 ( 6519) 
 811 ( 6519) proc checkindex(lowlim,highlim: integer);
 812 ( 6519) begin
 813 ( 6519)   if icheck then begin
 814 ( 6528)     code3($40,lowlim-1);
 815 ( 6546)     code2(highlim and 255, highlim shr 8)
 816 ( 6559)   end
 817 ( 6566) end;
 818 ( 6566) 
 819 ( 6567) { * getcon *      (of block) }
 820 ( 6567) 
 821 ( 6567) func getcon;
 822 ( 6567) 
 823 ( 6567) var idpnt,val,ii: integer;
 824 ( 6570)     rval: real;
 825 ( 6570)     sign: char;
 826 ( 6570) begin
 827 ( 6570)   restype:='i';
 828 ( 6574)   if token=' -' then begin
 829 ( 6586)     sign:='-'; scan
 830 ( 6595)   end else begin
 831 ( 6602)     sign:='+'; if token=' +' then scan
 832 ( 6616)   end;
 833 ( 6623)   case token of
 834 ( 6623)     'nu': val:=value[0];
 835 ( 6637)     'ru': begin val:=value[0];
 836 ( 6658)             restype:='r' end;
 837 ( 6672)     'st': if value[0]=1 then begin
 838 ( 6692)             restype:='c';
 839 ( 6697)             val:=ord(ident[1])

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 15

 840 ( 6703)           end else if value[0]=2 then begin
 841 ( 6723)             val:=(ord(ident[1]) shl 8) +
 842 ( 6735)               ord(ident[2]);
 843 ( 6741)             restype:='p';
 844 ( 6748)           end else if value[0]>2 then begin
 845 ( 6764)             val:=pc;
 846 ( 6767)             for ii:=1 to value[0] do
 847 ( 6783)                         code1(ord(ident[ii]));
 848 ( 6810)             code1(0); value[0]:=0; restype:='s';
 849 ( 6842)           end else error(15);
 850 ( 6857)     'cr': begin parse(' ('); scan; val:=getcon;
 851 ( 6887)             if (val>127) or (val<0) then
 852 ( 6905)               error(12);
 853 ( 6917)             testtype('i');
 854 ( 6925)             restype:='c'; parse(' )');
 855 ( 6940)           end;
 856 ( 6940)     'tr': begin val:=1; restype:='b' end;
 857 ( 6963)     'fa': begin val:=0; restype:='b' end;
 858 ( 6986)     'cp': begin
 859 ( 6997)             scan; val:=getcon;
 860 ( 7007)             testtype('i'); restype:='q';
 861 ( 7021)           end;
 862 ( 7025)     ' @': begin scan; val:=getcon;
 863 ( 7046)             if restype<>'q' then testtype('i');
 864 ( 7068)             restype:='f'
 865 ( 7068)           end
 866 ( 7070)     else begin
 867 ( 7077)       testto('id'); idpnt:=findid;
 868 ( 7092)       if (idpnt>0) and (high(t0[idpnt])='c')
 869 ( 7114)       then begin
 870 ( 7116)         val:=t2[idpnt];
 871 ( 7123)         restype:=low(t0[idpnt]);
 872 ( 7139)         if restype='r' then
 873 ( 7150)           value[1]:=t3[idpnt];
 874 ( 7160)       end
 875 ( 7168)       else begin error(4); val:=0;
 876 ( 7181)         restype:='i'
 877 ( 7185)       end
 878 ( 7187)     end
 879 ( 7191)   end {case};
 880 ( 7193)   if sign='-' then
 881 ( 7199)     case restype of
 882 ( 7203)       'i': getcon:=-val;
 883 ( 7214)       'r': begin value[0]:=val;
 884 ( 7235)              splitconv(value,rval);
 885 ( 7267)              splitconv(-rval,value);
 886 ( 7292)              getcon:=value[0]
 887 ( 7294)            end
 888 ( 7294)       else error(12)
 889 ( 7307)     end {case}
 890 ( 7315)   else getcon:=val;
 891 ( 7318) end {getcon};
 892 ( 7326) 
 893 ( 7327) { * deccon *         ( of block ) }
 894 ( 7327) 
 895 ( 7327) proc deccon;    { declare constant }
 896 ( 7327) begin
 897 ( 7327)   if token=' ;' then scan;
 898 ( 7347)   testto('id');
 899 ( 7356)   putsym('c','i');

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 16

 900 ( 7366)   parse(' ='); scan;
 901 ( 7379)   t2[spnt]:=getcon;
 902 ( 7389)   if (restype='r') then t3[spnt]:=value[1];
 903 ( 7409)   if restype<>'i' then
 904 ( 7423)     t0[spnt]:=packed('c',restype);
 905 ( 7438)   scan
 906 ( 7442) end {deccon};
 907 ( 7446) 
 908 ( 7447) { * decvar *          ( of block ) }
 909 ( 7447) 
 910 ( 7447) proc decvar(typ1,typ2: char);
 911 ( 7447) begin
 912 ( 7447)   if token=' ,' then scan;
 913 ( 7467)   testto('id');
 914 ( 7476)   putsym(typ1,typ2);
 915 ( 7490)   scan;
 916 ( 7494) end {decvar};
 917 ( 7494) 
 918 ( 7495) { * gettype *         ( of block ) }
 919 ( 7495) 
 920 ( 7495) proc gettype(var typ2: char;
 921 ( 7495)   var aflag,uflag: boolean; var n: integer);
 922 ( 7495) 
 923 ( 7495) begin
 924 ( 7495)   aflag:=false; n:=0; uflag:=false;
 925 ( 7514)   scan;
 926 ( 7522)   if token='ar' then begin
 927 ( 7530)     parse(' ['); scan;
 928 ( 7546)     n:=getcon; testtype('i');
 929 ( 7564)     if (n<1) then begin error(15); n:=1 end;
 930 ( 7588)     parse(' ]'); parse('of'); scan;
 931 ( 7610)     aflag:=true
 932 ( 7610)   end;
 933 ( 7616)   if token=' %' then begin
 934 ( 7624)     scan; uflag:=true
 935 ( 7631)   end;
 936 ( 7637)   case token of
 937 ( 7637)     'in': typ2:='i';
 938 ( 7651)     'ch': typ2:='c';
 939 ( 7668)     'pa': begin parse ('ch'); typ2:='p' end;
 940 ( 7698)     'bo': typ2:='b';
 941 ( 7711)     'rl': begin typ2:='r'; aflag:=true;
 942 ( 7734)             n:=prec(2*succ(n)) end;
 943 ( 7751)     'cp': typ2:='q';
 944 ( 7764)     'fl': typ2:='f'
 945 ( 7779)     else begin error(11); typ2:='i';end
 946 ( 7802)   end {case}
 947 ( 7804) end {gettype};
 948 ( 7804) 
 949 ( 7805) { * variable *        ( of block) }
 950 ( 7805) 
 951 ( 7805) proc variable;  { variable declarations }
 952 ( 7805) 
 953 ( 7805) var typ1,typ2: char;
 954 ( 7808)     i,l: integer;
 955 ( 7808)     aflag,uflag: boolean;
 956 ( 7808) 
 957 ( 7808) begin
 958 ( 7808)   scan;
 959 ( 7814)   repeat {main loop}

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 17

 960 ( 7814)     l:=0;
 961 ( 7816)     repeat decvar('v','i'); l:=succ(l);
 962 ( 7834)     until token<> ' ,';
 963 ( 7846)     testto(' :');
 964 ( 7859)     gettype(typ2,aflag,uflag,n);
 965 ( 7895)     if uflag then error(11);
 966 ( 7910)     if aflag then typ1:='a' else typ1:='v';
 967 ( 7928)     if typ1='a' then begin {array}
 968 ( 7942)        dpnt:=dpnt-l; {variable has been assumed}
 969 ( 7955)        for i:=succ(spnt-l) to spnt do begin
 970 ( 7982)          t2[i]:=dpnt; t3[i]:=n;
 971 ( 7998)          dpnt:=succ(dpnt+n);
 972 ( 8015)       end
 973 ( 8020)     end {array};
 974 ( 8034)     for i:=succ(spnt-l) to spnt do
 975 ( 8048)       t0[i]:=packed(typ1,typ2);
 976 ( 8074)     parse(' ;');scan
 977 ( 8101)   until token<>'id' {end main loop}
 978 ( 8112) end {variable};
 979 ( 8116) 
 980 ( 8117) { * fixup *           ( of block ) }
 981 ( 8117) 
 982 ( 8117) proc fixup(x: integer);
 983 ( 8117) begin
 984 ( 8117)   if ofno<>nooutput then begin
 985 ( 8129)     write(@ofno,'F');
 986 ( 8140)     savebyte(succ(x-offset) and 255);
 987 ( 8159)     savebyte(succ(x-offset) shr 8);
 988 ( 8178)     savebyte((pc-x-1) and 255);
 989 ( 8199)     savebyte((pc-x-1) shr 8);
 990 ( 8220)   end;
 991 ( 8220) end;
 992 ( 8220) 
 993 ( 8221) { * function *        ( of block ) }
 994 ( 8221) 
 995 ( 8221) proc function;
 996 ( 8221) 
 997 ( 8221) var n: integer;
 998 ( 8224)     typ1,typ2: char;
 999 ( 8224)     aflag,uflag: boolean;
1000 ( 8224) begin
1001 ( 8224)   if token<>' :' then begin
1002 ( 8234)     aflag:=false; uflag:=false; typ2:='i' end
1003 ( 8251)   else begin
1004 ( 8258)     gettype(typ2,aflag,uflag,n);
1005 ( 8294)     scan
1006 ( 8294)   end;
1007 ( 8298)   if aflag then begin
1008 ( 8302)     typ1:='s'; t3[succ(cproc)]:=n;
1009 ( 8316)     t2[succ(cproc)]:=t2[succ(cproc)]-n
1010 ( 8338)   end
1011 ( 8338)   else typ1:='r';
1012 ( 8352)   t0[succ(cproc)]:=packed(typ1,typ2);
1013 ( 8370)   if uflag then typ2:='u';
1014 ( 8383)   if aflag then typ1:='g'
1015 ( 8394)   else typ1:='f';
1016 ( 8405)   t0[cproc]:=packed(typ1,typ2);
1017 ( 8422) end {function};
1018 ( 8426) 
1019 ( 8427) { * parameter *       ( of block ) }

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 18

1020 ( 8427) 
1021 ( 8427) proc parameter;
1022 ( 8427) 
1023 ( 8427) var counter1,counter2,i,n,bs: integer;
1024 ( 8430)     aflag,uflag: boolean;
1025 ( 8430)     vtype1,vtype2: char;
1026 ( 8430)     vtype: packed char;
1027 ( 8430) 
1028 ( 8430) begin
1029 ( 8430)   push(0); { dummy size, fixed later }
1030 ( 8440)   if find=0 then t3[spnt-npara]:=stackpnt
1031 ( 8459)   else bs:=stackpnt;
1032 ( 8470)   counter1:=0
1033 ( 8478)   repeat {main loop}
1034 ( 8484)     counter2:=0;
1035 ( 8486)     vtype1:='d'; vtype2:='i';
1036 ( 8498)     scan;
1037 ( 8506)     if token='co' then scan
1038 ( 8514)     else if token='va' then begin
1039 ( 8532)       scan; vtype1:='w' end; {variable param}
1040 ( 8545)     end;
1041 ( 8545)     repeat {inner loop}
1042 ( 8545)       decvar(vtype1,vtype2);
1043 ( 8559)       t2[spnt]:=parlevel;
1044 ( 8563)       parlevel:=succ(parlevel);
1045 ( 8575)       npara:=succ(npara);
1046 ( 8584)       counter2:=succ(counter2);
1047 ( 8593)       until token<>' ,';
1048 ( 8605)     uflag:=false;aflag:=false; n:=0;
1049 ( 8623)     if token<>' :' then
1050 ( 8634)       vtype2:='i' {assume integer }
1051 ( 8640)     else begin
1052 ( 8647)       gettype(vtype2,aflag,uflag,n);
1053 ( 8683)       if n>63 then error(15);
1054 ( 8701)       scan
1055 ( 8701)     end;
1056 ( 8705)     if aflag then begin
1057 ( 8709)       vtype1:=succ(vtype1);
1058 ( 8716)       parlevel:=parlevel-counter2;
1059 ( 8725)     end;
1060 ( 8734)     vtype:=packed(vtype1,vtype2);
1061 ( 8743)     for i:=1 to counter2 do begin
1062 ( 8766)       if uflag then push(packed(vtype1,'u'))
1063 ( 8780)       else push(vtype);
1064 ( 8799)       if aflag then begin
1065 ( 8803)         push(n); t3[spnt-counter2+i]:=n;
1066 ( 8830)         t2[spnt-counter2+i]:=parlevel;
1067 ( 8852)         parlevel:=succ(parlevel)+n;
1068 ( 8865)       end {then};
1069 ( 8874)       t0[spnt-counter2+i]:=vtype;
1070 ( 8888)     end {for};
1071 ( 8896)     if aflag then counter2:=2*counter2;
1072 ( 8919)     counter1:=counter1+counter2;
1073 ( 8932)     until token<>' ;'; {outer loop}
1074 ( 8952)   testto(' )'); scan;
1075 ( 8965)   if find=0 then
1076 ( 8971)     stack[t3[spnt-npara]]:=counter1
1077 ( 8988)   else begin {information is allready there}
1078 ( 8999)     stack[bs]:=counter1;
1079 ( 9003)     n:=t3[fortab[find]]; {existing stack data}

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 19

1080 ( 9027)     for i:=0 to stackpnt-bs do
1081 ( 9037)       if stack[bs+1]<>stack[n+1]
1082 ( 9068)         then merror(13,'pa'); {parameter wrong}
1083 ( 9102)     stackpnt:=prec(bs) {clear the new info}
1084 ( 9106)   end  {else}
1085 ( 9111) end {parameter};
1086 ( 9111) 
1087 ( 9112) { * memory *              ( of block) }
1088 ( 9112) 
1089 ( 9112) proc memory;
1090 ( 9112) 
1091 ( 9112) var typ1,typ2:char;
1092 ( 9115)     i,l,n: integer;
1093 ( 9115)     aflag,uflag: boolean;
1094 ( 9115) 
1095 ( 9115) begin
1096 ( 9115)   scan;
1097 ( 9121)   repeat {main loop}
1098 ( 9121)     l:=0;
1099 ( 9123)     repeat
1100 ( 9127)       decvar('m','i');
1101 ( 9137)       l:=succ(l); testto(' ='); scan;
1102 ( 9159)       n:=getcon; testtype('i');
1103 ( 9177)       scan; t2[spnt]:=n;
1104 ( 9185)     until token<>' ,';
1105 ( 9200)     testto(' :');
1106 ( 9213)     gettype(typ2,aflag,uflag,n);
1107 ( 9249)     if uflag then error(11);
1108 ( 9264)     scan;
1109 ( 9268)     if token=' &' then begin {8-bit}
1110 ( 9279)       typ1:='h'; scan
1111 ( 9285)     end
1112 ( 9289)     else typ1:='m';
1113 ( 9294)     if aflag then typ1:=succ(typ1);
1114 ( 9309)     for i:=succ(spnt-l) to spnt do begin
1115 ( 9341)       t0[i]:=packed(typ1,typ2);
1116 ( 9354)       t3[i]:=n;
1117 ( 9362)     end;
1118 ( 9370)     testto(' ;'); scan;
1119 ( 9397)   until token<>'id';
1120 ( 9404) end {memory};
1121 ( 9408) 
1122 ( 9409) 
1123 ( 9409) {######################################}
1124 ( 9409) { * statement *           ( of block ) }
1125 ( 9409) {######################################}
1126 ( 9409) 
1127 ( 9409) proc statmnt;
1128 ( 9409) 
1129 ( 9409) var idpnt,relad,k2,savpc,bottom1: integer;
1130 ( 9412)     device,wln: boolean;
1131 ( 9412)     savtp1,vartyp2: char;
1132 ( 9412)     wl: boolean;
1133 ( 9412) 
1134 ( 9412) { * code4 *               ( of statement ) }
1135 ( 9412) 
1136 ( 9412) proc code4(x,y1,z1: integer); {set 4-byte code}
1137 ( 9412) 
1138 ( 9412) var y,z: integer;
1139 ( 9415) 

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 20

1140 ( 9415) begin
1141 ( 9415)   y:=y1; z:=z1;
1142 ( 9425)   if y<0 then y:=y+256;
1143 ( 9450)   if x=43 then z:=z-pc-2;
1144 ( 9476)   code1(x);code1(y);code1(z and 255);
1145 ( 9514)   code1(z shr 8)
1146 ( 9520) end {code4};
1147 ( 9527) 
1148 ( 9528) { * testferror *         ( of statement) ) }
1149 ( 9528) 
1150 ( 9528) proc testferror;
1151 ( 9528) begin
1152 ( 9528)   code1($4f);
1153 ( 9541) end;
1154 ( 9541) 
1155 ( 9542) { * gpval *              ( of statement ) }
1156 ( 9542) 
1157 ( 9542) proc gpval(idpnt: integer;
1158 ( 9542)   dir: boolean; typ: char);
1159 ( 9542) 
1160 ( 9542) var d: integer;
1161 ( 9545) 
1162 ( 9545) begin {gpval}
1163 ( 9545)   if dir then d:=1 else d:=0;
1164 ( 9565)   case typ of
1165 ( 9569)   'h':  begin code3($22,t2[idpnt]);
1166 ( 9596)           if dir then code1($3f);
1167 ( 9611)           code1($17+d) end;
1168 ( 9624)   'm':  begin code3($22,t2[idpnt]);
1169 ( 9650)           code1($3d+d) end;
1170 ( 9663)   'i':  begin
1171 ( 9673)           if dir then code1($3f);
1172 ( 9688)           code3($22,t2[idpnt]);
1173 ( 9704)           code1(3);
1174 ( 9712)           if dir then code1($3f);
1175 ( 9727)           code1($17+d) end;
1176 ( 9740)   'n':  begin if dir then code1($3f);
1177 ( 9765)           code3($22,1); code1($12);
1178 ( 9783)           code3($22,t2[idpnt]);
1179 ( 9799)           code1(3); code1($3d+d) end
1180 ( 9820)   else begin
1181 ( 9823)     if typ='q' then begin
1182 ( 9830)       code4($55,level-t1[idpnt],2*t2[idpnt]);
1183 ( 9865)     end else
1184 ( 9865)       code4($27+2*d+relad,level-t1[idpnt],
1185 ( 9891)         2*t2[idpnt]);
1186 ( 9913)     end
1187 ( 9913)   end {case}
1188 ( 9915) end;
1189 ( 9915) 
1190 ( 9916) { FORWARD decl. of mainexp (of statement) }
1191 ( 9916) 
1192 ( 9916) proc mainexp(reqtype: char;
1193 ( 9916)   var arsize: integer); forward;
1194 ( 9919) 
1195 ( 9919) { * express *           ( of statement ) }
1196 ( 9919) 
1197 ( 9919) proc express; {requests a normal 16-bit result }
1198 ( 9919) 
1199 ( 9919) var resultsize: integer;

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 21

1200 ( 9922) 
1201 ( 9922) begin {express}
1202 ( 9922)   mainexp('n',resultsize);
1203 ( 9940)   if resultsize<>0 then error(15)
1204 ( 9952) end {express};
1205 ( 9958) 
1206 ( 9959) { * arrayexp *          ( of mainexp) }
1207 ( 9959) 
1208 ( 9959) proc arrayexp(size: integer; eltype: char);
1209 ( 9959) 
1210 ( 9959) var resultsize: integer;
1211 ( 9962) 
1212 ( 9962) begin
1213 ( 9962)   mainexp(eltype,resultsize);
1214 ( 9982)   if resultsize<>size then error(15);
1215 (10002)   testtype(eltype);
1216 (10012) end;
1217 (10012) 
1218 (10013) { * getvar *            ( of statement ) }
1219 (10013) 
1220 (10013) proc getvar;
1221 (10013) begin
1222 (10013)   vartyp2:=high(t0[idpnt]);
1223 (10026)   vartype:=low(t0[idpnt]);
1224 (10039)   scan;
1225 (10048)   if (vartype='q') and (token=' [') and
1226 (10063)     ((vartyp2='v') or (vartyp2='d')) then begin
1227 (10080)     vartyp2:='q'; vartype:='c';
1228 (10091)   end;
1229 (10095)   case vartyp2 of
1230 (10095)   'a','x','s','i','n','q':
1231 (10138)       begin
1232 (10141)         if token=' [' then begin
1233 (10149)           scan; express; relad:=1;
1234 (10162)           if vartyp2='r' then begin
1235 (10173)             relad:=3;
1236 (10178)             code3($22,1); code1($12)
1237 (10194)           end;
1238 (10200)           if (vartyp2='q') and (t3[idpnt]=0) then
1239 (10218)             checkindex(0,63)
1240 (10226)           else
1241 (10232)             checkindex(0,t3[idpnt]);
1242 (10251)           testtype('i'); testto(' ]'); scan;
1243 (10272)         end else relad:=2;
1244 (10277)       end;
1245 (10281)   'v','w','r','h','m': relad:=0;
1246 (10321)   'c','d','e','t','u': error(6)
1247 (10365)   else error(1)
1248 (10376)   end {case}
1249 (10384) end {getvar};
1250 (10384) 
1251 (10385) { * prcall *            ( of statement ) }
1252 (10385) 
1253 (10385) proc prcall (idpn1: integer);
1254 (10385) 
1255 (10385) var bstack,numpar,i,n,n2: integer;
1256 (10388) 
1257 (10388) { body of prcall follows later }
1258 (10388) 
1259 (10388) { * prcall1 *           ( of prcall ) }

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 22

1260 (10388) 
1261 (10388) proc prcall1;
1262 (10388) var ressize:integer;
1263 (10391) 
1264 (10391)   proc prcall3;
1265 (10391)   begin {prcall3}
1266 (10394)     testto('id');
1267 (10405)     idpnt:=findid;
1268 (10411)     if idpnt=0 then error(5);
1269 (10433)     getvar;
1270 (10437)     if chr(stack[i] and 255)<>vartype then
1271 (10449)       if chr(stack[i] and 255)<>'u' then
1272 (10471)         merror(14,'01');
1273 (10486)       push(idpnt);
1274 (10496)   end {prcall3};
1275 (10496) 
1276 (10497) begin {prcall1}
1277 (10497)   case chr(stack[i] shr 8) of
1278 (10510)     'd':  begin
1279 (10518)             if chr(stack[i] and 255) = 'q' then
1280 (10532)               mainexp('q',ressize)
1281 (10538)             else
1282 (10552)               express;
1283 (10559)             if chr(stack[i] and 255)<>'u' then
1284 (10573)               testtype(chr(stack[i] and 255));
1285 (10595)           end;
1286 (10595)     'e':  begin
1287 (10605)             arrayexp(stack[succ(i)],
1288 (10610)               chr(stack[i]));
1289 (10629)             i:=succ(i);
1290 (10633)           end;
1291 (10638)     'w':  begin
1292 (10648)             prcall3;
1293 (10652)             if relad<>0 then merror(14,'02');
1294 (10673)             gpval(idpnt,false,vartyp2);
1295 (10689)           end;
1296 (10689)     'x':  begin
1297 (10699)             prcall3;
1298 (10703)             if relad<>2 then merror(14,'03');
1299 (10724)             if vartyp2='i' then error(16);
1300 (10742)             i:=succ(i);
1301 (10746)             if stack[i]<>t3[idpnt] then
1302 (10763)               error(15);
1303 (10779)             if vartyp2='n' then begin
1304 (10786)               code3($22,t2[idpnt]);
1305 (10805)               code1($3d);
1306 (10813)             end else code4($27,level-t1[idpnt],
1307 (10826)               2*t2[idpnt]);
1308 (10848)             code2($3b,stack[i]);
1309 (10864)           end
1310 (10864)     else merror(14,'04')
1311 (10872)   end {case}
1312 (10880) end {prcall1};
1313 (10880) 
1314 (10881) proc prcall2;
1315 (10881) begin
1316 (10881)   if n>0 then code3(35,-2*n);
1317 (10912)   n:=0
1318 (10912) end {prcall2};
1319 (10918) 

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 23

1320 (10919) begin {body of prcall}
1321 (10919)   if t3[idpn1]<>0 then begin
1322 (10932)     bstack:=t3[idpn1];
1323 (10939)     numpar:=stack[bstack];
1324 (10951)     parse(' ('); scan;
1325 (10972)     for i:=succ(bstack) to bstack+numpar do
1326 (10985)     begin
1327 (10999)       prcall1;
1328 (11003)       if i<bstack+numpar then begin
1329 (11017)         testto(' ,'); scan
1330 (11029)       end
1331 (11033)     end;
1332 (11033)     testto(' )');
1333 (11056)   end {then};
1334 (11056)   code4(43,level-t1[idpn1],t2[idpn1]);
1335 (11085)   if t3[idpn1]<>0 then begin
1336 (11096)     n:=0; i:=bstack+numpar;
1337 (11109)     repeat
1338 (11118)       case chr(stack[i] shr 8) of
1339 (11129)       'd':  n:=succ(n);
1340 (11141)       'w':  begin
1341 (11156)               prcall2; idpnt:=pop;
1342 (11166)               gpval(idpnt,true,
1343 (11176)                   high(t0[idpnt]));
1344 (11191)             end;
1345 (11191)       chr(0): begin
1346 (11201)             n2:=stack[i];
1347 (11205)             i:=i-1;
1348 (11219)             case chr(stack[i] shr 8) of
1349 (11235)               'e':  n:=succ(n+n2);
1350 (11252)               'x':  begin
1351 (11267)                       prcall2;
1352 (11271)                       idpnt:=pop;
1353 (11277)                       if high(t0[idpnt])='n'
1354 (11290)                       then begin
1355 (11293)                         code3($22,t2[idpnt]+
1356 (11302)                           2*t3[idpnt]);
1357 (11324)                         code1($3e)
1358 (11326)                       end else
1359 (11332)                         code4(41,
1360 (11337)                           level-t1[idpnt],
1361 (11345)                           2*(t2[idpnt]+
1362 (11356)                           t3[idpnt]));
1363 (11376)                       code2($3c,t3[idpnt])
1364 (11382)                     end
1365 (11392)               end {case}
1366 (11394)             end
1367 (11394)       end; {case}
1368 (11396)       i:=prec(i);
1369 (11400)     until i=bstack;
1370 (11409)     prcall2
1371 (11417)   end
1372 (11421) end {prcall};
1373 (11421) 
1374 (11422) 
1375 (11422) {###################################}
1376 (11422) { * mainexp *       ( of statement) }
1377 (11422) {###################################}
1378 (11422) {  see forward declaration above    }
1379 (11422) 

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 24

1380 (11422) proc mainexp(reqtype: char;
1381 (11422)   var arsize: integer);
1382 (11422) 
1383 (11422) { variables of mainexp}
1384 (11422) var opcode,roff: integer;
1385 (11425)     savtype: char;
1386 (11425) 
1387 (11425) { * argument *         ( of mainexp ) }
1388 (11425) 
1389 (11425) proc argument(rtype: char);
1390 (11425) begin
1391 (11425)   parse(' ('); scan; express;
1392 (11447)   testtype(rtype);
1393 (11457)   testto(' )'); scan
1394 (11466) end; {argument}
1395 (11471) 
1396 (11471) {#######################################}
1397 (11471) { * simexp *             ( of mainexp ) }
1398 (11471) {#######################################}
1399 (11471) 
1400 (11471) proc simexp(var arsize1: integer);
1401 (11471) 
1402 (11471) var opcode: integer;
1403 (11474)     sign: char;
1404 (11474) 
1405 (11474) {body of simexp  follows later }
1406 (11474) 
1407 (11474) {#######################################}
1408 (11474) { * term *               ( of simexp )  }
1409 (11474) {#######################################}
1410 (11474) 
1411 (11474) proc term(var arsize2: integer);
1412 (11474) 
1413 (11474) var opcode: integer;
1414 (11477) 
1415 (11477) { body of term follows later }
1416 (11477) 
1417 (11477) {#######################################}
1418 (11477) { * factor *             ( of term )    }
1419 (11477) {#######################################}
1420 (11477) 
1421 (11477) proc factor(var arsize3: integer);
1422 (11477) 
1423 (11477) var i, idpnt: integer;
1424 (11480)     h: char;
1425 (11480) 
1426 (11480) { * index *              ( of factor )  }
1427 (11480) 
1428 (11480) proc index(chk: boolean);
1429 (11480) 
1430 (11480) var savtype: char;
1431 (11483) 
1432 (11483) begin {index}
1433 (11483)   scan; savtype:=restype;
1434 (11489)   express; testtype('i'); testto(' ]');
1435 (11518)   if savtype='r' then begin
1436 (11525)     code3($22,1); code1($12);
1437 (11546)   end;
1438 (11546)   if chk then begin
1439 (11550)     if (savtype='q') and (t3[idpnt]=0) then

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 25

1440 (11571)       { is an arrayed cpnt }
1441 (11572)       checkindex(0,63)
1442 (11579)     else
1443 (11585)       checkindex(0,t3[idpnt]);
1444 (11604)   end;
1445 (11604)   restype:=savtype; scan
1446 (11612) end;
1447 (11616) 
1448 (11617) 
1449 (11617) begin { *** body of factor *** }
1450 (11617)   arsize3:=0;
1451 (11621)   case token of
1452 (11625)     'id': begin {identifier }
1453 (11637)             idpnt:=findid;
1454 (11643)             if idpnt=0 then error(5);
1455 (11665)             restype:=low(t0[idpnt]);
1456 (11673)             h:=high(t0[idpnt]);
1457 (11686)             case h of
1458 (11691)               'v','w','d':
1459 (11713)                     begin
1460 (11716)                       scan;
1461 (11720)                       if (restype='q') and (token=' [')
1462 (11734)                       then begin
1463 (11736)                         code4(39,level-t1[idpnt],
1464 (11749)                           2*t2[idpnt]);
1465 (11771)                         index(true);
1466 (11779)                         code1($03);
1467 (11787)                         code1($54);
1468 (11795)                         restype:='c';
1469 (11797)                       end else
1470 (11801)                         code4(39,level-t1[idpnt],
1471 (11814)                           2*t2[idpnt]);
1472 (11836)                     end;
1473 (11836)               'h':  begin code3($22,t2[idpnt]);
1474 (11862)                       code1($17); scan end;
1475 (11874)               'i':  begin code3($22,t2[idpnt]);
1476 (11900)                       scan;
1477 (11904)                       if token=' [' then begin
1478 (11912)                         index(true); code1($03);
1479 (11931)                         code1($17)
1480 (11933)                       end else begin
1481 (11942)                         error(16)
1482 (11944)                       end
1483 (11950)                     end;
1484 (11950)               'm':  begin code3($22,t2[idpnt]);
1485 (11976)                       code1($3d); scan
1486 (11984)                     end;
1487 (11988)               'n':  begin code3($22,t2[idpnt]);
1488 (12014)                       scan;
1489 (12018)                       if token=' [' then begin
1490 (12026)                         index(true);
1491 (12037)                         code3($22,1);code1($12);
1492 (12055)                         code1($03); code1($3d);
1493 (12071)                         if restype='r' then
1494 (12077)                         begin
1495 (12078)                           code2($3b,1);
1496 (12091)                           arsize3:=1
1497 (12091)                         end
1498 (12093)                       end else begin
1499 (12100)                         code1($3d);

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 26

1500 (12108)                         code2($3b,t3[idpnt]);
1501 (12124)                         arsize3:=t3[idpnt];
1502 (12128)                       end
1503 (12136)                     end;
1504 (12136)               'r','t': begin
1505 (12153)                       code3(35,2);
1506 (12163)                       idpnt:=prec(idpnt);
1507 (12167)                       prcall(idpnt); scan;
1508 (12186)                       restype:=low(t0[idpnt]);
1509 (12194)                     end;
1510 (12199)               'c':  if low(t0[idpnt])<>'r' then begin
1511 (12221)                       code3(34,t2[idpnt]);
1512 (12240)                       scan;
1513 (12244)                       if restype='s' then begin
1514 (12251)                         if token=' [' then begin
1515 (12262)                           index(true);
1516 (12273)                           code1($03);
1517 (12281)                           code1($58);
1518 (12289)                           code1($54);
1519 (12297)                           restype:='c';
1520 (12299)                         end else begin
1521 (12306)                           code1($58);
1522 (12314)                           restype:='q';
1523 (12316)                         end;
1524 (12320)                       end;
1525 (12320)                       {scan;}
1526 (12320)                     end else begin
1527 (12323)                       code2($3a,2);
1528 (12333)                       code2(t2[idpnt] and 255,
1529 (12343)                         t2[idpnt] shr 8);
1530 (12361)                       code2(t3[idpnt] and 255,
1531 (12371)                         t3[idpnt] shr 8);
1532 (12389)                       arsize3:=1; scan
1533 (12395)                     end;
1534 (12399)               'a','e','x':
1535 (12420)                     begin scan;
1536 (12427)                       if token=' [' then begin
1537 (12435)                         index(true);
1538 (12446)                         code4($28,
1539 (12448)                             level-t1[idpnt],
1540 (12456)                             2*t2[idpnt]);
1541 (12478)                         if restype='r' then
1542 (12484)                         begin
1543 (12485)                           code2($3b,1);
1544 (12498)                           arsize3:=1
1545 (12498)                         end
1546 (12500)                       end else begin
1547 (12507)                         code4($27,
1548 (12509)                             level-t1[idpnt],
1549 (12517)                             2*t2[idpnt]);
1550 (12539)                         code2($3b,t3[idpnt]);
1551 (12555)                         arsize3:=t3[idpnt];
1552 (12559)                       end
1553 (12567)                     end;
1554 (12567)               's','u':
1555 (12581)                     begin
1556 (12584)                       code3(35,2*t3[idpnt]+2);
1557 (12606)                       idpnt:=prec(idpnt);
1558 (12610)                       prcall(idpnt); scan;
1559 (12629)                       restype:=low(t0[idpnt]);

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 27

1560 (12637)                       idpnt:=succ(idpnt);
1561 (12646)                       arsize3:=t3[idpnt]
1562 (12651)                     end
1563 (12655)               else error(1)
1564 (12668)             end {case}
1565 (12676)           end; {identifier}
1566 (12679)     'nu': begin code3(34,value[0]); scan;
1567 (12705)             restype:='i'
1568 (12705)           end;
1569 (12711)     'ru': begin code2($3a,2);
1570 (12732)             code2(value[0] and 255,
1571 (12740)               value[0] shr 8);
1572 (12756)             code2(value[1] and 255,
1573 (12764)               value[1] shr 8);
1574 (12780)             scan; restype:='r';
1575 (12786)             arsize3:=1
1576 (12790)           end;
1577 (12796)     'st': begin
1578 (12807)           if (reqtype='n') and (value[0]<3)
1579 (12822)             then begin
1580 (12824)               if value[0]<2 then begin
1581 (12836)                 code3(34,ord(ident[1]));
1582 (12853)                 restype:='c'
1583 (12853)               end else begin
1584 (12862)                 code3(34,packed(ident[1],
1585 (12866)                   ident[2]));
1586 (12883)                 restype:='p'
1587 (12883)               end
1588 (12885)             end else begin
1589 (12892)               case reqtype of
1590 (12892)                 'c','u','n','q':
1591 (12921)                     begin
1592 (12924)                       if (vartype='q') or
1593 (12931)                          (reqtype='q') then begin
1594 (12939)                         arsize3:=0;
1595 (12944)                         restype:='q';
1596 (12950)                         code2($56,value[0]);
1597 (12968)                       end else begin
1598 (12971)                         arsize3:=prec(value[0]);
1599 (12977)                         restype:='c';
1600 (12984)                         code2($39,value[0]);
1601 (13002)                       end;
1602 (13002)                       for i:=1 to value[0] do
1603 (13010)                         code1(ord(ident[i]));
1604 (13037)                       if (vartype='q') or
1605 (13058)                          (reqtype='q') then code1(0);
1606 (13077)                     end;
1607 (13077)                 'p': begin
1608 (13087)                       if odd(value[0]) then
1609 (13093)                         error(15);
1610 (13105)                       value[0]:=value[0] shr 1;
1611 (13115)                       arsize3:=prec(value[0]);
1612 (13126)                       restype:='p';
1613 (13133)                       code2($3a,value[0]);
1614 (13151)                       for i:=1 to value[0] do
1615 (13159)                         begin
1616 (13172)                         code1(ident[2*i]);
1617 (13189)                         code1(ident[2*i-1]);
1618 (13209)                       end
1619 (13209)                     end

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 28

1620 (13209)                 else merror(14,'05')
1621 (13231)               end {case}
1622 (13239)             end;
1623 (13239)             scan
1624 (13239)           end;
1625 (13243)     'od': begin
1626 (13254)             argument('i'); code1(7);
1627 (13270)             restype:='b'
1628 (13270)           end;
1629 (13276)     'me': begin
1630 (13287)             parse(' ['); index(false);
1631 (13304)             code1(23); restype:='i';
1632 (13314)           end;
1633 (13318)     ' (': begin
1634 (13329)             scan; mainexp(reqtype,arsize3);
1635 (13351)             testto(' )'); scan
1636 (13360)           end; {no type change}
1637 (13367)     'no': begin
1638 (13375)             scan; factor(arsize3);
1639 (13391)             if (arsize3<>0) then error(15);
1640 (13409)             code1($11);
1641 (13417)             if restype<>'i' then
1642 (13423)               testtype('b')
1643 (13429)           end;
1644 (13435)     'cr': begin
1645 (13446)             argument('i'); code1(52);
1646 (13462)             restype:='c'
1647 (13462)           end;
1648 (13468)     'hi': begin
1649 (13479)             argument('p'); code1(51);
1650 (13495)             restype:='c'
1651 (13495)           end;
1652 (13501)     'lo': begin
1653 (13512)             argument('p'); code1(52);
1654 (13528)             restype:='c'
1655 (13528)           end;
1656 (13534)     'su': begin
1657 (13545)             argument('u'); code1($14);
1658 (13561)           end;
1659 (13561)     'pc': begin
1660 (13572)             argument('u'); code1($15)
1661 (13582)           end;
1662 (13588)     'cp': begin
1663 (13599)             argument('i'); restype:='q';
1664 (13609)           end;
1665 (13613)     'ni': begin
1666 (13624)             code3(34,0); scan; restype:='q';
1667 (13640)           end;
1668 (13644)     'ox': begin
1669 (13655)             argument('u');
1670 (13663)             restype:='i'
1671 (13663)           end;
1672 (13669)     ' @': begin
1673 (13680)             scan; factor(arsize3);
1674 (13696)             if arsize3<>0 then error(15);
1675 (13714)             if restype<>'q' then testtype('i');
1676 (13732)             restype:='f'
1677 (13732)           end;
1678 (13738)     'tr': begin
1679 (13749)             code3(34,1); scan;

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 29

1680 (13763)             restype:='b';
1681 (13765)           end;
1682 (13769)     'fa': begin
1683 (13780)             code3(34,0); scan;
1684 (13794)             restype:='b'
1685 (13794)           end;
1686 (13800)     'tc': begin
1687 (13811)             parse(' ('); scan;
1688 (13824)             arrayexp(1,'r');
1689 (13834)             testto(' )'); scan;
1690 (13847)             code1($47); restype:='i';
1691 (13857)           end;
1692 (13861)     'cv': begin
1693 (13872)             argument('i');
1694 (13880)             code1($46); arsize3:=1;
1695 (13890)             restype:='r'
1696 (13894)           end;
1697 (13900)     'pa': begin
1698 (13911)             parse(' ('); scan; express;
1699 (13928)             testtype('c');
1700 (13936)             if token=' ,' then begin
1701 (13944)               scan; express; testtype('c');
1702 (13963)               code1(53)
1703 (13965)             end;
1704 (13971)             testto(' )'); scan; restype:='p'
1705 (13984)           end
1706 (13986)     else error(1)
1707 (13995)   end {case of token}
1708 (14003) end {factor};
1709 (14003) 
1710 (14004) begin  { *** body of term *** }
1711 (14004)   factor(arsize2);
1712 (14018)   repeat
1713 (14018)     case token of
1714 (14018)       ' *': opcode:=5;
1715 (14032)       'di': opcode:=6;
1716 (14049)       'an': opcode:=15;
1717 (14066)       'sh': opcode:=18;
1718 (14083)       'sr': opcode:=19;
1719 (14100)       ' /': opcode:=$45
1720 (14115)       else opcode:=0
1721 (14124)     end {case};
1722 (14132)     if opcode>0 then begin
1723 (14139)       if (restype='r') and
1724 (14149)             (arsize2=1) then begin
1725 (14157)         scan; factor(arsize2);
1726 (14176)         if (restype<>'r') or (arsize2<>1) then
1727 (14190)           merror(14,'06');
1728 (14205)         case opcode of
1729 (14205)           5: code1($44);
1730 (14224)           $45: code1($45)
1731 (14236)           else error(17)
1732 (14247)         end{case}
1733 (14255)       end else begin
1734 (14258)         if opcode=$45 then error(9);
1735 (14276)         if arsize2<>0 then error(15);
1736 (14294)         if (restype='b') and (opcode=15)
1737 (14307)           then begin
1738 (14309)           scan; factor(arsize2);
1739 (14328)           if arsize2<>0 then error(15);

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 30

1740 (14346)           testtype('b');
1741 (14354)           code1(opcode)
1742 (14354)         end else begin
1743 (14367)           testtype('i'); scan;
1744 (14379)           factor(arsize2);
1745 (14391)           if arsize2<>0 then error(15);
1746 (14409)           testtype('i'); code1(opcode);
1747 (14427)         end
1748 (14427)       end
1749 (14427)     end;
1750 (14427)   until opcode=0;
1751 (14433) end {term};
1752 (14437) 
1753 (14438) 
1754 (14438) begin { *** body of simexp *** }
1755 (14438)   sign:=' ';
1756 (14442)   if token=' +' then begin
1757 (14454)     sign:='+'; scan
1758 (14463)   end else if token=' -' then begin
1759 (14478)     sign:='-'; scan
1760 (14487)   end;
1761 (14491)   term(arsize1);
1762 (14503)   if sign<>' ' then begin
1763 (14510)     if (restype='r')and (arsize1=1) then begin
1764 (14528)       if sign='-' then code1($4e)
1765 (14543)     end else begin
1766 (14552)       testtype('i');
1767 (14560)       if arsize1<>0 then error(15);
1768 (14578)       if sign='-' then code1(2);
1769 (14596)     end
1770 (14596)   end;
1771 (14596)   repeat
1772 (14596)     case token of
1773 (14596)       ' &': opcode:=1;
1774 (14610)       ' +': opcode:=3;
1775 (14627)       ' -': opcode:=4;
1776 (14644)       'or': opcode:=14;
1777 (14661)       'xo': opcode:=16
1778 (14676)       else opcode:=0
1779 (14685)     end {case};
1780 (14693)     if opcode>1 then begin {if 1}
1781 (14703)       if (restype='r') and (arsize1=1)
1782 (14716)         then begin {real}
1783 (14721)         scan; term(arsize1);
1784 (14737)         if (restype<>'r') or (arsize1<>1) then
1785 (14751)           error(17);
1786 (14763)         case opcode of
1787 (14763)           3:  code1($42);
1788 (14782)           4:  code1($43)
1789 (14794)           else error(17)
1790 (14805)         end {case}
1791 (14813)       end {real}
1792 (14813)       else begin {not real}
1793 (14816)         if (arsize1<>0) then error(15);
1794 (14834)         if (restype='b') and (opcode>=14)
1795 (14847)           then begin {boolean}
1796 (14852)           scan; term(arsize1);
1797 (14868)           if arsize1<>0 then error(15);
1798 (14886)           testtype('b'); code1(opcode)
1799 (14894)         end {boolean}

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 31

1800 (14904)         else begin {not boolean}
1801 (14907)           testtype('i'); scan;
1802 (14919)           term(arsize1);
1803 (14931)           if arsize1<>0 then error(15);
1804 (14949)           testtype('i'); code1(opcode);
1805 (14967)         end {not boolean}
1806 (14967)       end {not real}
1807 (14967)     end {if 1}
1808 (14967)     else if opcode=1 then begin {else 1}
1809 (14980)       sign:=restype;
1810 (14980)       scan; term(opcode);
1811 (15004)       arsize1:=arsize1+opcode+1;
1812 (15015)       testtype(sign)
1813 (15020)     end {else 1}
1814 (15030)   until opcode=0
1815 (15034) end {simexp};
1816 (15040) 
1817 (15041) 
1818 (15041) begin { *** body of mainexp *** }
1819 (15041)   roff:=0;
1820 (15045)   simexp(arsize);
1821 (15061)   if (restype='r') and (arsize=1) then
1822 (15075)     roff:=$40;
1823 (15081)   case token of
1824 (15085)     ' =': opcode:=8;
1825 (15099)     ' <': opcode:=10;
1826 (15116)     ' >': opcode:=12;
1827 (15133)     '<>': opcode:=9;
1828 (15150)     '<=': opcode:=13;
1829 (15167)     '>=': opcode:=11
1830 (15182)     else opcode:=0
1831 (15191)   end {case};
1832 (15199)   if opcode>0 then begin
1833 (15206)     if (arsize<>0) and (roff=0) then
1834 (15223)       error(15);
1835 (15235)     scan; savtype:=restype; simexp(arsize);
1836 (15259)     if ((roff=0) and (arsize<>0))
1837 (15273)       or((roff<>0) and (arsize>1)) then
1838 (15289)       error(15);
1839 (15301)     testtype(savtype); code1(opcode+roff);
1840 (15326)     arsize:=0; restype:='b'
1841 (15332)   end
1842 (15334) end {mainexp};
1843 (15338) 
1844 (15339) 
1845 (15339) {#########################################}
1846 (15339) { * assign *             ( of statement ) }
1847 (15339) {#########################################}
1848 (15339) 
1849 (15339) proc assign;
1850 (15339) 
1851 (15339) var savetype: char;
1852 (15342) 
1853 (15342)   proc assign1;
1854 (15342)   begin
1855 (15342)     testto(':='); scan; express;
1856 (15364)     if (vartype='q') and (restype='s') then begin
1857 (15379)       code1($58); restype:='q';
1858 (15392)     end;
1859 (15396)     gpval(idpnt,true,vartyp2);

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 32

1860 (15412)   end {assign1};
1861 (15412) 
1862 (15413) begin {assign}
1863 (15413)   idpnt:=findid;
1864 (15421)   if idpnt=0 then error(5);
1865 (15443)   if t0[idpnt]='pr' then begin
1866 (15455)     prcall(idpnt);scan end
1867 (15472)   else begin
1868 (15475)     getvar; savetype:=vartype;
1869 (15479)     if relad<2 then begin
1870 (15494)       assign1; testtype(vartype)
1871 (15501)     end else begin
1872 (15514)       if vartyp2='i' then error(16); {8-bit mem}
1873 (15532)       testto(':='); scan;
1874 (15545)       if relad=3 then begin
1875 (15552)         arrayexp(1,vartype); relad:=1;
1876 (15569)         code1($53);
1877 (15581)         if vartyp2='n' then begin
1878 (15588)           code1($3f);
1879 (15599)           code3($22,1);code1($12);
1880 (15617)           code3($22,t2[idpnt]+2);
1881 (15636)           code1($3);code1($3e)
1882 (15646)         end else
1883 (15652)           code4($2a,level-t1[idpnt],
1884 (15665)             2*t2[idpnt]+2);
1885 (15690)         code2($3c,1)
1886 (15694)       end else begin
1887 (15703)         arrayexp(t3[idpnt],vartype);
1888 (15721)         if vartyp2='n' then begin
1889 (15728)           code3($22,t2[idpnt]+2*t3[idpnt]);
1890 (15759)           code1($3e);
1891 (15767)         end else
1892 (15767)           code4($29,level-t1[idpnt],
1893 (15780)             2*(t2[idpnt]+t3[idpnt]));
1894 (15811)         code2($3c,t3[idpnt]);
1895 (15827)       end
1896 (15827)     end
1897 (15827)   end
1898 (15827) end {assign};
1899 (15827) 
1900 (15828) { * case1 *             ( of statement ) }
1901 (15828) 
1902 (15828) proc case1;
1903 (15828) 
1904 (15828) var i1,i2,casave: integer;
1905 (15831)     savetype: char;
1906 (15831) 
1907 (15831)   proc case2;
1908 (15831) 
1909 (15831)     proc case3;
1910 (15834)     begin
1911 (15834)       scan; code1(22); code3(34,getcon);
1912 (15865)       testtype(savetype);
1913 (15875)       code1(8); scan
1914 (15883)     end;
1915 (15887) 
1916 (15888)   begin {case2}
1917 (15888)     i1:=0; case3;
1918 (15900)     while token=' ,' do begin
1919 (15911)       push(pc); code3(38,0); i1:=succ(i1);

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 33

1920 (15935)       case3
1921 (15940)     end;
1922 (15944)     testto(' :'); savpc:=pc; code3(37,0);
1923 (15974)     for k2:=1 to i1 do fixup(pop);
1924 (16005)     push(savpc);
1925 (16029)     scan; statmnt
1926 (16033)   end {case2};
1927 (16037) 
1928 (16038) begin {case1}
1929 (16038)   scan; express; testto('of');
1930 (16057)   savetype:=restype; i2:=1; case2;
1931 (16075)   while token=' ;' do begin
1932 (16086)     casave:=pc; code3(36,0); fixup(pop);
1933 (16116)     push(casave); i2:=succ(i2); case2
1934 (16135)   end;
1935 (16139)   if token='el' then begin
1936 (16150)     casave:=pc; code3(36,0); fixup(pop);
1937 (16183)     push(casave); scan; statmnt
1938 (16197)   end;
1939 (16201)   testto('en'); for k2:=1 to i2 do fixup(pop);
1940 (16241)   code3(35,-2); scan
1941 (16266) end {case1};
1942 (16270) 
1943 (16271) { * openrw *              ( of statement ) }
1944 (16271) 
1945 (16271) proc openrw(x: integer);
1946 (16271) begin
1947 (16271)   parse(' ('); parse('id');
1948 (16294)   idpnt:=findid;
1949 (16300)   if idpnt=0 then error(5);
1950 (16322)   getvar; code1(x);
1951 (16336)   testferror;
1952 (16340)   if relad=2 then error(15);
1953 (16358)   if vartype<>'f' then merror(14,'07');
1954 (16379)   gpval(idpnt,true,vartyp2);
1955 (16395)   testto(' )'); scan
1956 (16404) end {openrw};
1957 (16408) 
1958 (16409) { * gpsec *               ( of statement )  }
1959 (16409) 
1960 (16409) proc gpsec(code);   { get/put sector }
1961 (16409) 
1962 (16409)   proc gpsec1;
1963 (16412)   begin
1964 (16412)     scan; express; testtype('i');
1965 (16433)     testto(' ,');
1966 (16442)   end;
1967 (16442) 
1968 (16443) begin {gpsec}
1969 (16443)   parse(' ('); gpsec1; gpsec1; gpsec1;
1970 (16466)   code1(code);
1971 (16476)   parse('id'); idpnt:=findid;
1972 (16491)   if idpnt=0 then error(5);
1973 (16513)   getvar; code3(34,$db); { get file error code }
1974 (16527)   if relad=2 then error(15);
1975 (16545)   code1(23); if vartype<>'i' then merror(14,'08');
1976 (16574)   gpval(idpnt,true,vartyp2);
1977 (16590)   testto(' )');
1978 (16599) end {gpsec};
1979 (16599) 

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 34

1980 (16600) 
1981 (16600) begin {body of statement }
1982 (16600)   if token=' ;' then scan;
1983 (16617)   case token of
1984 (16617)     'id': assign;
1985 (16633) 
1986 (16636)     'if': begin {if}
1987 (16644)             scan; express; testtype('b');
1988 (16660)             testto('th'); scan;  savpc:=pc;
1989 (16673)             code3(37,0); statmnt;
1990 (16695)             if token='el' then begin {else}
1991 (16706)               k2:=pc; code3(36,0);
1992 (16724)               fixup(savpc); scan; statmnt;
1993 (16742)               fixup(k2)
1994 (16742)             end else fixup(savpc)
1995 (16755)           end; {if}
1996 (16768) 
1997 (16768)     'be':  begin {begin}
1998 (16776)             repeat
1999 (16776)               scan; statmnt
2000 (16780)             until token<>(' ;');
2001 (16791)             testto('en'); scan
2002 (16804)           end; {begin}
2003 (16811) 
2004 (16811)     'rp': begin {repeat}
2005 (16819)             savpc:=pc;
2006 (16819)             repeat
2007 (16827)               scan; statmnt
2008 (16831)             until token='un';
2009 (16842)             scan; express; testtype('b');
2010 (16862)             code3(37,savpc)
2011 (16864)           end {repeat};
2012 (16874) 
2013 (16877)     're': begin {read}
2014 (16885)             parse(' ('); scan;
2015 (16898)             if token=' @' then begin
2016 (16906)               scan; express; testtype('f');
2017 (16925)               device:=true;
2018 (16927)               code1(44); testto(' ,')
2019 (16942)             end
2020 (16948)             else begin
2021 (16951)               device:=false; code1(26)
2022 (16959)             end;
2023 (16965)             repeat
2024 (16965)               begin {main loop of read}
2025 (16965)                 if token=' ,' then scan;
2026 (16980)                 testto('id'); idpnt:=findid;
2027 (16995)                 if idpnt=0 then error(5);
2028 (17017)                 getvar;
2029 (17021)                 if relad=2 then error(15);
2030 (17039)                 case vartype of
2031 (17039)                   'i':  code1(28);
2032 (17058)                   'c':  code1(27);
2033 (17076)                   'p':  begin
2034 (17086)                         code1(27); code1(27);
2035 (17102)                         code1(53)
2036 (17104)                         end
2037 (17110)                   else error(114)
2038 (17115)                 end {case};
2039 (17123)                 gpval(idpnt,true,vartyp2)

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 35

2040 (17129)               end {mainloop of read}
2041 (17139)             until token<>' ,';
2042 (17146)             testto(' )'); scan;
2043 (17163)             if device then code1(45);
2044 (17178)           end {read};
2045 (17178) 
2046 (17181)     'wr','wl':
2047 (17194)           begin {write,writeln}
2048 (17197)             if token='wl' then wln:=true
2049 (17208)             else wln:=false;
2050 (17219)             scan;
2051 (17227)             if token=' (' then begin
2052 (17235)               scan;
2053 (17242)               if token=' @' then begin
2054 (17250)                 scan; express;
2055 (17261)                 if restype='q' then restype:='f';
2056 (17273)                 testtype('f');
2057 (17285)                 device:=true; code1(44);
2058 (17299)                 testto(' ,');
2059 (17308)               end else device:=false;
2060 (17313)               repeat
2061 (17317)                 if token=' ,' then scan;
2062 (17332)                 if (token=' )') and device
2063 (17340)                        and wln then
2064 (17345)                    {empty writeln except device}
2065 (17350)                    k2:=k2 {do nothing}
2066 (17353)                 else if token='st' then begin
2067 (17372)                   {string}
2068 (17375)                   code1(50);
2069 (17383)                   for k2:=1 to value[0]-1 do
2070 (17397)                     code1(ord(ident[k2])
2071 (17411)                         and 127);
2072 (17424)                   code1(ord(ident[value[0]])
2073 (17444)                       or 128);
2074 (17457)                   scan
2075 (17457)                 end else begin
2076 (17464)                   {expression}
2077 (17464)                   express;
2078 (17468)                   case restype of
2079 (17468)                     'i':  code1(30);
2080 (17487)                     'c':  code1(29);
2081 (17505)                     'q':  code1($57);
2082 (17523)                     's':  begin
2083 (17533)                             code1($58);
2084 (17541)                             code1($57);
2085 (17549)                           end;
2086 (17549)                     'p':  begin
2087 (17559)                             code1(22);
2088 (17567)                             code1(51);
2089 (17575)                             code1(29);
2090 (17583)                             code1(52);
2091 (17591)                             code1(29);
2092 (17599)                           end
2093 (17599)                     else merror(14,'09')
2094 (17607)                   end {case}
2095 (17615)                 end {expression}
2096 (17615)               until token<>' ,';
2097 (17622)               if wln then begin {writeln(..)}
2098 (17633)                 code2(32,13); code1(29);
2099 (17651)                 code2(32,10); code1(29);

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 36

2100 (17669)               end;
2101 (17669)               if device then code1(45);
2102 (17684)               testto(' )'); scan
2103 (17693)             end {if}
2104 (17697)             else if wln then begin {writeln}
2105 (17707)               code2(32,13); code1(29);
2106 (17725)               code2(32,10); code1(29);
2107 (17743)             end
2108 (17743)           end {write, writeln};
2109 (17743) 
2110 (17746)     'cs': case1; {case statement}
2111 (17761) 
2112 (17761)     'wh': begin {while}
2113 (17769)             scan; savpc:=pc; express;
2114 (17785)             testtype('b');
2115 (17793)             k2:=pc; code3(37,0);
2116 (17811)             testto('do'); scan; statmnt;
2117 (17828)             code3(36,savpc); fixup(k2)
2118 (17840)           end {while};
2119 (17850) 
2120 (17853)     'fo': begin {for}
2121 (17861)             parse('id'); assign;
2122 (17874)             if t0[idpnt]='pr' then error(1);
2123 (17897)             savtp1:=low(t0[idpnt]);
2124 (17905)             case token of
2125 (17910)               'to': k2:=1;
2126 (17924)               'dw': k2:=0
2127 (17939)               else merror(2,'to')
2128 (17953)             end {case of token};
2129 (17961)             scan; express; testtype(savtp1);
2130 (17979)             bottom1:=pc; code1(22);
2131 (17995)             gpval(idpnt,false,vartyp2);
2132 (18011)             code1(13-k2-k2);
2133 (18029)             savpc:=pc; code3(37,0);
2134 (18047)             testto('do'); scan; statmnt;
2135 (18064)             gpval(idpnt,false,vartyp2);
2136 (18080)             code1(21-k2);
2137 (18093)             gpval(idpnt,true,vartyp2);
2138 (18109)             code3(36,bottom1); fixup(savpc);
2139 (18131)             code3(35,-2);
2140 (18142)           end {for};
2141 (18142) 
2142 (18145)     'me': begin {mem}
2143 (18153)             parse(' ['); scan; express;
2144 (18170)             testtype('i');
2145 (18178)             testto(' ]'); parse(':=');
2146 (18196)             scan; express; code1(24);
2147 (18212)             testtype('i');
2148 (18220)           end {mem};
2149 (18220) 
2150 (18223)     'ca': begin {call}
2151 (18231)             parse(' ('); scan; express;
2152 (18248)             testtype('i');
2153 (18256)             testto(' )'); code1(25); scan
2154 (18273)           end {call};
2155 (18277) 
2156 (18280)     'op': openrw(47);
2157 (18296) 
2158 (18299)     'ow': openrw(48);
2159 (18315) 

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 37

2160 (18318)     'ob': openrw(80);
2161 (18334) 
2162 (18337)     'gb': begin
2163 (18345)             parse(' ('); scan; express;
2164 (18362)             testtype('f'); testto(' ,');
2165 (18379)             scan; express; testtype('i');
2166 (18395)             testto(' ,'); scan; testto('id');
2167 (18417)             idpnt:=findid;
2168 (18423)             if idpnt=0 then error(5);
2169 (18445)             getvar;
2170 (18449)             if relad<>0 then error(15);
2171 (18467)             code1($51); testferror;
2172 (18479)             gpval(idpnt,true,vartyp2);
2173 (18495)             testto(' )'); scan
2174 (18504)           end;
2175 (18508) 
2176 (18511)     'pb': begin
2177 (18519)             parse(' ('); scan; express;
2178 (18536)             testtype('f'); testto(' ,');
2179 (18553)             scan; express; testtype('i');
2180 (18569)             testto(' ,'); scan; express;
2181 (18586)             code1($52);testferror;
2182 (18598)             testto(' )');
2183 (18607)             scan
2184 (18607)           end;
2185 (18611) 
2186 (18614)     'ru': begin
2187 (18622)             code1($41); scan;
2188 (18634)           end;
2189 (18634) 
2190 (18637)     'fi': begin
2191 (18645)             code1(46); scan
2192 (18653)           end;
2193 (18657) 
2194 (18660)     'ge': gpsec(55);
2195 (18676) 
2196 (18679)     'pu': gpsec(56);
2197 (18695) 
2198 (18698)     'ex': begin {exit}
2199 (18706)             if level>0 then code1(1) else code1(0);
2200 (18735)             scan;
2201 (18739)           end;
2202 (18739) 
2203 (18742)     'cl': begin {close}
2204 (18750)             parse(' (');
2205 (18759)             repeat
2206 (18759)               scan; express; code1(49);
2207 (18775)               testtype('f');
2208 (18783)               testferror
2209 (18783)             until token<>' ,';
2210 (18794)             testto(' )'); scan;
2211 (18811)           end {close}
2212 (18811) 
2213 (18811)     else if (token<>'en') and (token<>' ;')
2214 (18829)       and (token<>'un') then begin
2215 (18840)       error(10); scan
2216 (18851)     end
2217 (18855)   end {case of statements}
2218 (18857) end;
2219 (18857) 

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 38

2220 (18858) { * findforw *          ( of block ) }
2221 (18858) 
2222 (18858) func findforw;
2223 (18858) 
2224 (18858) var i,j,sav1: integer;
2225 (18861) 
2226 (18861)   func found(start: integer):boolean;
2227 (18861)   var ii,i9: integer;
2228 (18864)   begin {compare}
2229 (18864)     ii:= 0;
2230 (18868)     repeat
2231 (18872)       ii:=succ(ii);
2232 (18876)     until (ii >= 8) or
2233 (18888)       (ident[ii] <> idtab[start+ii]);
2234 (18911)     found:=(ii >= 8);
2235 (18922)   end {compare};
2236 (18926) 
2237 (18927) 
2238 (18927) begin {findforw}
2239 (18927)   i:=succ(forwpn);
2240 (18933)   repeat
2241 (18938)     i:=prec(i)
2242 (18938)   until (i=0) or found(8*fortab[i]);
2243 (18973)   findforw:=i;
2244 (18977)   if i>0 then
2245 (18991)     if i=forwpn then forwpn:=forwpn-1
2246 (19011)     else begin
2247 (19021)       sav1:=fortab[i];
2248 (19025)       for j:=1 to forwpn-1 do
2249 (19045)       fortab[j]:=fortab[succ(j)];
2250 (19064)       fortab[forwpn]:=sav1;
2251 (19090)       findforw:=forwpn;
2252 (19098)       forwpn:=forwpn-1
2253 (19110)     end
2254 (19112) end {findforw};
2255 (19117) 
2256 (19118) 
2257 (19118) begin { *** body of block *** }
2258 (19118)   dpnt:=3; t2[bottom]:=pc;
2259 (19130)   code3(36,0);
2260 (19148)   stackpn1:=stackpnt; forwpn:=0;
2261 (19158) 
2262 (19162)   if token='co' then begin    { * const * }
2263 (19173)     scan;
2264 (19177)     repeat
2265 (19177)       deccon; testto(' ;'); scan
2266 (19190)     until token <> 'id';
2267 (19201)   end {const};
2268 (19205) 
2269 (19205)   if token='me' then memory;  { * mem * }
2270 (19220) 
2271 (19220)   if token='va' then variable;{ * var * }
2272 (19235) 
2273 (19235)   while (token='pr')or (token='fu') do begin
2274 (19255)     parlevel:=0;
2275 (19257)     case token of
2276 (19261)     'pr': begin               { * proc * }
2277 (19273)             parse('id'); npara:=0;
2278 (19284)             putsym('p','r'); cproc:=spnt;
2279 (19298)             level:=succ(level);

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 39

2280 (19310)           end;
2281 (19315)     'fu': begin               { * func * }
2282 (19326)             parse('id'); npara:=1;
2283 (19337)             putsym('f','i');
2284 (19351)             cproc:=spnt; level:=succ(level);
2285 (19363)             putsym('f','i');
2286 (19378)             t2[spnt]:=parlevel;
2287 (19382)             parlevel:=succ(parlevel);
2288 (19394)           end
2289 (19399)     end; {case of token}
2290 (19401)     if forwpn=0 then find:=0
2291 (19411)     else find:=findforw;
2292 (19426)     if find<>0 then begin
2293 (19437)       spnt:=spnt-npara-1;
2294 (19451)       cproc:=fortab[find];
2295 (19460)       fixup(t2[cproc]);
2296 (19482)     end;
2297 (19482)     scan; spnt1:=spnt;
2298 (19486)     dpnt1:=dpnt;
2299 (19494)     if token=' (' then parameter;
2300 (19517)     if t0[cproc]='fi' then function;
2301 (19536)     testto(' ;');
2302 (19545)     for i:=1 to npara do
2303 (19551)     t2[succ(spnt-i)]:=t2[succ(spnt-i)]
2304 (19583)           -parlevel;
2305 (19588)     scan;
2306 (19615)     if token='fw' then begin
2307 (19623)       if forwpn=8 then merror(13,'ov');
2308 (19647)       forwpn:=succ(forwpn);
2309 (19651)       fortab[forwpn]:=cproc;
2310 (19660)       t2[cproc]:=pc;
2311 (19672)       code3(36,0);
2312 (19690)       scan
2313 (19690)     end else block(cproc);
2314 (19707)     level:=prec(level);
2315 (19711)     dpnt:=dpnt1; spnt:=spnt1;
2316 (19724)     case high(t0[spnt]) of
2317 (19740)       'r':  t0[spnt]:=packed('t',low(t0[spnt]));
2318 (19764)       's':  t0[spnt]:=packed('u',low(t0[spnt]))
2319 (19792)     end {case};
2320 (19800)     testto(' ;'); scan
2321 (19809)   end {procedure of function};
2322 (19813) 
2323 (19816)   testto('be');     { * begin * }
2324 (19825)   if forwpn<>0 then merror(13,'ur');
2325 (19846)   fixup(t2[bottom]);
2326 (19860)   t2[bottom]:=pc;
2327 (19864)   scan;
2328 (19876)   code3(35,2*dpnt);
2329 (19891)   repeat
2330 (19891)     statmnt
2331 (19891)   until token='en';
2332 (19902)   scan;
2333 (19910)   if level>0 then code1(1) else code1(0);
2334 (19939)   stackpnt:=stackpn1;
2335 (19939) end {block};
2336 (19947) 
2337 (19948) { * savtable *    ( global) }
2338 (19948) 
2339 (19948) proc savtable; { save lib table in @ofno }

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 40

2340 (19948) 
2341 (19948) var i,j,num: integer;
2342 (19951)     vtype1: char;
2343 (19951) 
2344 (19951) begin
2345 (19951)   writeln(@ofno,spnt,',',pc+2);
2346 (19980)   for i:=1 to spnt do begin {for every entry }
2347 (19999)     for j:=1 to 8 do begin
2348 (20016)       write(@ofno,idtab[8*i+j])
2349 (20036)     end;
2350 (20040)     writeln(@ofno,',',t0[i],',',t1[i],',',
2351 (20087)       t2[i],',',t3[i]);
2352 (20114)     vtype1:=high(t0[i]);
2353 (20122)     if ((vtype1='p') or (vtype1='f') or
2354 (20141)       (vtype1='g')) and (t3[i]<>0) then begin
2355 (20162)       num:=stack[t3[i]];
2356 (20173)       write(@ofno,num);
2357 (20192)       for j:=1 to num do
2358 (20198)         write(@ofno,',',stack[t3[i]+j]);
2359 (20237)       write(@ofno,cr,lf);
2360 (20263)     end {then};
2361 (20263)   end {for}
2362 (20263) end {savtable};
2363 (20277) 
2364 (20278) { * main program * }
2365 (20278) 
2366 (20278) begin {main}
2367 (20278)   nlflg:=false;
2368 (20283)   init;scan;
2369 (20295)   case token of
2370 (20295)     'pg': begin
2371 (20307)             libflg:=false;
2372 (20309)             asetfile(pname,scyclus,sdrive,'Q');
2373 (20335)           end;
2374 (20335)     'li': begin
2375 (20346)             libflg:=true;
2376 (20348)             asetfile(pname,scyclus,sdrive,'T');
2377 (20374)           end
2378 (20374)     else
2379 (20374)       merror(2,'pg')
2380 (20382)   end {case}
2381 (20390)   parse('id');
2382 (20399)   i:=0;
2383 (20401)   repeat
2384 (20405)     i:=succ(i);
2385 (20409)   until (i>7) or (pname[i] = ':') or
2386 (20432)       (pname[i]<>uppercase(ident[i+1]));
2387 (20461)   if i<8 then
2388 (20471)     merror(2,packed(pname[0],pname[1]));
2389 (20496)     { name differs from filename }
2390 (20496)   parse(' ;');
2391 (20505)   if ofno<>nooutput then openw(ofno);
2392 (20521)   scan;
2393 (20525)   if (token='us') and (libflg=false) then begin
2394 (20541)     repeat
2395 (20544)       getlib; scan
2396 (20548)     until token<>' ,';
2397 (20559)     testto(' ;'); scan
2398 (20572)   end;
2399 (20576)   block(0); testto(' .');

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 41

2400 (20593)   if ofno<>nooutput then begin
2401 (20600)     write(@ofno,'E');
2402 (20611)     savebyte(pc and 255);
2403 (20624)     savebyte(pc shr 8);
2404 (20637)     close(ofno);
2405 (20643)     if libflg then begin
2406 (20647)       asetfile(pname,scyclus,sdrive,'L');
2407 (20672)       openw(ofno);
2408 (20678)       savtable;
2409 (20682)       close(ofno)
2410 (20682)     end
2411 (20688)   end else
2412 (20688)     runerr:=$87; {no loader file}
2413 (20697)   writeln;
2414 (20697)   writeln;
2415 (20703)   writeln('End compile');
2416 (20727)   writeln;
2417 (20727)   writeln('Code lenght:          ',pc);
2418 (20767)   writeln('Compiler stack size:  ',stackmax);
2419 (20801)   writeln('Ident stack size:     ',spntmax);
2420 (20835)   write('Pascal errors:        ');
2421 (20858)   if numerr>0 then write(invvid);
2422 (20871)   writeln(numerr,norvid);
2423 (20885)   if prt then begin
2424 (20889)     write(prtoff);
2425 (20895)     setemucom(9);
2426 (20903)   end;
2427 (20903)   close(fno);
2428 (20909)   { check whether second pass is not required }
2429 (20909)   if (runerr=0) and libflg then runerr:=-1;
2430 (20925) end {main}.
2431 (20930) 

End compile

Code lenght:          20929
Compiler stack size:  136
Ident stack size:     215
Pascal errors:        0
