
R65 COMPILE 4.4: program COMPILE1         1/3/26 page 1


   1 (    4) {   ********************************
   2 (    4)     *                              *
   3 (    4)     *  R65 "Tiny" Pascal Compiler  *
   4 (    4)     *            Pass 1            *
   5 (    4)     *                              *
   6 (    4)     ********************************
   7 (    4) 
   8 (    4) First version 1978 by rricharz
   9 (    4) Version 3.7 (20K)  01/08/82 rricharz
  10 (    4) 
  11 (    4) Recovered 2018 by rricharz (r77@bluewin.ch)
  12 (    4) Improved 2018-2024 by rricharz
  13 (    4) Version 4 with cpnt strings and exit statement
  14 (    4) Version 4.3 with include compiler directive
  15 (    4) 
  16 (    4) Original derived from the publication by
  17 (    4) Kin-Man Chung and Herbert Yen in
  18 (    4) Byte, Volume 3, Number 9 and Number 10, 1978
  19 (    4) 
  20 (    4) Adapted for the R65 computer system and
  21 (    4) substantially enhanced by rricharz 1978-2023
  22 (    4) 
  23 (    4) This is a Pascal derivative optimized for 8-bit
  24 (    4) microprocessors (integer type is 16 bit) with
  25 (    4) additional features (mem) to interact directly
  26 (    4) with the microprocessor hardware. Only one
  27 (    4) dimensional arrays and no records or user
  28 (    4) defined types. Floating point numbers (real)
  29 (    4) and file io to floppy disks are supported.
  30 (    4) 
  31 (    4) Precompiled libraries are merged in the loader.
  32 (    4) The table of reserved words and the library
  33 (    4) tables are loaded from the same drive as
  34 (    4) the compiler.
  35 (    4) 
  36 (    4) The output of the program is a loader file for
  37 (    4) the Pascal loader (compile2).
  38 (    4) 
  39 (    4) usage:
  40 (    4)  compile1 name[.cy[,drv]] [xxx]
  41 (    4)   where x:       l,p: no hard copy print
  42 (    4)                  i,r: index bound checking
  43 (    4)                  n: no loader file
  44 (    4)   [] means not required
  45 (    4) 
  46 (    4) The compiler uses 2 fixed memory areas to store
  47 (    4) the table of reserved words and the table of
  48 (    4) idents. The top of the Pascal stack (endstk) is
  49 (    4) adjusted accordingly. The reason for this hack
  50 (    4) is speed and convenience. A normal Pascal array
  51 (    4) of chars would store the chars as 16 bit
  52 (    4) numers and would therefore require twice the
  53 (    4) space. An array of packed chars would require
  54 (    4) more coding and slow the scanner module of the
  55 (    4) compiler down.                                }
  56 (    4) 
  57 (    4) program compile1;
  58 (    4) 
  59 (    4) uses syslib, arglib;

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 2

  60 ( 1093) 
  61 ( 1093) const version='4.4';
  62 ( 1100) 
  63 ( 1100)     table     =$97ff; {user ident table -1}
  64 ( 1100)     idtab     =$95ff; {resword table -1}
  65 ( 1100)     idlength  =64;    {max. length of ident}
  66 ( 1100)     stacksize =256;   {stack size}
  67 ( 1100)     pagelenght=60;    {no of lines per page}
  68 ( 1100)     nooutput  =@0;
  69 ( 1100)     maxfi     =3;     {max number of ins fls}
  70 ( 1100) 
  71 ( 1100)     nresw=63;   {number of res. words, max 64}
  72 ( 1100)     symbsize=256;     {id table entries}
  73 ( 1100)     reswtabpos=$c600; { up to $c7ff }
  74 ( 1100)     idtabpos=$be00;   { up to $c5ff }
  75 ( 1100) 
  76 ( 1100)     yesoutput=@255;
  77 ( 1100) 
  78 ( 1100) mem endstk  =$000e: integer;
  79 ( 1100)     reswtab =reswtabpos: array[$200] of char&;
  80 ( 1100)     idtab   =idtabpos: array[$800] of char&;
  81 ( 1100) 
  82 ( 1100) var tpos,pc,level,line,offset,dpnt,spnt,fipnt,
  83 ( 1100)     npara,i,stackpnt,stackmax,spntmax,numerr,
  84 ( 1100)     lineinc,linepage                 :integer;
  85 ( 1100) 
  86 ( 1100)     scyclus,sdrive,cdrive: integer;
  87 ( 1100) 
  88 ( 1100)     pname: array[15] of char;
  89 ( 1100) 
  90 ( 1100)     value: array[1] of integer;
  91 ( 1100) 
  92 ( 1100)     ch,restype,vartype:char;
  93 ( 1100) 
  94 ( 1100)     token: packed char;
  95 ( 1100) 
  96 ( 1100)     prt,libflg,icheck,ateof,lineflg,nlflg: boolean;
  97 ( 1100) 
  98 ( 1100)     fno,ofno,savefno: file;
  99 ( 1100) 
 100 ( 1100)     filstk: array[maxfi] of file;
 101 ( 1100) 
 102 ( 1100)     ident: array[idlength] of char;
 103 ( 1100)     { Only the first 8 characters are
 104 ( 1100)       used to find and differentiate ids }
 105 ( 1100) 
 106 ( 1100)     t0: array[symbsize] of packed char;
 107 ( 1100)            {type of symbol}
 108 ( 1100) 
 109 ( 1100)         {High letter:
 110 ( 1100)          a:array, c:constant, d;const parameter
 111 ( 1100)          e:constant array parameter, f:function
 112 ( 1100)          g:array function, h;8-bit memory var
 113 ( 1100)          i:8-bit array memory variable
 114 ( 1100)          m:16-bit memory variable
 115 ( 1100)          n:16-bit array memory variable
 116 ( 1100)          p:procedure
 117 ( 1100)          q:indexed cpnt
 118 ( 1100)          r,t:function result
 119 ( 1100)          s,u:array function result

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 3

 120 ( 1100)          v:variable, w:variable parameter
 121 ( 1100)          x:variable array parameter
 122 ( 1100) 
 123 ( 1100)          Low letter:
 124 ( 1100)          i:integer, c:char, p:packed char
 125 ( 1100)          q:cpnt (pointer to chars)
 126 ( 1100)          r:real(array multiple of two)
 127 ( 1100)          s:const cpnt
 128 ( 1100)          f:file, b:boolean, u:undefined  }
 129 ( 1100) 
 130 ( 1100)     t1: array[symbsize] of integer;
 131 ( 1100)          {level}
 132 ( 1100)     t2: array[symbsize] of integer;
 133 ( 1100)          {val,dis,addr}
 134 ( 1100)     t3: array[symbsize] of integer;
 135 ( 1100)          {stack pointer,size of array}
 136 ( 1100) 
 137 ( 1100)     reswcod:array[nresw] of packed char;
 138 ( 1100) 
 139 ( 1100)     stack: array[stacksize] of integer;
 140 ( 1100) 
 141 ( 1100) 
 142 ( 1100) {       * savebyte *    (global)        }
 143 ( 1100) 
 144 ( 1100) proc savebyte(x: integer);
 145 ( 1100) 
 146 ( 1100) begin
 147 ( 1100)     if ofno<>nooutput then begin
 148 ( 1112)       write(@ofno,
 149 ( 1115)         chr(((x and 255) shr 4)+ord('0')));
 150 ( 1136)       write(@ofno,chr((x and 15)+ord('0')))
 151 ( 1151)     end
 152 ( 1154) end {savebyte};
 153 ( 1154) 
 154 ( 1155) {       * crlf *        (global)        }
 155 ( 1155) 
 156 ( 1155) proc newpage; forward;
 157 ( 1158) 
 158 ( 1158) proc crlf;
 159 ( 1158)   var i: integer;
 160 ( 1161) begin
 161 ( 1161)   writeln;
 162 ( 1163)   line:=succ(line); lineinc:=succ(lineinc);
 163 ( 1182)   linepage:=succ(linepage);
 164 ( 1191)   if ((linepage div pagelenght)
 165 ( 1202)     * pagelength)=linepage then newpage;
 166 ( 1218) end {crlf};
 167 ( 1218) 
 168 ( 1219) {       error message   (global)        }
 169 ( 1219) 
 170 ( 1219) proc merror(x: integer; code: packed char);
 171 ( 1219) 
 172 ( 1219) var i: integer;
 173 ( 1222)     answer: char;
 174 ( 1222) 
 175 ( 1222) begin
 176 ( 1222)   crlf; numerr:=succ(numerr);
 177 ( 1232)   for i:=2 to tpos do write(' ');
 178 ( 1258)   write('^'); crlf;
 179 ( 1278)   write('*** (',numerr,',',pc,')   ');

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 4

 180 ( 1301)   case x of
 181 ( 1301)     01: write('Ident');
 182 ( 1318)     02: write('Ident ',code,' expected');
 183 ( 1354)     03: write('Var declaration');
 184 ( 1380)     04: write('Const expected');
 185 ( 1405)     05: write('Ident unknown');
 186 ( 1429)     06: write('Cannot be assigned');
 187 ( 1458)     07: write('Symbol table overflow');
 188 ( 1490)     08: write('Stack overflow');
 189 ( 1515)     09: write('Expression');
 190 ( 1536)     10: write('Statement');
 191 ( 1556)     11: write('Declaration');
 192 ( 1578)     12: write('Constant');
 193 ( 1597)     13: write('Forward reference: ',code);
 194 ( 1636)     14: write('Type mismatch: ',code);
 195 ( 1671)     15: write('Array size');
 196 ( 1692)     16: write('Array (8-bit)');
 197 ( 1716)     17: write('Real');
 198 ( 1731)     18: write('File table overflow');
 199 ( 1761)     19: write('Parameter');
 200 ( 1781)     20: write('Compiler directive syntax');
 201 ( 1817)     21: write('Nested include files');
 202 ( 1848)     22: write('Unexpected eof')
 203 ( 1873)   end {case};
 204 ( 1875)   writeln;
 205 ( 1875)   write('Continue?');
 206 ( 1891)   read(@key,answer);
 207 ( 1899)   if answer<>'Y' then begin
 208 ( 1907)     crlf; write(prtoff); setemucom(9); close(fno);
 209 ( 1931)     if (ofno<>nooutput) and (ofno<>yesoutput)
 210 ( 1944)       then close(ofno);
 211 ( 1955)     writeln('Aborting compile1 on request');
 212 ( 1990)     abort
 213 ( 1990)   end
 214 ( 1994)   else crlf;
 215 ( 2001)   if (ofno<>nooutput) and (ofno<>yesoutput)
 216 ( 2014)     then close(ofno);
 217 ( 2025)   ofno:=nooutput;
 218 ( 2027) end {merror};
 219 ( 2031) 
 220 ( 2032) proc error(x: integer);
 221 ( 2032) 
 222 ( 2032) begin
 223 ( 2032)   merror(x,'##')
 224 ( 2044) end;
 225 ( 2050) 
 226 ( 2051) {       * push & pop *  (global) }
 227 ( 2051) 
 228 ( 2051) proc push(x: %integer);
 229 ( 2051) 
 230 ( 2051) begin
 231 ( 2051)   if stackpnt>=stacksize then error(8)
 232 ( 2069)   else stackpnt:=succ(stackpnt);
 233 ( 2082)   if stackpnt>stackmax then stackmax:=stackpnt;
 234 ( 2099)   stack[stackpnt]:=x;
 235 ( 2111) end {push};
 236 ( 2119) 
 237 ( 2120) func pop: integer;
 238 ( 2120) 
 239 ( 2120) begin

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 5

 240 ( 2120)   pop:=stack[stackpnt];
 241 ( 2129)   stackpnt:=prec(stackpnt)
 242 ( 2137) end {pop};
 243 ( 2146) 
 244 ( 2147) {       * newpage *     (global) }
 245 ( 2147) 
 246 ( 2147) proc newpage;
 247 ( 2147) 
 248 ( 2147) var i: integer;
 249 ( 2150) 
 250 ( 2150) begin
 251 ( 2150)   if ((linepage)<>0) and prt then
 252 ( 2159)     write(@printer,formfeed);
 253 ( 2174)   writeln; { Do not count this line}
 254 ( 2180)   if pname[0]<>'x' then begin
 255 ( 2189)     write('R65 COMPILE ');
 256 ( 2205)     write(version);
 257 ( 2210)     if libflg then write(': library ')
 258 ( 2228)     else write(': program ');
 259 ( 2242)     prtext16(output,pname);
 260 ( 2256)   end;
 261 ( 2256)   write(' ');
 262 ( 2258)   prtdate(output);
 263 ( 2266)   writeln(' page ',
 264 ( 2273)     (linepage div pagelenght)+1);
 265 ( 2290)   writeln;
 266 ( 2290) end {newpage};
 267 ( 2296) 
 268 ( 2297) {        * code1 *      (global) }
 269 ( 2297) 
 270 ( 2297) proc code1(x: %integer);  {set one byte p-code}
 271 ( 2297) begin
 272 ( 2297)   savebyte(x); pc:=succ(pc)
 273 ( 2312) end;
 274 ( 2321) 
 275 ( 2322) {       * writenum *      (global) }
 276 ( 2322) 
 277 ( 2322) proc writenum(i: integer);
 278 ( 2322) begin
 279 ( 2322)   if i<=999 then write(' ');
 280 ( 2340)   if i<=99 then write(' ');
 281 ( 2352)   if i<=9 then write(' ');
 282 ( 2364)   write(i);
 283 ( 2369) end;
 284 ( 2369) 
 285 ( 2370) {       * nextline *      (global) }
 286 ( 2370) 
 287 ( 2370) proc nextline;
 288 ( 2370) begin
 289 ( 2370)   nlflg:=true;
 290 ( 2377)   if savefno=@0 then writenum(line)
 291 ( 2391)   else begin
 292 ( 2404)     write('{I} ');
 293 ( 2409)     line:=line-1; { do not count line }
 294 ( 2420)     writenum(lineinc);
 295 ( 2430)   end;
 296 ( 2430)   write(' (');
 297 ( 2433)   if (pc+2)<9999 then write(' ');
 298 ( 2449)   writenum(pc+2); write(') ');
 299 ( 2465) end;

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 6

 300 ( 2465) 
 301 ( 2466) {       * getchr *      (global) }
 302 ( 2466) 
 303 ( 2466) proc getchr;
 304 ( 2466) begin
 305 ( 2466)   if ateof then begin
 306 ( 2475)     if savefno<>@0 then begin
 307 ( 2485)       { end of include file, close it }
 308 ( 2488)       close(fno);
 309 ( 2494)       fno:=savefno;
 310 ( 2494)       { switch back to normal input file }
 311 ( 2502)       savefno:=@0;
 312 ( 2504)       ateof:=false;
 313 ( 2510)       if ch=cr then ch:=' ';
 314 ( 2526)     end else begin
 315 ( 2533)       error(22);
 316 ( 2541)       abort
 317 ( 2541)     end
 318 ( 2545)   end else begin
 319 ( 2548)     read(@fno,ch);
 320 ( 2558)     if ch=cr then begin
 321 ( 2566)       crlf;
 322 ( 2573)       nextline;
 323 ( 2577)       ch:=' ';
 324 ( 2579)     end {if}
 325 ( 2583)     else if ch=eof then begin
 326 ( 2593)       ateof:=true;
 327 ( 2598)       { we need to suppy one more char }
 328 ( 2602)       { for end. at end of file to work properly }
 329 ( 2602)       ch:=' ';
 330 ( 2604)     end {else if}
 331 ( 2608)     else write(ch);
 332 ( 2616)   end;
 333 ( 2616) end {getchr};
 334 ( 2616) 
 335 ( 2617) {       * splitconv *   (global) }
 336 ( 2617) 
 337 ( 2617) proc splitconv(a: array[1] of %integer;
 338 ( 2617)   var b:array[1] of %integer);
 339 ( 2617) 
 340 ( 2617) begin
 341 ( 2617)   b:=a;
 342 ( 2622) end;
 343 ( 2634) 
 344 ( 2635) {       * init *        (global) }
 345 ( 2635) 
 346 ( 2635) proc init;
 347 ( 2635) 
 348 ( 2635) const char96=chr(20);
 349 ( 2638) 
 350 ( 2638) var i,j,dummy: integer;
 351 ( 2638)     dch: char;
 352 ( 2638)     pch: packed char;
 353 ( 2638)     request: array[15] of char;
 354 ( 2638)     default: boolean;
 355 ( 2638) 
 356 ( 2638) begin {init}
 357 ( 2638)   writeln('R65 PASCAL COMPILER version ', version,
 358 ( 2672)     ', Pass  1');
 359 ( 2690)   ateof:=false; savefno:=@0;

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 7

 360 ( 2698)   cdrive:=fildrv; { drive of compile program }
 361 ( 2709)   fipnt:=-1;
 362 ( 2711)   endstk:=idtabpos-144;
 363 ( 2721)   pc:=2; dpnt:=0; spnt:=0; offset:=2;
 364 ( 2745)   npara:=0; level:=0;
 365 ( 2757)   stackpnt:=0; libflg:=false;
 366 ( 2769)   stackmax:=0;spntmax:=0; numerr:=0;
 367 ( 2787)   t0[0]:='vi'; t1[0]:=0; t2[0]:=0; t3[0]:=0;
 368 ( 2820)   { prepare resword table }
 369 ( 2824)   writeln('Reading list of reserved words');
 370 ( 2861)   asetfile('RESWORDS:W      ',0,cdrive,'W');
 371 ( 2893)   openr(fno);
 372 ( 2899)   for i:=0 to nresw do begin
 373 ( 2916)     read(@fno,pch,dch);
 374 ( 2933)     reswcod[i]:=pch;
 375 ( 2938)     for j:=0 to 7 do reswtab[8*i+j]:=' ';
 376 ( 2977)     j:=0;
 377 ( 3000)     while (j<8) and (dch<>cr) do begin
 378 ( 3022)       read(@fno,dch);
 379 ( 3032)       if (dch<>cr) then
 380 ( 3040)         reswtab[8*i+j]:=dch;
 381 ( 3055)       j:=succ(j)
 382 ( 3066)     end;
 383 ( 3075)     while (dch<>cr) and (dch<>eof) do
 384 ( 3092)       read(@fno,dch)
 385 ( 3101)   end;
 386 ( 3110)   close(fno);
 387 ( 3130) 
 388 ( 3130)   writeln;
 389 ( 3130) 
 390 ( 3136)   sdrive:=1; {default drive for source }
 391 ( 3142)   scyclus:=0;
 392 ( 3144)   agetstring(pname,default,scyclus,sdrive);
 393 ( 3188) 
 394 ( 3188)   agetstring(request,default,dummy,dummy);
 395 ( 3228)   icheck:=false;
 396 ( 3230)   prt:=true; ofno:=yesoutput; lineflg:=false;
 397 ( 3248)   if not default then begin
 398 ( 3257)     if request[0]<>'/' then argerror(103);
 399 ( 3280)     for i:=1 to 8 do
 400 ( 3288)       case request[i] of
 401 ( 3301)         'P': prt:=false;
 402 ( 3314)         'L': lineflg:=true;
 403 ( 3330)         'I','R': icheck:=true;
 404 ( 3353)         'N': ofno:=nooutput;
 405 ( 3369)         ' ': begin end
 406 ( 3383)         else argerror(104)
 407 ( 3388)       end; {case}
 408 ( 3410)   end;
 409 ( 3410) 
 410 ( 3410)   asetfile(pname,scyclus,sdrive,'P');
 411 ( 3432)   openr(fno);
 412 ( 3438)   scyclus:=filcyc; { may have changed }
 413 ( 3446) 
 414 ( 3446)   {save cyclus and drive for compile2}
 415 ( 3446)   arglist[8]:=scyclus;
 416 ( 3448)   arglist[9]:=sdrive;
 417 ( 3462)   numarg:=1;
 418 ( 3476) 
 419 ( 3480)   if prt then begin

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 8

 420 ( 3484)     write(prton);
 421 ( 3490)     setemucom(8);
 422 ( 3498)   end
 423 ( 3498) 
 424 ( 3498)   line:=0; lineinc:=0; linepage:=0;
 425 ( 3512)   newpage; crlf; line:=1; linepage:=1;
 426 ( 3532)   write('   1 (    4) '); getchr
 427 ( 3550) end {init};
 428 ( 3554) 
 429 ( 3555) 
 430 ( 3555) { ############################# }
 431 ( 3555) {       *scan*              (global)    }
 432 ( 3555) { ############################# }
 433 ( 3555) { scan input and make tokens }
 434 ( 3555) 
 435 ( 3555) proc scan;
 436 ( 3555) 
 437 ( 3555) var count,ll,hh,i,i1,co: integer;
 438 ( 3558)     name: array[7] of char;
 439 ( 3558) 
 440 ( 3558) {       * compresw*     (of scan)       }
 441 ( 3558) 
 442 ( 3558) func compresw(index: integer);
 443 ( 3558) 
 444 ( 3558) var addr,ci,i: integer;
 445 ( 3561) 
 446 ( 3561) begin
 447 ( 3561)   addr:=8*index; i:=0;
 448 ( 3576)   repeat
 449 ( 3580)     ci:=ord(ident[i+1])-ord(reswtab[addr+i]);
 450 ( 3605)     i:=succ(i)
 451 ( 3610)   until (ci<>0) or (i>=8);
 452 ( 3633)   compresw:=ci
 453 ( 3637) end {compresw};
 454 ( 3645) 
 455 ( 3646) {       * clear *       (of scan)              }
 456 ( 3646) 
 457 ( 3646) proc clear; {clears 8 chars of identifier}
 458 ( 3646) 
 459 ( 3646) var i: integer;
 460 ( 3649) 
 461 ( 3649) begin
 462 ( 3649)   for i:=1 to 8 do ident[i]:=' '
 463 ( 3672) end;
 464 ( 3692) 
 465 ( 3693) {       * pack *        (of scan)              }
 466 ( 3693) 
 467 ( 3693) proc pack;  {packs token and ch to token }
 468 ( 3693) 
 469 ( 3693) begin
 470 ( 3693)   token:=packed(low(token),ch); getchr
 471 ( 3712) end;
 472 ( 3716) 
 473 ( 3717) {       * setval *      (of scan)              }
 474 ( 3717) 
 475 ( 3717) proc setval;
 476 ( 3717) 
 477 ( 3717) var r: real;
 478 ( 3720)     n,n1: integer;
 479 ( 3720)     ems: boolean;

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 9

 480 ( 3720) 
 481 ( 3720)   func times10(r:real):real;
 482 ( 3720)   { slightly more accurate than 10.0*r }
 483 ( 3720)   var r2,r4:real;
 484 ( 3723)   begin
 485 ( 3723)     r2:=r+r;
 486 ( 3731)     r4:=r2+r2;
 487 ( 3750)     times10:=r2+r4+r4;
 488 ( 3776)   end;
 489 ( 3789) 
 490 ( 3790) begin
 491 ( 3790)   r:=0.0;
 492 ( 3798)   repeat
 493 ( 3804)     r:=times10(r)+conv(ord(ch)-ord('0'));
 494 ( 3825)     getchr;
 495 ( 3837)   until (ch<'0') or (ch>'9');
 496 ( 3851)   if ch<>'.' then begin {numeric integer}
 497 ( 3865)     token:='nu';
 498 ( 3868)     value[0]:=trunc(r+0.5);
 499 ( 3887)   end
 500 ( 3892)   else begin {numeric real}
 501 ( 3895)     n:=0; getchr;
 502 ( 3905)     while (ch<='9') and (ch>='0') do begin
 503 ( 3923)       r:=times10(r)+conv(ord(ch)-ord('0'));
 504 ( 3944)       n:=prec(n); getchr
 505 ( 3961)     end;
 506 ( 3965)     if ch='e' then begin
 507 ( 3975)       ems:=false; getchr;
 508 ( 3988)       case ch of
 509 ( 3988)         '+': getchr;
 510 ( 4003)         '-': begin ems:=true; getchr end
 511 ( 4023)       end;
 512 ( 4025)       if (ch>'9') or (ch<'0') then error(17)
 513 ( 4045)       else begin
 514 ( 4054)         n1:=ord(ch)-ord('0');
 515 ( 4060)         getchr;
 516 ( 4069)         if (ch<='9') and (ch>='0') then begin
 517 ( 4084)           n1:=10*n1+ord(ch)-ord('0');
 518 ( 4101)           getchr
 519 ( 4106)         end;
 520 ( 4110)         if ems then n:=n-n1 else n:=n+n1
 521 ( 4137)       end
 522 ( 4137)     end;
 523 ( 4146)     while n>0 do begin
 524 ( 4156)       n:=prec(n);
 525 ( 4160)       r:=times10(r);
 526 ( 4179)     end;
 527 ( 4185)     while n<0 do begin
 528 ( 4198)       n:=succ(n); r:=0.1*r;
 529 ( 4213)     end;
 530 ( 4226)     splitconv(r,value);
 531 ( 4253)     token:='ru'
 532 ( 4253)   end
 533 ( 4256) end {setval};
 534 ( 4260) 
 535 ( 4261) {       * directive *   (of scan               }
 536 ( 4261) 
 537 ( 4261) proc directive;
 538 ( 4261) var i,icyclus:integer;
 539 ( 4264)     name: array[15] of char;

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 10

 540 ( 4264) begin
 541 ( 4264)   getchr;
 542 ( 4270)   case ch of
 543 ( 4270)     'I': begin
 544 ( 4281)            if savefno<>@0 then error(21);
 545 ( 4299)            getchr; if ch<>' ' then error(20);
 546 ( 4321)            i:=0; getchr;
 547 ( 4331)            while (ch<>'}') and (i<16) do begin
 548 ( 4349)              name[i]:=ch; i:=i+1; getchr;
 549 ( 4376)            end;
 550 ( 4376)            while (i<16) do begin
 551 ( 4389)              name[i]:=' '; i:=i+1;
 552 ( 4405)            end;
 553 ( 4410)            icyclus:=0;
 554 ( 4415)            asetfile(name,icyclus,sdrive,'P');
 555 ( 4441)            savefno:=fno;
 556 ( 4441)            openr(fno);
 557 ( 4455)            lineinc:=0;
 558 ( 4457)            crlf;
 559 ( 4465)            nextline;
 560 ( 4469)            getchr; scan;
 561 ( 4477)          end
 562 ( 4477)     else error(20)
 563 ( 4482)   end {case}
 564 ( 4490) end;
 565 ( 4490) 
 566 ( 4491) {       * setid *       (of scan)              }
 567 ( 4491) 
 568 ( 4491) proc setid; {sets one char to ident}
 569 ( 4491) 
 570 ( 4491) begin
 571 ( 4491)   if count<=idlength then begin
 572 ( 4503)     ident[count]:=ch; count:=succ(count)
 573 ( 4518)   end;
 574 ( 4527)   getchr;
 575 ( 4531) end {setid};
 576 ( 4531) 
 577 ( 4532) begin { ***** body of scan ***** }
 578 ( 4532)   count:=1; while ch=' ' do getchr;
 579 ( 4554)   tpos:=curpos;
 580 ( 4560) 
 581 ( 4564)   { delayed because of token lookahead }
 582 ( 4564)   if nlflg then begin
 583 ( 4568)     if lineflg and (pc>2) then begin
 584 ( 4583)       code1($59);
 585 ( 4594)       code1((line) and 255);
 586 ( 4607)       code1((line) shr 8);
 587 ( 4620)     end;
 588 ( 4620)     nlflg:=false;
 589 ( 4622)   end;
 590 ( 4626) 
 591 ( 4626)   if not (((ch>='a') and (ch<='z')) or
 592 ( 4641)          ((ch>='A') and (ch<='Z')) or
 593 ( 4656)          (ch='_')) then begin {main if}
 594 ( 4669) 
 595 ( 4669)     if (ch<'0') or (ch>'9') then begin {symb}
 596 ( 4687)       token:=packed(' ',ch); getchr;
 597 ( 4702)       case low(token) of
 598 ( 4706)         '<': if (ch='=') or (ch='>') then pack;
 599 ( 4736)         '>',':': if (ch='=') then pack;

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 11

 600 ( 4767)         '{': begin
 601 ( 4777)                if ch='$' then directive
 602 ( 4784)                else begin
 603 ( 4794)                  if ch<>'}' then
 604 ( 4800)                  repeat getchr until ch='}';
 605 ( 4814)                  getchr; scan
 606 ( 4822)                end
 607 ( 4826)              end;
 608 ( 4826)         '$': begin {hex constant}
 609 ( 4836)                token:='nu'; value[0]:=0;
 610 ( 4847)                while ((ch>='0')and(ch<='9'))
 611 ( 4865)                      or((ch>='a')and(ch<='f'))
 612 ( 4880)                      do begin
 613 ( 4885)                  if ch>'9' then
 614 ( 4891)                    value[0]:=(value[0] shl 4)
 615 ( 4905)                      +ord(ch)-ord('a')+10
 616 ( 4914)                  else
 617 ( 4916)                    value[0]:=(value[0] shl 4)
 618 ( 4934)                      +ord(ch)-ord('0');
 619 ( 4942)                  getchr
 620 ( 4947)                end {do}
 621 ( 4951)              end; {hex constant}
 622 ( 4957)         chr(39): begin {string}
 623 ( 4964)                token:='st';
 624 ( 4967)                repeat setid until ch=chr(39);
 625 ( 4981)                value[0]:=prec(count); getchr
 626 ( 4997)               end
 627 ( 5001)       end {case of token}
 628 ( 5003)     end {special symbols}
 629 ( 5003)     else setval {numeric value}
 630 ( 5010)   end {main if}
 631 ( 5010)   else begin {ident}
 632 ( 5013)         clear;
 633 ( 5017)     repeat
 634 ( 5017)       setid
 635 ( 5017)     until (ch<'0') or (ch>'z') or
 636 ( 5035)       ((ch>'9') and (ch<'A')) or
 637 ( 5051)       ((ch>'Z') and (ch<'a'));
 638 ( 5067)     ll:=0; hh:=nresw; {look up in resword table}
 639 ( 5083)     repeat
 640 ( 5083)       i:=(ll+hh) shr 1; co:=compresw(i);
 641 ( 5111)       if (co<0) then hh:=prec(i)
 642 ( 5125)       else ll:=succ(i);
 643 ( 5141)       until (co=0) or (ll>hh);
 644 ( 5162)     if (co=0) then
 645 ( 5173)       token:=reswcod[i] {reserved word found}
 646 ( 5180)     else token:='id' {ident}
 647 ( 5194)   end {odent}
 648 ( 5198) end {scan};
 649 ( 5198) 
 650 ( 5199) { * testto/parse * }
 651 ( 5199) 
 652 ( 5199) { parce source for specific token; else error }
 653 ( 5199) 
 654 ( 5199) proc testto(x: packed char); { current token }
 655 ( 5199) begin
 656 ( 5199)   if token<>x then merror(2,x)
 657 ( 5218) end;
 658 ( 5228) 
 659 ( 5229) proc parse(x: packed char); { next token }

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 12

 660 ( 5229) begin
 661 ( 5229)   scan; testto(x);
 662 ( 5248) end;
 663 ( 5248) 
 664 ( 5249) { * getlib * }
 665 ( 5249) 
 666 ( 5249) proc getlib;  { read library data }
 667 ( 5249) 
 668 ( 5249) var i,j,nent,addr,size,num,x,base: integer;
 669 ( 5252)     libfil: file;
 670 ( 5252)     ch,ltyp2,dummy: char;
 671 ( 5252)     name: array[7] of char;
 672 ( 5252) 
 673 ( 5252) begin
 674 ( 5252)   scan; if token=' ,' then scan;
 675 ( 5273)   testto('id');
 676 ( 5282)   base:=pc-2;
 677 ( 5288)   if (ofno<>nooutput) then write(@ofno,'L');
 678 ( 5311)   for i:=0 to 7 do begin
 679 ( 5328)     name[i]:=ident[succ(i)];
 680 ( 5337)     if ofno<>nooutput then
 681 ( 5351)       write(@ofno,ident[succ(i)])
 682 ( 5365)   end;
 683 ( 5371)   write(prtoff);
 684 ( 5388)   asetfile(name&'        ',0,cdrive,'L');
 685 ( 5418)   openr(libfil);  { get table file }
 686 ( 5424)   read(@libfil,nent,size);
 687 ( 5439)   {including cr,lf}
 688 ( 5440)   for i:=succ(spnt) to spnt+nent do begin
 689 ( 5467)     if spnt>symbsize then error(7);
 690 ( 5486)     spnt:=succ(spnt); addr:=8*i+1;
 691 ( 5504)     for j:=0 to 7 do begin
 692 ( 5526)       read(@libfil,ch);
 693 ( 5536)       idtab[addr+j]:=ch
 694 ( 5546)     end;
 695 ( 5557)     read(@libfil,ch);
 696 ( 5581)     read(@libfil,t0[i],dummy,t1[i],t2[i],t3[i]);
 697 ( 5630)     t1[i]:=t1[i]+level;
 698 ( 5643)     ltyp2:=high(t0[i]);
 699 ( 5660)     if (ltyp2='p')or(ltyp2='f')
 700 ( 5678)       or(ltyp2='g') then begin
 701 ( 5688)       t2[i]:=t2[i]+base;
 702 ( 5703)       if t3[i]<>0 then begin {stack data}
 703 ( 5726)         read(@libfil,num);
 704 ( 5736)         push(num); t3[i]:=stackpnt;
 705 ( 5751)         for j:=1 to num do begin
 706 ( 5778)           read(@libfil,x);
 707 ( 5788)           push(x);
 708 ( 5799)         end {for j};
 709 ( 5799)       end {stack data}
 710 ( 5813)     end {if ltyp2}
 711 ( 5813)   end {for i}
 712 ( 5813)   level:=succ(level); pc:=pc+size; offset:=pc;
 713 ( 5849)   close(libfil);
 714 ( 5863)   if spnt>spntmax then spntmax:=spnt;
 715 ( 5875)   if stackpnt>stackmax then stackmax:=stackpnt;
 716 ( 5895)   if prt then write(prton);
 717 ( 5913) end {getlib};
 718 ( 5913) 
 719 ( 5914) 

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 13

 720 ( 5914) { #################################### }
 721 ( 5914) {       * block * (global): handle one block }
 722 ( 5914) { #################################### }
 723 ( 5914) 
 724 ( 5914) 
 725 ( 5914) proc block(bottom: integer);
 726 ( 5914) 
 727 ( 5914) var l,f9,i,n,stackpn1,forwpn,find,cproc,
 728 ( 5917)     spnt1,dpnt1,parlevel: integer;
 729 ( 5917)     fortab: array[8] of integer;
 730 ( 5917) 
 731 ( 5917) { * find ident *    (of block) }
 732 ( 5917) { this is a fast version for compiler speed }
 733 ( 5917) 
 734 ( 5917) func findid; {search in table for id }
 735 ( 5917) 
 736 ( 5917) var k,i: integer;
 737 ( 5920)     id1: char;
 738 ( 5920) 
 739 ( 5920) begin
 740 ( 5920) 
 741 ( 5920)   i:=1; k:=8*spnt+9; id1:=ident[1];
 742 ( 5944) 
 743 ( 5952)   repeat
 744 ( 5952)     k:=k-8;
 745 ( 5958)     while (idtab[k]<>id1) and (k>0) do k:=k-8;
 746 ( 5994)     if k>0 then begin
 747 ( 6009)        i:=1;
 748 ( 6014)        repeat i:=succ(i)
 749 ( 6018)          until (i>8) or
 750 ( 6034)              (idtab[k+i-1]<>ident[i]);
 751 ( 6060)     end;
 752 ( 6064)     until (i>8) or (k<=0);
 753 ( 6078)   if k<=0 then begin
 754 ( 6089)     findid:=0;
 755 ( 6094)   end
 756 ( 6098)   else
 757 ( 6098)     findid:=(k-1) shr 3;
 758 ( 6110) end;
 759 ( 6115) 
 760 ( 6116) { * code2 *    (of block) }
 761 ( 6116) 
 762 ( 6116) proc code2(x,y: integer);
 763 ( 6116) begin
 764 ( 6116)   code1(x); code1(y);
 765 ( 6141) end;
 766 ( 6141) 
 767 ( 6142) { * code3 *    (of block) }
 768 ( 6142) 
 769 ( 6142) proc code3(x: integer; y1: %integer);
 770 ( 6142) 
 771 ( 6142) var y: integer;
 772 ( 6145) 
 773 ( 6145) begin {code3}
 774 ( 6145)   y:=y1;
 775 ( 6147)   if (x=34) and (y>=0) and (y<256) then
 776 ( 6178)     code2(32,y)
 777 ( 6184)   else begin
 778 ( 6197)     if (x=35) and (y>-128) and (y<=127) then
 779 ( 6220)       begin

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 14

 780 ( 6221)         if (y<0) then y:=y+256;
 781 ( 6241)         code2(33,y);
 782 ( 6258)       end
 783 ( 6258)     else begin
 784 ( 6261)       if (x>=36) and (x<=38) then y:=y-pc-1;
 785 ( 6290)       code1(x); code1(y and 255);
 786 ( 6318)       code1(y shr 8);
 787 ( 6331)     end
 788 ( 6331)   end
 789 ( 6331) end {code3};
 790 ( 6331) 
 791 ( 6332) { * testtype *      (of block) }
 792 ( 6332) 
 793 ( 6332) proc testtype(ttype: char);
 794 ( 6332) 
 795 ( 6332) begin
 796 ( 6332)   if restype<>ttype then
 797 ( 6341)     if (restype<>'u') and (ttype<>'u') then
 798 ( 6363)       merror(14,packed(ttype,restype));
 799 ( 6384) end;
 800 ( 6384) 
 801 ( 6385) { * putsym *   (of block) }
 802 ( 6385) 
 803 ( 6385) proc putsym(ltyp1,ltyp2: char);
 804 ( 6385) 
 805 ( 6385) var i,addr: integer;
 806 ( 6388) begin
 807 ( 6388)   if spnt>symbsize then error(7)
 808 ( 6403)   else spnt:=succ(spnt);
 809 ( 6416)   if spnt>spntmax then spntmax:=spnt;
 810 ( 6433)   t0[spnt]:=packed(ltyp1,ltyp2);
 811 ( 6454)   t3[spnt]:=0;
 812 ( 6464)   addr:=8*spnt;
 813 ( 6470)   for i:=1 to 8 do idtab[addr+i]:=ident[i];
 814 ( 6509)   if ltyp1='v' then begin
 815 ( 6541)     t2[spnt]:=dpnt; dpnt:=succ(dpnt);
 816 ( 6560)   end;
 817 ( 6565)   t1[spnt]:=level
 818 ( 6569) end {putsym};
 819 ( 6577) 
 820 ( 6578) { * checkindex *  (of block) }
 821 ( 6578) 
 822 ( 6578) proc checkindex(lowlim,highlim: integer);
 823 ( 6578) begin
 824 ( 6578)   if icheck then begin
 825 ( 6587)     code3($40,lowlim-1);
 826 ( 6605)     code2(highlim and 255, highlim shr 8)
 827 ( 6618)   end
 828 ( 6625) end;
 829 ( 6625) 
 830 ( 6626) { * getcon *      (of block) }
 831 ( 6626) 
 832 ( 6626) func getcon;
 833 ( 6626) 
 834 ( 6626) var idpnt,val,ii: integer;
 835 ( 6629)     rval: real;
 836 ( 6629)     sign: char;
 837 ( 6629) begin
 838 ( 6629)   restype:='i';
 839 ( 6633)   if token=' -' then begin

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 15

 840 ( 6645)     sign:='-'; scan
 841 ( 6654)   end else begin
 842 ( 6661)     sign:='+'; if token=' +' then scan
 843 ( 6675)   end;
 844 ( 6682)   case token of
 845 ( 6682)     'nu': val:=value[0];
 846 ( 6696)     'ru': begin val:=value[0];
 847 ( 6717)             restype:='r' end;
 848 ( 6731)     'st': if value[0]=1 then begin
 849 ( 6751)             restype:='c';
 850 ( 6756)             val:=ord(ident[1])
 851 ( 6762)           end else if value[0]=2 then begin
 852 ( 6782)             val:=(ord(ident[1]) shl 8) +
 853 ( 6794)               ord(ident[2]);
 854 ( 6800)             restype:='p';
 855 ( 6807)           end else if value[0]>2 then begin
 856 ( 6823)             val:=pc;
 857 ( 6826)             for ii:=1 to value[0] do
 858 ( 6842)                         code1(ord(ident[ii]));
 859 ( 6869)             code1(0); value[0]:=0; restype:='s';
 860 ( 6901)           end else error(15);
 861 ( 6916)     'cr': begin parse(' ('); scan; val:=getcon;
 862 ( 6946)             if (val>127) or (val<0) then
 863 ( 6964)               error(12);
 864 ( 6976)             testtype('i');
 865 ( 6984)             restype:='c'; parse(' )');
 866 ( 6999)           end;
 867 ( 6999)     'tr': begin val:=1; restype:='b' end;
 868 ( 7022)     'fa': begin val:=0; restype:='b' end;
 869 ( 7045)     'cp': begin
 870 ( 7056)             scan; val:=getcon;
 871 ( 7066)             testtype('i'); restype:='q';
 872 ( 7080)           end;
 873 ( 7084)     ' @': begin scan; val:=getcon;
 874 ( 7105)             if restype<>'q' then testtype('i');
 875 ( 7127)             restype:='f'
 876 ( 7127)           end
 877 ( 7129)     else begin
 878 ( 7136)       testto('id'); idpnt:=findid;
 879 ( 7151)       if (idpnt>0) and (high(t0[idpnt])='c')
 880 ( 7173)       then begin
 881 ( 7175)         val:=t2[idpnt];
 882 ( 7182)         restype:=low(t0[idpnt]);
 883 ( 7198)         if restype='r' then
 884 ( 7209)           value[1]:=t3[idpnt];
 885 ( 7219)       end
 886 ( 7227)       else begin error(4); val:=0;
 887 ( 7240)         restype:='i'
 888 ( 7244)       end
 889 ( 7246)     end
 890 ( 7250)   end {case};
 891 ( 7252)   if sign='-' then
 892 ( 7258)     case restype of
 893 ( 7262)       'i': getcon:=-val;
 894 ( 7273)       'r': begin value[0]:=val;
 895 ( 7294)              splitconv(value,rval);
 896 ( 7326)              splitconv(-rval,value);
 897 ( 7351)              getcon:=value[0]
 898 ( 7353)            end
 899 ( 7353)       else error(12)

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 16

 900 ( 7366)     end {case}
 901 ( 7374)   else getcon:=val;
 902 ( 7377) end {getcon};
 903 ( 7385) 
 904 ( 7386) { * deccon *         ( of block ) }
 905 ( 7386) 
 906 ( 7386) proc deccon;    { declare constant }
 907 ( 7386) begin
 908 ( 7386)   if token=' ;' then scan;
 909 ( 7406)   testto('id');
 910 ( 7415)   putsym('c','i');
 911 ( 7425)   parse(' ='); scan;
 912 ( 7438)   t2[spnt]:=getcon;
 913 ( 7448)   if (restype='r') then t3[spnt]:=value[1];
 914 ( 7468)   if restype<>'i' then
 915 ( 7482)     t0[spnt]:=packed('c',restype);
 916 ( 7497)   scan
 917 ( 7501) end {deccon};
 918 ( 7505) 
 919 ( 7506) { * decvar *          ( of block ) }
 920 ( 7506) 
 921 ( 7506) proc decvar(typ1,typ2: char);
 922 ( 7506) begin
 923 ( 7506)   if token=' ,' then scan;
 924 ( 7526)   testto('id');
 925 ( 7535)   putsym(typ1,typ2);
 926 ( 7549)   scan;
 927 ( 7553) end {decvar};
 928 ( 7553) 
 929 ( 7554) { * gettype *         ( of block ) }
 930 ( 7554) 
 931 ( 7554) proc gettype(var typ2: char;
 932 ( 7554)   var aflag,uflag: boolean; var n: integer);
 933 ( 7554) 
 934 ( 7554) begin
 935 ( 7554)   aflag:=false; n:=0; uflag:=false;
 936 ( 7573)   scan;
 937 ( 7581)   if token='ar' then begin
 938 ( 7589)     parse(' ['); scan;
 939 ( 7605)     n:=getcon; testtype('i');
 940 ( 7623)     if (n<1) then begin error(15); n:=1 end;
 941 ( 7647)     parse(' ]'); parse('of'); scan;
 942 ( 7669)     aflag:=true
 943 ( 7669)   end;
 944 ( 7675)   if token=' %' then begin
 945 ( 7683)     scan; uflag:=true
 946 ( 7690)   end;
 947 ( 7696)   case token of
 948 ( 7696)     'in': typ2:='i';
 949 ( 7710)     'ch': typ2:='c';
 950 ( 7727)     'pa': begin parse ('ch'); typ2:='p' end;
 951 ( 7757)     'bo': typ2:='b';
 952 ( 7770)     'rl': begin typ2:='r'; aflag:=true;
 953 ( 7793)             n:=prec(2*succ(n)) end;
 954 ( 7810)     'cp': typ2:='q';
 955 ( 7823)     'fl': typ2:='f'
 956 ( 7838)     else begin error(11); typ2:='i';end
 957 ( 7861)   end {case}
 958 ( 7863) end {gettype};
 959 ( 7863) 

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 17

 960 ( 7864) { * variable *        ( of block) }
 961 ( 7864) 
 962 ( 7864) proc variable;  { variable declarations }
 963 ( 7864) 
 964 ( 7864) var typ1,typ2: char;
 965 ( 7867)     i,l: integer;
 966 ( 7867)     aflag,uflag: boolean;
 967 ( 7867) 
 968 ( 7867) begin
 969 ( 7867)   scan;
 970 ( 7873)   repeat {main loop}
 971 ( 7873)     l:=0;
 972 ( 7875)     repeat decvar('v','i'); l:=succ(l);
 973 ( 7893)     until token<> ' ,';
 974 ( 7905)     testto(' :');
 975 ( 7918)     gettype(typ2,aflag,uflag,n);
 976 ( 7954)     if uflag then error(11);
 977 ( 7969)     if aflag then typ1:='a' else typ1:='v';
 978 ( 7987)     if typ1='a' then begin {array}
 979 ( 8001)        dpnt:=dpnt-l; {variable has been assumed}
 980 ( 8014)        for i:=succ(spnt-l) to spnt do begin
 981 ( 8041)          t2[i]:=dpnt; t3[i]:=n;
 982 ( 8057)          dpnt:=succ(dpnt+n);
 983 ( 8074)       end
 984 ( 8079)     end {array};
 985 ( 8093)     for i:=succ(spnt-l) to spnt do
 986 ( 8107)       t0[i]:=packed(typ1,typ2);
 987 ( 8133)     parse(' ;');scan
 988 ( 8160)   until token<>'id' {end main loop}
 989 ( 8171) end {variable};
 990 ( 8175) 
 991 ( 8176) { * fixup *           ( of block ) }
 992 ( 8176) 
 993 ( 8176) proc fixup(x: integer);
 994 ( 8176) begin
 995 ( 8176)   if ofno<>nooutput then begin
 996 ( 8188)     write(@ofno,'F');
 997 ( 8199)     savebyte(succ(x-offset) and 255);
 998 ( 8218)     savebyte(succ(x-offset) shr 8);
 999 ( 8237)     savebyte((pc-x-1) and 255);
1000 ( 8258)     savebyte((pc-x-1) shr 8);
1001 ( 8279)   end;
1002 ( 8279) end;
1003 ( 8279) 
1004 ( 8280) { * function *        ( of block ) }
1005 ( 8280) 
1006 ( 8280) proc function;
1007 ( 8280) 
1008 ( 8280) var n: integer;
1009 ( 8283)     typ1,typ2: char;
1010 ( 8283)     aflag,uflag: boolean;
1011 ( 8283) begin
1012 ( 8283)   if token<>' :' then begin
1013 ( 8293)     aflag:=false; uflag:=false; typ2:='i' end
1014 ( 8310)   else begin
1015 ( 8317)     gettype(typ2,aflag,uflag,n);
1016 ( 8353)     scan
1017 ( 8353)   end;
1018 ( 8357)   if aflag then begin
1019 ( 8361)     typ1:='s'; t3[succ(cproc)]:=n;

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 18

1020 ( 8375)     t2[succ(cproc)]:=t2[succ(cproc)]-n
1021 ( 8397)   end
1022 ( 8397)   else typ1:='r';
1023 ( 8411)   t0[succ(cproc)]:=packed(typ1,typ2);
1024 ( 8429)   if uflag then typ2:='u';
1025 ( 8442)   if aflag then typ1:='g'
1026 ( 8453)   else typ1:='f';
1027 ( 8464)   t0[cproc]:=packed(typ1,typ2);
1028 ( 8481) end {function};
1029 ( 8485) 
1030 ( 8486) { * parameter *       ( of block ) }
1031 ( 8486) 
1032 ( 8486) proc parameter;
1033 ( 8486) 
1034 ( 8486) var counter1,counter2,i,n,bs: integer;
1035 ( 8489)     aflag,uflag: boolean;
1036 ( 8489)     vtype1,vtype2: char;
1037 ( 8489)     vtype: packed char;
1038 ( 8489) 
1039 ( 8489) begin
1040 ( 8489)   push(0); { dummy size, fixed later }
1041 ( 8499)   if find=0 then t3[spnt-npara]:=stackpnt
1042 ( 8518)   else bs:=stackpnt;
1043 ( 8529)   counter1:=0
1044 ( 8537)   repeat {main loop}
1045 ( 8543)     counter2:=0;
1046 ( 8545)     vtype1:='d'; vtype2:='i';
1047 ( 8557)     scan;
1048 ( 8565)     if token='co' then scan
1049 ( 8573)     else if token='va' then begin
1050 ( 8591)       scan; vtype1:='w' end; {variable param}
1051 ( 8604)     end;
1052 ( 8604)     repeat {inner loop}
1053 ( 8604)       decvar(vtype1,vtype2);
1054 ( 8618)       t2[spnt]:=parlevel;
1055 ( 8622)       parlevel:=succ(parlevel);
1056 ( 8634)       npara:=succ(npara);
1057 ( 8643)       counter2:=succ(counter2);
1058 ( 8652)       until token<>' ,';
1059 ( 8664)     uflag:=false;aflag:=false; n:=0;
1060 ( 8682)     if token<>' :' then
1061 ( 8693)       vtype2:='i' {assume integer }
1062 ( 8699)     else begin
1063 ( 8706)       gettype(vtype2,aflag,uflag,n);
1064 ( 8742)       if n>63 then error(15);
1065 ( 8760)       scan
1066 ( 8760)     end;
1067 ( 8764)     if aflag then begin
1068 ( 8768)       vtype1:=succ(vtype1);
1069 ( 8775)       parlevel:=parlevel-counter2;
1070 ( 8784)     end;
1071 ( 8793)     vtype:=packed(vtype1,vtype2);
1072 ( 8802)     for i:=1 to counter2 do begin
1073 ( 8825)       if uflag then push(packed(vtype1,'u'))
1074 ( 8839)       else push(vtype);
1075 ( 8858)       if aflag then begin
1076 ( 8862)         push(n); t3[spnt-counter2+i]:=n;
1077 ( 8889)         t2[spnt-counter2+i]:=parlevel;
1078 ( 8911)         parlevel:=succ(parlevel)+n;
1079 ( 8924)       end {then};

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 19

1080 ( 8933)       t0[spnt-counter2+i]:=vtype;
1081 ( 8947)     end {for};
1082 ( 8955)     if aflag then counter2:=2*counter2;
1083 ( 8978)     counter1:=counter1+counter2;
1084 ( 8991)     until token<>' ;'; {outer loop}
1085 ( 9011)   testto(' )'); scan;
1086 ( 9024)   if find=0 then
1087 ( 9030)     stack[t3[spnt-npara]]:=counter1
1088 ( 9047)   else begin {information is allready there}
1089 ( 9058)     stack[bs]:=counter1;
1090 ( 9062)     n:=t3[fortab[find]]; {existing stack data}
1091 ( 9086)     for i:=0 to stackpnt-bs do
1092 ( 9096)       if stack[bs+1]<>stack[n+1]
1093 ( 9127)         then merror(13,'pa'); {parameter wrong}
1094 ( 9161)     stackpnt:=prec(bs) {clear the new info}
1095 ( 9165)   end  {else}
1096 ( 9170) end {parameter};
1097 ( 9170) 
1098 ( 9171) { * memory *              ( of block) }
1099 ( 9171) 
1100 ( 9171) proc memory;
1101 ( 9171) 
1102 ( 9171) var typ1,typ2:char;
1103 ( 9174)     i,l,n: integer;
1104 ( 9174)     aflag,uflag: boolean;
1105 ( 9174) 
1106 ( 9174) begin
1107 ( 9174)   scan;
1108 ( 9180)   repeat {main loop}
1109 ( 9180)     l:=0;
1110 ( 9182)     repeat
1111 ( 9186)       decvar('m','i');
1112 ( 9196)       l:=succ(l); testto(' ='); scan;
1113 ( 9218)       n:=getcon; testtype('i');
1114 ( 9236)       scan; t2[spnt]:=n;
1115 ( 9244)     until token<>' ,';
1116 ( 9259)     testto(' :');
1117 ( 9272)     gettype(typ2,aflag,uflag,n);
1118 ( 9308)     if uflag then error(11);
1119 ( 9323)     scan;
1120 ( 9327)     if token=' &' then begin {8-bit}
1121 ( 9338)       typ1:='h'; scan
1122 ( 9344)     end
1123 ( 9348)     else typ1:='m';
1124 ( 9353)     if aflag then typ1:=succ(typ1);
1125 ( 9368)     for i:=succ(spnt-l) to spnt do begin
1126 ( 9400)       t0[i]:=packed(typ1,typ2);
1127 ( 9413)       t3[i]:=n;
1128 ( 9421)     end;
1129 ( 9429)     testto(' ;'); scan;
1130 ( 9456)   until token<>'id';
1131 ( 9463) end {memory};
1132 ( 9467) 
1133 ( 9468) 
1134 ( 9468) {######################################}
1135 ( 9468) { * statement *           ( of block ) }
1136 ( 9468) {######################################}
1137 ( 9468) 
1138 ( 9468) proc statmnt;
1139 ( 9468) 

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 20

1140 ( 9468) var idpnt,relad,k2,savpc,bottom1: integer;
1141 ( 9471)     device,wln: boolean;
1142 ( 9471)     savtp1,vartyp2: char;
1143 ( 9471)     wl: boolean;
1144 ( 9471) 
1145 ( 9471) { * code4 *               ( of statement ) }
1146 ( 9471) 
1147 ( 9471) proc code4(x,y1,z1: integer); {set 4-byte code}
1148 ( 9471) 
1149 ( 9471) var y,z: integer;
1150 ( 9474) 
1151 ( 9474) begin
1152 ( 9474)   y:=y1; z:=z1;
1153 ( 9484)   if y<0 then y:=y+256;
1154 ( 9509)   if x=43 then z:=z-pc-2;
1155 ( 9535)   code1(x);code1(y);code1(z and 255);
1156 ( 9573)   code1(z shr 8)
1157 ( 9579) end {code4};
1158 ( 9586) 
1159 ( 9587) { * testferror *         ( of statement) ) }
1160 ( 9587) 
1161 ( 9587) proc testferror;
1162 ( 9587) begin
1163 ( 9587)   code1($4f);
1164 ( 9600) end;
1165 ( 9600) 
1166 ( 9601) { * gpval *              ( of statement ) }
1167 ( 9601) 
1168 ( 9601) proc gpval(idpnt: integer;
1169 ( 9601)   dir: boolean; typ: char);
1170 ( 9601) 
1171 ( 9601) var d: integer;
1172 ( 9604) 
1173 ( 9604) begin {gpval}
1174 ( 9604)   if dir then d:=1 else d:=0;
1175 ( 9624)   case typ of
1176 ( 9628)   'h':  begin code3($22,t2[idpnt]);
1177 ( 9655)           if dir then code1($3f);
1178 ( 9670)           code1($17+d) end;
1179 ( 9683)   'm':  begin code3($22,t2[idpnt]);
1180 ( 9709)           code1($3d+d) end;
1181 ( 9722)   'i':  begin
1182 ( 9732)           if dir then code1($3f);
1183 ( 9747)           code3($22,t2[idpnt]);
1184 ( 9763)           code1(3);
1185 ( 9771)           if dir then code1($3f);
1186 ( 9786)           code1($17+d) end;
1187 ( 9799)   'n':  begin if dir then code1($3f);
1188 ( 9824)           code3($22,1); code1($12);
1189 ( 9842)           code3($22,t2[idpnt]);
1190 ( 9858)           code1(3); code1($3d+d) end
1191 ( 9879)   else begin
1192 ( 9882)     if typ='q' then begin
1193 ( 9889)       { relad=1 bedeutet: s[i] Zugriff auf }
1194 ( 9892)       { cpnt-string-byte }
1195 ( 9892)       if relad=1 then begin
1196 ( 9899)         if t3[idpnt]=0 then
1197 ( 9912)           checkindex(0,63)
1198 ( 9920)         else
1199 ( 9926)           checkindex(0,t3[idpnt]);

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 21

1200 ( 9945)       end;
1201 ( 9945)       code4($55,level-t1[idpnt],2*t2[idpnt]);
1202 ( 9977)     end else
1203 ( 9977)       code4($27+2*d+relad,level-t1[idpnt],
1204 (10003)         2*t2[idpnt]);
1205 (10025)     end
1206 (10025)   end {case}
1207 (10027) end;
1208 (10027) 
1209 (10028) { FORWARD decl. of mainexp (of statement) }
1210 (10028) 
1211 (10028) proc mainexp(reqtype: char;
1212 (10028)   var arsize: integer); forward;
1213 (10031) 
1214 (10031) { * express *           ( of statement ) }
1215 (10031) 
1216 (10031) proc express; {requests a normal 16-bit result }
1217 (10031) 
1218 (10031) var resultsize: integer;
1219 (10034) 
1220 (10034) begin {express}
1221 (10034)   mainexp('n',resultsize);
1222 (10052)   if resultsize<>0 then error(15)
1223 (10064) end {express};
1224 (10070) 
1225 (10071) { * arrayexp *          ( of mainexp) }
1226 (10071) 
1227 (10071) proc arrayexp(size: integer; eltype: char);
1228 (10071) 
1229 (10071) var resultsize: integer;
1230 (10074) 
1231 (10074) begin
1232 (10074)   mainexp(eltype,resultsize);
1233 (10094)   if resultsize<>size then error(15);
1234 (10114)   testtype(eltype);
1235 (10124) end;
1236 (10124) 
1237 (10125) { * getvar *            ( of statement ) }
1238 (10125) 
1239 (10125) proc getvar;
1240 (10125) begin
1241 (10125)   vartyp2:=high(t0[idpnt]);
1242 (10138)   vartype:=low(t0[idpnt]);
1243 (10151)   scan;
1244 (10160)   if (vartype='q') and (token=' [') and
1245 (10175)     ((vartyp2='v') or (vartyp2='d')) then begin
1246 (10192)     vartyp2:='q'; vartype:='c';
1247 (10203)   end;
1248 (10207)   case vartyp2 of
1249 (10207)   'a','x','s','i','n','q':
1250 (10250)       begin
1251 (10253)         if token=' [' then begin
1252 (10261)           scan; express; relad:=1;
1253 (10274)           if vartyp2='r' then begin
1254 (10285)             relad:=3;
1255 (10290)             code3($22,1); code1($12)
1256 (10306)           end;
1257 (10312)           if (vartyp2='q') and (t3[idpnt]=0) then
1258 (10330)             checkindex(0,63)
1259 (10338)           else

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 22

1260 (10344)             checkindex(0,t3[idpnt]);
1261 (10363)           testtype('i'); testto(' ]'); scan;
1262 (10384)         end else relad:=2;
1263 (10389)       end;
1264 (10393)   'v','w','r','h','m': relad:=0;
1265 (10433)   'c','d','e','t','u': error(6)
1266 (10477)   else error(1)
1267 (10488)   end {case}
1268 (10496) end {getvar};
1269 (10496) 
1270 (10497) { * prcall *            ( of statement ) }
1271 (10497) 
1272 (10497) proc prcall (idpn1: integer);
1273 (10497) 
1274 (10497) var bstack,numpar,i,n,n2: integer;
1275 (10500) 
1276 (10500) { body of prcall follows later }
1277 (10500) 
1278 (10500) { * prcall1 *           ( of prcall ) }
1279 (10500) 
1280 (10500) proc prcall1;
1281 (10500) var ressize:integer;
1282 (10503) 
1283 (10503)   proc prcall3;
1284 (10503)   begin {prcall3}
1285 (10506)     testto('id');
1286 (10517)     idpnt:=findid;
1287 (10523)     if idpnt=0 then error(5);
1288 (10545)     getvar;
1289 (10549)     if chr(stack[i] and 255)<>vartype then
1290 (10561)       if chr(stack[i] and 255)<>'u' then
1291 (10583)         merror(14,'01');
1292 (10598)       push(idpnt);
1293 (10608)   end {prcall3};
1294 (10608) 
1295 (10609) begin {prcall1}
1296 (10609)   case chr(stack[i] shr 8) of
1297 (10622)     'd':  begin
1298 (10630)             if chr(stack[i] and 255) = 'q' then
1299 (10644)               mainexp('q',ressize)
1300 (10650)             else
1301 (10664)               express;
1302 (10671)             if chr(stack[i] and 255)<>'u' then
1303 (10685)               testtype(chr(stack[i] and 255));
1304 (10707)           end;
1305 (10707)     'e':  begin
1306 (10717)             arrayexp(stack[succ(i)],
1307 (10722)               chr(stack[i]));
1308 (10741)             i:=succ(i);
1309 (10745)           end;
1310 (10750)     'w':  begin
1311 (10760)             prcall3;
1312 (10764)             if relad<>0 then merror(14,'02');
1313 (10785)             gpval(idpnt,false,vartyp2);
1314 (10801)           end;
1315 (10801)     'x':  begin
1316 (10811)             prcall3;
1317 (10815)             if relad<>2 then merror(14,'03');
1318 (10836)             if vartyp2='i' then error(16);
1319 (10854)             i:=succ(i);

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 23

1320 (10858)             if stack[i]<>t3[idpnt] then
1321 (10875)               error(15);
1322 (10891)             if vartyp2='n' then begin
1323 (10898)               code3($22,t2[idpnt]);
1324 (10917)               code1($3d);
1325 (10925)             end else code4($27,level-t1[idpnt],
1326 (10938)               2*t2[idpnt]);
1327 (10960)             code2($3b,stack[i]);
1328 (10976)           end
1329 (10976)     else merror(14,'04')
1330 (10984)   end {case}
1331 (10992) end {prcall1};
1332 (10992) 
1333 (10993) proc prcall2;
1334 (10993) begin
1335 (10993)   if n>0 then code3(35,-2*n);
1336 (11024)   n:=0
1337 (11024) end {prcall2};
1338 (11030) 
1339 (11031) begin {body of prcall}
1340 (11031)   if t3[idpn1]<>0 then begin
1341 (11044)     bstack:=t3[idpn1];
1342 (11051)     numpar:=stack[bstack];
1343 (11063)     parse(' ('); scan;
1344 (11084)     for i:=succ(bstack) to bstack+numpar do
1345 (11097)     begin
1346 (11111)       prcall1;
1347 (11115)       if i<bstack+numpar then begin
1348 (11129)         testto(' ,'); scan
1349 (11141)       end
1350 (11145)     end;
1351 (11145)     testto(' )');
1352 (11168)   end {then};
1353 (11168)   code4(43,level-t1[idpn1],t2[idpn1]);
1354 (11197)   if t3[idpn1]<>0 then begin
1355 (11208)     n:=0; i:=bstack+numpar;
1356 (11221)     repeat
1357 (11230)       case chr(stack[i] shr 8) of
1358 (11241)       'd':  n:=succ(n);
1359 (11253)       'w':  begin
1360 (11268)               prcall2; idpnt:=pop;
1361 (11278)               gpval(idpnt,true,
1362 (11288)                   high(t0[idpnt]));
1363 (11303)             end;
1364 (11303)       chr(0): begin
1365 (11313)             n2:=stack[i];
1366 (11317)             i:=i-1;
1367 (11331)             case chr(stack[i] shr 8) of
1368 (11347)               'e':  n:=succ(n+n2);
1369 (11364)               'x':  begin
1370 (11379)                       prcall2;
1371 (11383)                       idpnt:=pop;
1372 (11389)                       if high(t0[idpnt])='n'
1373 (11402)                       then begin
1374 (11405)                         code3($22,t2[idpnt]+
1375 (11414)                           2*t3[idpnt]);
1376 (11436)                         code1($3e)
1377 (11438)                       end else
1378 (11444)                         code4(41,
1379 (11449)                           level-t1[idpnt],

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 24

1380 (11457)                           2*(t2[idpnt]+
1381 (11468)                           t3[idpnt]));
1382 (11488)                       code2($3c,t3[idpnt])
1383 (11494)                     end
1384 (11504)               end {case}
1385 (11506)             end
1386 (11506)       end; {case}
1387 (11508)       i:=prec(i);
1388 (11512)     until i=bstack;
1389 (11521)     prcall2
1390 (11529)   end
1391 (11533) end {prcall};
1392 (11533) 
1393 (11534) 
1394 (11534) {###################################}
1395 (11534) { * mainexp *       ( of statement) }
1396 (11534) {###################################}
1397 (11534) {  see forward declaration above    }
1398 (11534) 
1399 (11534) proc mainexp(reqtype: char;
1400 (11534)   var arsize: integer);
1401 (11534) 
1402 (11534) { variables of mainexp}
1403 (11534) var opcode,roff: integer;
1404 (11537)     savtype: char;
1405 (11537) 
1406 (11537) { * argument *         ( of mainexp ) }
1407 (11537) 
1408 (11537) proc argument(rtype: char);
1409 (11537) begin
1410 (11537)   parse(' ('); scan; express;
1411 (11559)   testtype(rtype);
1412 (11569)   testto(' )'); scan
1413 (11578) end; {argument}
1414 (11583) 
1415 (11583) {#######################################}
1416 (11583) { * simexp *             ( of mainexp ) }
1417 (11583) {#######################################}
1418 (11583) 
1419 (11583) proc simexp(var arsize1: integer);
1420 (11583) 
1421 (11583) var opcode: integer;
1422 (11586)     sign: char;
1423 (11586) 
1424 (11586) {body of simexp  follows later }
1425 (11586) 
1426 (11586) {#######################################}
1427 (11586) { * term *               ( of simexp )  }
1428 (11586) {#######################################}
1429 (11586) 
1430 (11586) proc term(var arsize2: integer);
1431 (11586) 
1432 (11586) var opcode: integer;
1433 (11589) 
1434 (11589) { body of term follows later }
1435 (11589) 
1436 (11589) {#######################################}
1437 (11589) { * factor *             ( of term )    }
1438 (11589) {#######################################}
1439 (11589) 

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 25

1440 (11589) proc factor(var arsize3: integer);
1441 (11589) 
1442 (11589) var i, idpnt: integer;
1443 (11592)     h: char;
1444 (11592) 
1445 (11592) { * index *              ( of factor )  }
1446 (11592) 
1447 (11592) proc index(chk: boolean);
1448 (11592) 
1449 (11592) var savtype: char;
1450 (11595) 
1451 (11595) begin {index}
1452 (11595)   scan; savtype:=restype;
1453 (11601)   express; testtype('i'); testto(' ]');
1454 (11630)   if savtype='r' then begin
1455 (11637)     code3($22,1); code1($12);
1456 (11658)   end;
1457 (11658)   if chk then begin
1458 (11662)     if (savtype='q') and (t3[idpnt]=0) then
1459 (11683)       { is an arrayed cpnt }
1460 (11684)       checkindex(0,63)
1461 (11691)     else
1462 (11697)       checkindex(0,t3[idpnt]);
1463 (11716)   end;
1464 (11716)   restype:=savtype; scan
1465 (11724) end;
1466 (11728) 
1467 (11729) 
1468 (11729) begin { *** body of factor *** }
1469 (11729)   arsize3:=0;
1470 (11733)   case token of
1471 (11737)     'id': begin {identifier }
1472 (11749)             idpnt:=findid;
1473 (11755)             if idpnt=0 then error(5);
1474 (11777)             restype:=low(t0[idpnt]);
1475 (11785)             h:=high(t0[idpnt]);
1476 (11798)             case h of
1477 (11803)               'v','w','d':
1478 (11825)                     begin
1479 (11828)                       scan;
1480 (11832)                       if (restype='q') and (token=' [')
1481 (11846)                       then begin
1482 (11848)                         code4(39,level-t1[idpnt],
1483 (11861)                           2*t2[idpnt]);
1484 (11883)                         index(true);
1485 (11891)                         code1($03);
1486 (11899)                         code1($54);
1487 (11907)                         restype:='c';
1488 (11909)                       end else
1489 (11913)                         code4(39,level-t1[idpnt],
1490 (11926)                           2*t2[idpnt]);
1491 (11948)                     end;
1492 (11948)               'h':  begin code3($22,t2[idpnt]);
1493 (11974)                       code1($17); scan end;
1494 (11986)               'i':  begin code3($22,t2[idpnt]);
1495 (12012)                       scan;
1496 (12016)                       if token=' [' then begin
1497 (12024)                         index(true); code1($03);
1498 (12043)                         code1($17)
1499 (12045)                       end else begin

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 26

1500 (12054)                         error(16)
1501 (12056)                       end
1502 (12062)                     end;
1503 (12062)               'm':  begin code3($22,t2[idpnt]);
1504 (12088)                       code1($3d); scan
1505 (12096)                     end;
1506 (12100)               'n':  begin code3($22,t2[idpnt]);
1507 (12126)                       scan;
1508 (12130)                       if token=' [' then begin
1509 (12138)                         index(true);
1510 (12149)                         code3($22,1);code1($12);
1511 (12167)                         code1($03); code1($3d);
1512 (12183)                         if restype='r' then
1513 (12189)                         begin
1514 (12190)                           code2($3b,1);
1515 (12203)                           arsize3:=1
1516 (12203)                         end
1517 (12205)                       end else begin
1518 (12212)                         code1($3d);
1519 (12220)                         code2($3b,t3[idpnt]);
1520 (12236)                         arsize3:=t3[idpnt];
1521 (12240)                       end
1522 (12248)                     end;
1523 (12248)               'r','t': begin
1524 (12265)                       code3(35,2);
1525 (12275)                       idpnt:=prec(idpnt);
1526 (12279)                       prcall(idpnt); scan;
1527 (12298)                       restype:=low(t0[idpnt]);
1528 (12306)                     end;
1529 (12311)               'c':  if low(t0[idpnt])<>'r' then begin
1530 (12333)                       code3(34,t2[idpnt]);
1531 (12352)                       scan;
1532 (12356)                       if restype='s' then begin
1533 (12363)                         if token=' [' then begin
1534 (12374)                           index(true);
1535 (12385)                           code1($03);
1536 (12393)                           code1($58);
1537 (12401)                           code1($54);
1538 (12409)                           restype:='c';
1539 (12411)                         end else begin
1540 (12418)                           code1($58);
1541 (12426)                           restype:='q';
1542 (12428)                         end;
1543 (12432)                       end;
1544 (12432)                       {scan;}
1545 (12432)                     end else begin
1546 (12435)                       code2($3a,2);
1547 (12445)                       code2(t2[idpnt] and 255,
1548 (12455)                         t2[idpnt] shr 8);
1549 (12473)                       code2(t3[idpnt] and 255,
1550 (12483)                         t3[idpnt] shr 8);
1551 (12501)                       arsize3:=1; scan
1552 (12507)                     end;
1553 (12511)               'a','e','x':
1554 (12532)                     begin scan;
1555 (12539)                       if token=' [' then begin
1556 (12547)                         index(true);
1557 (12558)                         code4($28,
1558 (12560)                             level-t1[idpnt],
1559 (12568)                             2*t2[idpnt]);

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 27

1560 (12590)                         if restype='r' then
1561 (12596)                         begin
1562 (12597)                           code2($3b,1);
1563 (12610)                           arsize3:=1
1564 (12610)                         end
1565 (12612)                       end else begin
1566 (12619)                         code4($27,
1567 (12621)                             level-t1[idpnt],
1568 (12629)                             2*t2[idpnt]);
1569 (12651)                         code2($3b,t3[idpnt]);
1570 (12667)                         arsize3:=t3[idpnt];
1571 (12671)                       end
1572 (12679)                     end;
1573 (12679)               's','u':
1574 (12693)                     begin
1575 (12696)                       code3(35,2*t3[idpnt]+2);
1576 (12718)                       idpnt:=prec(idpnt);
1577 (12722)                       prcall(idpnt); scan;
1578 (12741)                       restype:=low(t0[idpnt]);
1579 (12749)                       idpnt:=succ(idpnt);
1580 (12758)                       arsize3:=t3[idpnt]
1581 (12763)                     end
1582 (12767)               else error(1)
1583 (12780)             end {case}
1584 (12788)           end; {identifier}
1585 (12791)     'nu': begin code3(34,value[0]); scan;
1586 (12817)             restype:='i'
1587 (12817)           end;
1588 (12823)     'ru': begin code2($3a,2);
1589 (12844)             code2(value[0] and 255,
1590 (12852)               value[0] shr 8);
1591 (12868)             code2(value[1] and 255,
1592 (12876)               value[1] shr 8);
1593 (12892)             scan; restype:='r';
1594 (12898)             arsize3:=1
1595 (12902)           end;
1596 (12908)     'st': begin
1597 (12919)           if (reqtype='n') and (value[0]<3)
1598 (12934)             then begin
1599 (12936)               if value[0]<2 then begin
1600 (12948)                 code3(34,ord(ident[1]));
1601 (12965)                 restype:='c'
1602 (12965)               end else begin
1603 (12974)                 code3(34,packed(ident[1],
1604 (12978)                   ident[2]));
1605 (12995)                 restype:='p'
1606 (12995)               end
1607 (12997)             end else begin
1608 (13004)               case reqtype of
1609 (13004)                 'c','u','n','q':
1610 (13033)                     begin
1611 (13036)                       if (vartype='q') or
1612 (13043)                          (reqtype='q') then begin
1613 (13051)                         arsize3:=0;
1614 (13056)                         restype:='q';
1615 (13062)                         code2($56,value[0]);
1616 (13080)                       end else begin
1617 (13083)                         arsize3:=prec(value[0]);
1618 (13089)                         restype:='c';
1619 (13096)                         code2($39,value[0]);

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 28

1620 (13114)                       end;
1621 (13114)                       for i:=1 to value[0] do
1622 (13122)                         code1(ord(ident[i]));
1623 (13149)                       if (vartype='q') or
1624 (13170)                          (reqtype='q') then code1(0);
1625 (13189)                     end;
1626 (13189)                 'p': begin
1627 (13199)                       if odd(value[0]) then
1628 (13205)                         error(15);
1629 (13217)                       value[0]:=value[0] shr 1;
1630 (13227)                       arsize3:=prec(value[0]);
1631 (13238)                       restype:='p';
1632 (13245)                       code2($3a,value[0]);
1633 (13263)                       for i:=1 to value[0] do
1634 (13271)                         begin
1635 (13284)                         code1(ident[2*i]);
1636 (13301)                         code1(ident[2*i-1]);
1637 (13321)                       end
1638 (13321)                     end
1639 (13321)                 else merror(14,'05')
1640 (13343)               end {case}
1641 (13351)             end;
1642 (13351)             scan
1643 (13351)           end;
1644 (13355)     'od': begin
1645 (13366)             argument('i'); code1(7);
1646 (13382)             restype:='b'
1647 (13382)           end;
1648 (13388)     'me': begin
1649 (13399)             parse(' ['); index(false);
1650 (13416)             code1(23); restype:='i';
1651 (13426)           end;
1652 (13430)     ' (': begin
1653 (13441)             scan; mainexp(reqtype,arsize3);
1654 (13463)             testto(' )'); scan
1655 (13472)           end; {no type change}
1656 (13479)     'no': begin
1657 (13487)             scan; factor(arsize3);
1658 (13503)             if (arsize3<>0) then error(15);
1659 (13521)             code1($11);
1660 (13529)             if restype<>'i' then
1661 (13535)               testtype('b')
1662 (13541)           end;
1663 (13547)     'cr': begin
1664 (13558)             argument('i'); code1(52);
1665 (13574)             restype:='c'
1666 (13574)           end;
1667 (13580)     'hi': begin
1668 (13591)             argument('p'); code1(51);
1669 (13607)             restype:='c'
1670 (13607)           end;
1671 (13613)     'lo': begin
1672 (13624)             argument('p'); code1(52);
1673 (13640)             restype:='c'
1674 (13640)           end;
1675 (13646)     'su': begin
1676 (13657)             argument('u'); code1($14);
1677 (13673)           end;
1678 (13673)     'pc': begin
1679 (13684)             argument('u'); code1($15)

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 29

1680 (13694)           end;
1681 (13700)     'cp': begin
1682 (13711)             argument('i'); restype:='q';
1683 (13721)           end;
1684 (13725)     'ni': begin
1685 (13736)             code3(34,0); scan; restype:='q';
1686 (13752)           end;
1687 (13756)     'ox': begin
1688 (13767)             argument('u');
1689 (13775)             restype:='i'
1690 (13775)           end;
1691 (13781)     ' @': begin
1692 (13792)             scan; factor(arsize3);
1693 (13808)             if arsize3<>0 then error(15);
1694 (13826)             if restype<>'q' then testtype('i');
1695 (13844)             restype:='f'
1696 (13844)           end;
1697 (13850)     'tr': begin
1698 (13861)             code3(34,1); scan;
1699 (13875)             restype:='b';
1700 (13877)           end;
1701 (13881)     'fa': begin
1702 (13892)             code3(34,0); scan;
1703 (13906)             restype:='b'
1704 (13906)           end;
1705 (13912)     'tc': begin
1706 (13923)             parse(' ('); scan;
1707 (13936)             arrayexp(1,'r');
1708 (13946)             testto(' )'); scan;
1709 (13959)             code1($47); restype:='i';
1710 (13969)           end;
1711 (13973)     'cv': begin
1712 (13984)             argument('i');
1713 (13992)             code1($46); arsize3:=1;
1714 (14002)             restype:='r'
1715 (14006)           end;
1716 (14012)     'pa': begin
1717 (14023)             parse(' ('); scan; express;
1718 (14040)             testtype('c');
1719 (14048)             if token=' ,' then begin
1720 (14056)               scan; express; testtype('c');
1721 (14075)               code1(53)
1722 (14077)             end;
1723 (14083)             testto(' )'); scan; restype:='p'
1724 (14096)           end
1725 (14098)     else error(1)
1726 (14107)   end {case of token}
1727 (14115) end {factor};
1728 (14115) 
1729 (14116) begin  { *** body of term *** }
1730 (14116)   factor(arsize2);
1731 (14130)   repeat
1732 (14130)     case token of
1733 (14130)       ' *': opcode:=5;
1734 (14144)       'di': opcode:=6;
1735 (14161)       'an': opcode:=15;
1736 (14178)       'sh': opcode:=18;
1737 (14195)       'sr': opcode:=19;
1738 (14212)       ' /': opcode:=$45
1739 (14227)       else opcode:=0

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 30

1740 (14236)     end {case};
1741 (14244)     if opcode>0 then begin
1742 (14251)       if (restype='r') and
1743 (14261)             (arsize2=1) then begin
1744 (14269)         scan; factor(arsize2);
1745 (14288)         if (restype<>'r') or (arsize2<>1) then
1746 (14302)           merror(14,'06');
1747 (14317)         case opcode of
1748 (14317)           5: code1($44);
1749 (14336)           $45: code1($45)
1750 (14348)           else error(17)
1751 (14359)         end{case}
1752 (14367)       end else begin
1753 (14370)         if opcode=$45 then error(9);
1754 (14388)         if arsize2<>0 then error(15);
1755 (14406)         if (restype='b') and (opcode=15)
1756 (14419)           then begin
1757 (14421)           scan; factor(arsize2);
1758 (14440)           if arsize2<>0 then error(15);
1759 (14458)           testtype('b');
1760 (14466)           code1(opcode)
1761 (14466)         end else begin
1762 (14479)           testtype('i'); scan;
1763 (14491)           factor(arsize2);
1764 (14503)           if arsize2<>0 then error(15);
1765 (14521)           testtype('i'); code1(opcode);
1766 (14539)         end
1767 (14539)       end
1768 (14539)     end;
1769 (14539)   until opcode=0;
1770 (14545) end {term};
1771 (14549) 
1772 (14550) 
1773 (14550) begin { *** body of simexp *** }
1774 (14550)   sign:=' ';
1775 (14554)   if token=' +' then begin
1776 (14566)     sign:='+'; scan
1777 (14575)   end else if token=' -' then begin
1778 (14590)     sign:='-'; scan
1779 (14599)   end;
1780 (14603)   term(arsize1);
1781 (14615)   if sign<>' ' then begin
1782 (14622)     if (restype='r')and (arsize1=1) then begin
1783 (14640)       if sign='-' then code1($4e)
1784 (14655)     end else begin
1785 (14664)       testtype('i');
1786 (14672)       if arsize1<>0 then error(15);
1787 (14690)       if sign='-' then code1(2);
1788 (14708)     end
1789 (14708)   end;
1790 (14708)   repeat
1791 (14708)     case token of
1792 (14708)       ' &': opcode:=1;
1793 (14722)       ' +': opcode:=3;
1794 (14739)       ' -': opcode:=4;
1795 (14756)       'or': opcode:=14;
1796 (14773)       'xo': opcode:=16
1797 (14788)       else opcode:=0
1798 (14797)     end {case};
1799 (14805)     if opcode>1 then begin {if 1}

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 31

1800 (14815)       if (restype='r') and (arsize1=1)
1801 (14828)         then begin {real}
1802 (14833)         scan; term(arsize1);
1803 (14849)         if (restype<>'r') or (arsize1<>1) then
1804 (14863)           error(17);
1805 (14875)         case opcode of
1806 (14875)           3:  code1($42);
1807 (14894)           4:  code1($43)
1808 (14906)           else error(17)
1809 (14917)         end {case}
1810 (14925)       end {real}
1811 (14925)       else begin {not real}
1812 (14928)         if (arsize1<>0) then error(15);
1813 (14946)         if (restype='b') and (opcode>=14)
1814 (14959)           then begin {boolean}
1815 (14964)           scan; term(arsize1);
1816 (14980)           if arsize1<>0 then error(15);
1817 (14998)           testtype('b'); code1(opcode)
1818 (15006)         end {boolean}
1819 (15016)         else begin {not boolean}
1820 (15019)           testtype('i'); scan;
1821 (15031)           term(arsize1);
1822 (15043)           if arsize1<>0 then error(15);
1823 (15061)           testtype('i'); code1(opcode);
1824 (15079)         end {not boolean}
1825 (15079)       end {not real}
1826 (15079)     end {if 1}
1827 (15079)     else if opcode=1 then begin {else 1}
1828 (15092)       sign:=restype;
1829 (15092)       scan; term(opcode);
1830 (15116)       arsize1:=arsize1+opcode+1;
1831 (15127)       testtype(sign)
1832 (15132)     end {else 1}
1833 (15142)   until opcode=0
1834 (15146) end {simexp};
1835 (15152) 
1836 (15153) 
1837 (15153) begin { *** body of mainexp *** }
1838 (15153)   roff:=0;
1839 (15157)   simexp(arsize);
1840 (15173)   if (restype='r') and (arsize=1) then
1841 (15187)     roff:=$40;
1842 (15193)   case token of
1843 (15197)     ' =': opcode:=8;
1844 (15211)     ' <': opcode:=10;
1845 (15228)     ' >': opcode:=12;
1846 (15245)     '<>': opcode:=9;
1847 (15262)     '<=': opcode:=13;
1848 (15279)     '>=': opcode:=11
1849 (15294)     else opcode:=0
1850 (15303)   end {case};
1851 (15311)   if opcode>0 then begin
1852 (15318)     if (arsize<>0) and (roff=0) then
1853 (15335)       error(15);
1854 (15347)     scan; savtype:=restype; simexp(arsize);
1855 (15371)     if ((roff=0) and (arsize<>0))
1856 (15385)       or((roff<>0) and (arsize>1)) then
1857 (15401)       error(15);
1858 (15413)     testtype(savtype); code1(opcode+roff);
1859 (15438)     arsize:=0; restype:='b'

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 32

1860 (15444)   end
1861 (15446) end {mainexp};
1862 (15450) 
1863 (15451) 
1864 (15451) {#########################################}
1865 (15451) { * assign *             ( of statement ) }
1866 (15451) {#########################################}
1867 (15451) 
1868 (15451) proc assign;
1869 (15451) 
1870 (15451) var savetype: char;
1871 (15454) 
1872 (15454)   proc assign1;
1873 (15454)   begin
1874 (15454)     testto(':='); scan; express;
1875 (15476)     if (vartype='q') and (restype='s') then begin
1876 (15491)       code1($58); restype:='q';
1877 (15504)     end;
1878 (15508)     gpval(idpnt,true,vartyp2);
1879 (15524)   end {assign1};
1880 (15524) 
1881 (15525) begin {assign}
1882 (15525)   idpnt:=findid;
1883 (15533)   if idpnt=0 then error(5);
1884 (15555)   if t0[idpnt]='pr' then begin
1885 (15567)     prcall(idpnt);scan end
1886 (15584)   else begin
1887 (15587)     getvar; savetype:=vartype;
1888 (15591)     if relad<2 then begin
1889 (15606)       assign1; testtype(vartype)
1890 (15613)     end else begin
1891 (15626)       if vartyp2='i' then error(16); {8-bit mem}
1892 (15644)       testto(':='); scan;
1893 (15657)       if relad=3 then begin
1894 (15664)         arrayexp(1,vartype); relad:=1;
1895 (15681)         code1($53);
1896 (15693)         if vartyp2='n' then begin
1897 (15700)           code1($3f);
1898 (15711)           code3($22,1);code1($12);
1899 (15729)           code3($22,t2[idpnt]+2);
1900 (15748)           code1($3);code1($3e)
1901 (15758)         end else
1902 (15764)           code4($2a,level-t1[idpnt],
1903 (15777)             2*t2[idpnt]+2);
1904 (15802)         code2($3c,1)
1905 (15806)       end else begin
1906 (15815)         arrayexp(t3[idpnt],vartype);
1907 (15833)         if vartyp2='n' then begin
1908 (15840)           code3($22,t2[idpnt]+2*t3[idpnt]);
1909 (15871)           code1($3e);
1910 (15879)         end else
1911 (15879)           code4($29,level-t1[idpnt],
1912 (15892)             2*(t2[idpnt]+t3[idpnt]));
1913 (15923)         code2($3c,t3[idpnt]);
1914 (15939)       end
1915 (15939)     end
1916 (15939)   end
1917 (15939) end {assign};
1918 (15939) 
1919 (15940) { * case1 *             ( of statement ) }

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 33

1920 (15940) 
1921 (15940) proc case1;
1922 (15940) 
1923 (15940) var i1,i2,casave: integer;
1924 (15943)     savetype: char;
1925 (15943) 
1926 (15943)   proc case2;
1927 (15943) 
1928 (15943)     proc case3;
1929 (15946)     begin
1930 (15946)       scan; code1(22); code3(34,getcon);
1931 (15977)       testtype(savetype);
1932 (15987)       code1(8); scan
1933 (15995)     end;
1934 (15999) 
1935 (16000)   begin {case2}
1936 (16000)     i1:=0; case3;
1937 (16012)     while token=' ,' do begin
1938 (16023)       push(pc); code3(38,0); i1:=succ(i1);
1939 (16047)       case3
1940 (16052)     end;
1941 (16056)     testto(' :'); savpc:=pc; code3(37,0);
1942 (16086)     for k2:=1 to i1 do fixup(pop);
1943 (16117)     push(savpc);
1944 (16141)     scan; statmnt
1945 (16145)   end {case2};
1946 (16149) 
1947 (16150) begin {case1}
1948 (16150)   scan; express; testto('of');
1949 (16169)   savetype:=restype; i2:=1; case2;
1950 (16187)   while token=' ;' do begin
1951 (16198)     casave:=pc; code3(36,0); fixup(pop);
1952 (16228)     push(casave); i2:=succ(i2); case2
1953 (16247)   end;
1954 (16251)   if token='el' then begin
1955 (16262)     casave:=pc; code3(36,0); fixup(pop);
1956 (16295)     push(casave); scan; statmnt
1957 (16309)   end;
1958 (16313)   testto('en'); for k2:=1 to i2 do fixup(pop);
1959 (16353)   code3(35,-2); scan
1960 (16378) end {case1};
1961 (16382) 
1962 (16383) { * openrw *              ( of statement ) }
1963 (16383) 
1964 (16383) proc openrw(x: integer);
1965 (16383) begin
1966 (16383)   parse(' ('); parse('id');
1967 (16406)   idpnt:=findid;
1968 (16412)   if idpnt=0 then error(5);
1969 (16434)   getvar; code1(x);
1970 (16448)   testferror;
1971 (16452)   if relad=2 then error(15);
1972 (16470)   if vartype<>'f' then merror(14,'07');
1973 (16491)   gpval(idpnt,true,vartyp2);
1974 (16507)   testto(' )'); scan
1975 (16516) end {openrw};
1976 (16520) 
1977 (16521) { * gpsec *               ( of statement )  }
1978 (16521) 
1979 (16521) proc gpsec(code);   { get/put sector }

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 34

1980 (16521) 
1981 (16521)   proc gpsec1;
1982 (16524)   begin
1983 (16524)     scan; express; testtype('i');
1984 (16545)     testto(' ,');
1985 (16554)   end;
1986 (16554) 
1987 (16555) begin {gpsec}
1988 (16555)   parse(' ('); gpsec1; gpsec1; gpsec1;
1989 (16578)   code1(code);
1990 (16588)   parse('id'); idpnt:=findid;
1991 (16603)   if idpnt=0 then error(5);
1992 (16625)   getvar; code3(34,$db); { get file error code }
1993 (16639)   if relad=2 then error(15);
1994 (16657)   code1(23); if vartype<>'i' then merror(14,'08');
1995 (16686)   gpval(idpnt,true,vartyp2);
1996 (16702)   testto(' )');
1997 (16711) end {gpsec};
1998 (16711) 
1999 (16712) 
2000 (16712) begin {body of statement }
2001 (16712)   if token=' ;' then scan;
2002 (16729)   case token of
2003 (16729)     'id': assign;
2004 (16745) 
2005 (16748)     'if': begin {if}
2006 (16756)             scan; express; testtype('b');
2007 (16772)             testto('th'); scan;  savpc:=pc;
2008 (16785)             code3(37,0); statmnt;
2009 (16807)             if token='el' then begin {else}
2010 (16818)               k2:=pc; code3(36,0);
2011 (16836)               fixup(savpc); scan; statmnt;
2012 (16854)               fixup(k2)
2013 (16854)             end else fixup(savpc)
2014 (16867)           end; {if}
2015 (16880) 
2016 (16880)     'be':  begin {begin}
2017 (16888)             repeat
2018 (16888)               scan; statmnt
2019 (16892)             until token<>(' ;');
2020 (16903)             testto('en'); scan
2021 (16916)           end; {begin}
2022 (16923) 
2023 (16923)     'rp': begin {repeat}
2024 (16931)             savpc:=pc;
2025 (16931)             repeat
2026 (16939)               scan; statmnt
2027 (16943)             until token='un';
2028 (16954)             scan; express; testtype('b');
2029 (16974)             code3(37,savpc)
2030 (16976)           end {repeat};
2031 (16986) 
2032 (16989)     're': begin {read}
2033 (16997)             parse(' ('); scan;
2034 (17010)             if token=' @' then begin
2035 (17018)               scan; express; testtype('f');
2036 (17037)               device:=true;
2037 (17039)               code1(44); testto(' ,')
2038 (17054)             end
2039 (17060)             else begin

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 35

2040 (17063)               device:=false; code1(26)
2041 (17071)             end;
2042 (17077)             repeat
2043 (17077)               begin {main loop of read}
2044 (17077)                 if token=' ,' then scan;
2045 (17092)                 testto('id'); idpnt:=findid;
2046 (17107)                 if idpnt=0 then error(5);
2047 (17129)                 getvar;
2048 (17133)                 if relad=2 then error(15);
2049 (17151)                 case vartype of
2050 (17151)                   'i':  code1(28);
2051 (17170)                   'c':  code1(27);
2052 (17188)                   'p':  begin
2053 (17198)                         code1(27); code1(27);
2054 (17214)                         code1(53)
2055 (17216)                         end
2056 (17222)                   else error(114)
2057 (17227)                 end {case};
2058 (17235)                 gpval(idpnt,true,vartyp2)
2059 (17241)               end {mainloop of read}
2060 (17251)             until token<>' ,';
2061 (17258)             testto(' )'); scan;
2062 (17275)             if device then code1(45);
2063 (17290)           end {read};
2064 (17290) 
2065 (17293)     'wr','wl':
2066 (17306)           begin {write,writeln}
2067 (17309)             if token='wl' then wln:=true
2068 (17320)             else wln:=false;
2069 (17331)             scan;
2070 (17339)             if token=' (' then begin
2071 (17347)               scan;
2072 (17354)               if token=' @' then begin
2073 (17362)                 scan; express;
2074 (17373)                 if restype='q' then restype:='f';
2075 (17385)                 testtype('f');
2076 (17397)                 device:=true; code1(44);
2077 (17411)                 testto(' ,');
2078 (17420)               end else device:=false;
2079 (17425)               repeat
2080 (17429)                 if token=' ,' then scan;
2081 (17444)                 if (token=' )') and device
2082 (17452)                        and wln then
2083 (17457)                    {empty writeln except device}
2084 (17462)                    k2:=k2 {do nothing}
2085 (17465)                 else if token='st' then begin
2086 (17484)                   {string}
2087 (17487)                   code1(50);
2088 (17495)                   for k2:=1 to value[0]-1 do
2089 (17509)                     code1(ord(ident[k2])
2090 (17523)                         and 127);
2091 (17536)                   code1(ord(ident[value[0]])
2092 (17556)                       or 128);
2093 (17569)                   scan
2094 (17569)                 end else begin
2095 (17576)                   {expression}
2096 (17576)                   express;
2097 (17580)                   case restype of
2098 (17580)                     'i':  code1(30);
2099 (17599)                     'c':  code1(29);

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 36

2100 (17617)                     'q':  code1($57);
2101 (17635)                     's':  begin
2102 (17645)                             code1($58);
2103 (17653)                             code1($57);
2104 (17661)                           end;
2105 (17661)                     'p':  begin
2106 (17671)                             code1(22);
2107 (17679)                             code1(51);
2108 (17687)                             code1(29);
2109 (17695)                             code1(52);
2110 (17703)                             code1(29);
2111 (17711)                           end
2112 (17711)                     else merror(14,'09')
2113 (17719)                   end {case}
2114 (17727)                 end {expression}
2115 (17727)               until token<>' ,';
2116 (17734)               if wln then begin {writeln(..)}
2117 (17745)                 code2(32,13); code1(29);
2118 (17763)                 code2(32,10); code1(29);
2119 (17781)               end;
2120 (17781)               if device then code1(45);
2121 (17796)               testto(' )'); scan
2122 (17805)             end {if}
2123 (17809)             else if wln then begin {writeln}
2124 (17819)               code2(32,13); code1(29);
2125 (17837)               code2(32,10); code1(29);
2126 (17855)             end
2127 (17855)           end {write, writeln};
2128 (17855) 
2129 (17858)     'cs': case1; {case statement}
2130 (17873) 
2131 (17873)     'wh': begin {while}
2132 (17881)             scan; savpc:=pc; express;
2133 (17897)             testtype('b');
2134 (17905)             k2:=pc; code3(37,0);
2135 (17923)             testto('do'); scan; statmnt;
2136 (17940)             code3(36,savpc); fixup(k2)
2137 (17952)           end {while};
2138 (17962) 
2139 (17965)     'fo': begin {for}
2140 (17973)             parse('id'); assign;
2141 (17986)             if t0[idpnt]='pr' then error(1);
2142 (18009)             savtp1:=low(t0[idpnt]);
2143 (18017)             case token of
2144 (18022)               'to': k2:=1;
2145 (18036)               'dw': k2:=0
2146 (18051)               else merror(2,'to')
2147 (18065)             end {case of token};
2148 (18073)             scan; express; testtype(savtp1);
2149 (18091)             bottom1:=pc; code1(22);
2150 (18107)             gpval(idpnt,false,vartyp2);
2151 (18123)             code1(13-k2-k2);
2152 (18141)             savpc:=pc; code3(37,0);
2153 (18159)             testto('do'); scan; statmnt;
2154 (18176)             gpval(idpnt,false,vartyp2);
2155 (18192)             code1(21-k2);
2156 (18205)             gpval(idpnt,true,vartyp2);
2157 (18221)             code3(36,bottom1); fixup(savpc);
2158 (18243)             code3(35,-2);
2159 (18254)           end {for};

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 37

2160 (18254) 
2161 (18257)     'me': begin {mem}
2162 (18265)             parse(' ['); scan; express;
2163 (18282)             testtype('i');
2164 (18290)             testto(' ]'); parse(':=');
2165 (18308)             scan; express; code1(24);
2166 (18324)             testtype('i');
2167 (18332)           end {mem};
2168 (18332) 
2169 (18335)     'ca': begin {call}
2170 (18343)             parse(' ('); scan; express;
2171 (18360)             testtype('i');
2172 (18368)             testto(' )'); code1(25); scan
2173 (18385)           end {call};
2174 (18389) 
2175 (18392)     'op': openrw(47);
2176 (18408) 
2177 (18411)     'ow': openrw(48);
2178 (18427) 
2179 (18430)     'ob': openrw(80);
2180 (18446) 
2181 (18449)     'gb': begin
2182 (18457)             parse(' ('); scan; express;
2183 (18474)             testtype('f'); testto(' ,');
2184 (18491)             scan; express; testtype('i');
2185 (18507)             testto(' ,'); scan; testto('id');
2186 (18529)             idpnt:=findid;
2187 (18535)             if idpnt=0 then error(5);
2188 (18557)             getvar;
2189 (18561)             if relad<>0 then error(15);
2190 (18579)             code1($51); testferror;
2191 (18591)             gpval(idpnt,true,vartyp2);
2192 (18607)             testto(' )'); scan
2193 (18616)           end;
2194 (18620) 
2195 (18623)     'pb': begin
2196 (18631)             parse(' ('); scan; express;
2197 (18648)             testtype('f'); testto(' ,');
2198 (18665)             scan; express; testtype('i');
2199 (18681)             testto(' ,'); scan; express;
2200 (18698)             code1($52);testferror;
2201 (18710)             testto(' )');
2202 (18719)             scan
2203 (18719)           end;
2204 (18723) 
2205 (18726)     'ru': begin
2206 (18734)             code1($41); scan;
2207 (18746)           end;
2208 (18746) 
2209 (18749)     'fi': begin
2210 (18757)             code1(46); scan
2211 (18765)           end;
2212 (18769) 
2213 (18772)     'ge': gpsec(55);
2214 (18788) 
2215 (18791)     'pu': gpsec(56);
2216 (18807) 
2217 (18810)     'ex': begin {exit}
2218 (18818)             if level>0 then code1(1) else code1(0);
2219 (18847)             scan;

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 38

2220 (18851)           end;
2221 (18851) 
2222 (18854)     'cl': begin {close}
2223 (18862)             parse(' (');
2224 (18871)             repeat
2225 (18871)               scan; express; code1(49);
2226 (18887)               testtype('f');
2227 (18895)               testferror
2228 (18895)             until token<>' ,';
2229 (18906)             testto(' )'); scan;
2230 (18923)           end {close}
2231 (18923) 
2232 (18923)     else if (token<>'en') and (token<>' ;')
2233 (18941)       and (token<>'un') then begin
2234 (18952)       error(10); scan
2235 (18963)     end
2236 (18967)   end {case of statements}
2237 (18969) end;
2238 (18969) 
2239 (18970) { * findforw *          ( of block ) }
2240 (18970) 
2241 (18970) func findforw;
2242 (18970) 
2243 (18970) var i,j,sav1: integer;
2244 (18973)     done: boolean;
2245 (18973) 
2246 (18973)   func found(start: integer):boolean;
2247 (18973)   var ii,i9: integer;
2248 (18976)   begin {compare}
2249 (18976)     ii:= 0;
2250 (18980)     repeat
2251 (18984)       ii:=succ(ii);
2252 (18988)     until (ii >= 8) or
2253 (19000)       (ident[ii] <> idtab[start+ii]);
2254 (19023)     found:=(ii >= 8);
2255 (19034)   end {compare};
2256 (19038) 
2257 (19039) 
2258 (19039) begin {findforw}
2259 (19039)   i:=succ(forwpn);
2260 (19045)   repeat
2261 (19050)     i:=prec(i);
2262 (19054)     done := (i = 0);
2263 (19066)     if not done then
2264 (19070)       done := found(8*fortab[i]);
2265 (19097)   until done;
2266 (19101)   findforw:=i;
2267 (19108)   if i>0 then
2268 (19122)     if i=forwpn then forwpn:=forwpn-1
2269 (19142)     else begin
2270 (19152)       sav1:=fortab[i];
2271 (19156)       for j:=1 to forwpn-1 do
2272 (19176)       fortab[j]:=fortab[succ(j)];
2273 (19195)       fortab[forwpn]:=sav1;
2274 (19221)       findforw:=forwpn;
2275 (19229)       forwpn:=forwpn-1
2276 (19241)     end
2277 (19243) end {findforw};
2278 (19248) 
2279 (19249) 

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 39

2280 (19249) begin { *** body of block *** }
2281 (19249)   dpnt:=3; t2[bottom]:=pc;
2282 (19261)   code3(36,0);
2283 (19279)   stackpn1:=stackpnt; forwpn:=0;
2284 (19289) 
2285 (19293)   if token='co' then begin    { * const * }
2286 (19304)     scan;
2287 (19308)     repeat
2288 (19308)       deccon; testto(' ;'); scan
2289 (19321)     until token <> 'id';
2290 (19332)   end {const};
2291 (19336) 
2292 (19336)   if token='me' then memory;  { * mem * }
2293 (19351) 
2294 (19351)   if token='va' then variable;{ * var * }
2295 (19366) 
2296 (19366)   while (token='pr')or (token='fu') do begin
2297 (19386)     parlevel:=0;
2298 (19388)     case token of
2299 (19392)     'pr': begin               { * proc * }
2300 (19404)             parse('id'); npara:=0;
2301 (19415)             putsym('p','r'); cproc:=spnt;
2302 (19429)             level:=succ(level);
2303 (19441)           end;
2304 (19446)     'fu': begin               { * func * }
2305 (19457)             parse('id'); npara:=1;
2306 (19468)             putsym('f','i');
2307 (19482)             cproc:=spnt; level:=succ(level);
2308 (19494)             putsym('f','i');
2309 (19509)             t2[spnt]:=parlevel;
2310 (19513)             parlevel:=succ(parlevel);
2311 (19525)           end
2312 (19530)     end; {case of token}
2313 (19532)     if forwpn=0 then find:=0
2314 (19542)     else find:=findforw;
2315 (19557)     if find<>0 then begin
2316 (19568)       spnt:=spnt-npara-1;
2317 (19582)       cproc:=fortab[find];
2318 (19591)       fixup(t2[cproc]);
2319 (19613)     end;
2320 (19613)     scan; spnt1:=spnt;
2321 (19617)     dpnt1:=dpnt;
2322 (19625)     if token=' (' then parameter;
2323 (19648)     if t0[cproc]='fi' then function;
2324 (19667)     testto(' ;');
2325 (19676)     for i:=1 to npara do
2326 (19682)     t2[succ(spnt-i)]:=t2[succ(spnt-i)]
2327 (19714)           -parlevel;
2328 (19719)     scan;
2329 (19746)     if token='fw' then begin
2330 (19754)       if forwpn=8 then merror(13,'ov');
2331 (19778)       forwpn:=succ(forwpn);
2332 (19782)       fortab[forwpn]:=cproc;
2333 (19791)       t2[cproc]:=pc;
2334 (19803)       code3(36,0);
2335 (19821)       scan
2336 (19821)     end else block(cproc);
2337 (19838)     level:=prec(level);
2338 (19842)     dpnt:=dpnt1; spnt:=spnt1;
2339 (19855)     case high(t0[spnt]) of

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 40

2340 (19871)       'r':  t0[spnt]:=packed('t',low(t0[spnt]));
2341 (19895)       's':  t0[spnt]:=packed('u',low(t0[spnt]))
2342 (19923)     end {case};
2343 (19931)     testto(' ;'); scan
2344 (19940)   end {procedure of function};
2345 (19944) 
2346 (19947)   testto('be');     { * begin * }
2347 (19956)   if forwpn<>0 then merror(13,'ur');
2348 (19977)   fixup(t2[bottom]);
2349 (19991)   t2[bottom]:=pc;
2350 (19995)   scan;
2351 (20007)   code3(35,2*dpnt);
2352 (20022)   repeat
2353 (20022)     statmnt
2354 (20022)   until token='en';
2355 (20033)   scan;
2356 (20041)   if level>0 then code1(1) else code1(0);
2357 (20070)   stackpnt:=stackpn1;
2358 (20070) end {block};
2359 (20078) 
2360 (20079) { * savtable *    ( global) }
2361 (20079) 
2362 (20079) proc savtable; { save lib table in @ofno }
2363 (20079) 
2364 (20079) var i,j,num: integer;
2365 (20082)     vtype1: char;
2366 (20082) 
2367 (20082) begin
2368 (20082)   writeln(@ofno,spnt,',',pc+2);
2369 (20111)   for i:=1 to spnt do begin {for every entry }
2370 (20130)     for j:=1 to 8 do begin
2371 (20147)       write(@ofno,idtab[8*i+j])
2372 (20167)     end;
2373 (20171)     writeln(@ofno,',',t0[i],',',t1[i],',',
2374 (20218)       t2[i],',',t3[i]);
2375 (20245)     vtype1:=high(t0[i]);
2376 (20253)     if ((vtype1='p') or (vtype1='f') or
2377 (20272)       (vtype1='g')) and (t3[i]<>0) then begin
2378 (20293)       num:=stack[t3[i]];
2379 (20304)       write(@ofno,num);
2380 (20323)       for j:=1 to num do
2381 (20329)         write(@ofno,',',stack[t3[i]+j]);
2382 (20368)       write(@ofno,cr,lf);
2383 (20394)     end {then};
2384 (20394)   end {for}
2385 (20394) end {savtable};
2386 (20408) 
2387 (20409) { * main program * }
2388 (20409) 
2389 (20409) begin {main}
2390 (20409)   nlflg:=false;
2391 (20414)   init;scan;
2392 (20426)   case token of
2393 (20426)     'pg': begin
2394 (20438)             libflg:=false;
2395 (20440)             asetfile(pname,scyclus,sdrive,'Q');
2396 (20466)           end;
2397 (20466)     'li': begin
2398 (20477)             libflg:=true;
2399 (20479)             asetfile(pname,scyclus,sdrive,'T');

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 41

2400 (20505)           end
2401 (20505)     else
2402 (20505)       merror(2,'pg')
2403 (20513)   end {case}
2404 (20521)   parse('id');
2405 (20530)   i:=0;
2406 (20532)   repeat
2407 (20536)     i:=succ(i);
2408 (20540)   until (i>7) or (pname[i] = ':') or
2409 (20563)       (pname[i]<>uppercase(ident[i+1]));
2410 (20592)   if i<8 then
2411 (20602)     merror(2,packed(pname[0],pname[1]));
2412 (20627)     { name differs from filename }
2413 (20627)   parse(' ;');
2414 (20636)   if ofno<>nooutput then openw(ofno);
2415 (20652)   scan;
2416 (20656)   if (token='us') and (libflg=false) then begin
2417 (20672)     repeat
2418 (20675)       getlib; scan
2419 (20679)     until token<>' ,';
2420 (20690)     testto(' ;'); scan
2421 (20703)   end;
2422 (20707)   block(0); testto(' .');
2423 (20724)   if ofno<>nooutput then begin
2424 (20731)     write(@ofno,'E');
2425 (20742)     savebyte(pc and 255);
2426 (20755)     savebyte(pc shr 8);
2427 (20768)     close(ofno);
2428 (20774)     if libflg then begin
2429 (20778)       asetfile(pname,scyclus,sdrive,'L');
2430 (20803)       openw(ofno);
2431 (20809)       savtable;
2432 (20813)       close(ofno)
2433 (20813)     end
2434 (20819)   end else
2435 (20819)     runerr:=$87; {no loader file}
2436 (20828)   writeln;
2437 (20828)   writeln;
2438 (20834)   writeln('End compile');
2439 (20858)   writeln;
2440 (20858)   writeln('Code lenght:          ',pc);
2441 (20898)   writeln('Compiler stack size:  ',stackmax);
2442 (20932)   writeln('Ident stack size:     ',spntmax);
2443 (20966)   write('Pascal errors:        ');
2444 (20989)   if numerr>0 then write(invvid);
2445 (21002)   writeln(numerr,norvid);
2446 (21016)   if prt then begin
2447 (21020)     write(prtoff);
2448 (21026)     setemucom(9);
2449 (21034)   end;
2450 (21034)   close(fno);
2451 (21040)   { check whether second pass is not required }
2452 (21040)   if (runerr=0) and libflg then runerr:=-1;
2453 (21056) end {main}.
2454 (21061) 

End compile

Code lenght:          21060
Compiler stack size:  136
Ident stack size:     216
Pascal errors:        0
