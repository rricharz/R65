
R65 COMPILE 4.4: program COMPILE1         1/3/26 page 1


   1 (    4) {   ********************************
   2 (    4)     *                              *
   3 (    4)     *  R65 "Tiny" Pascal Compiler  *
   4 (    4)     *            Pass 1            *
   5 (    4)     *                              *
   6 (    4)     ********************************
   7 (    4) 
   8 (    4) First version 1978 by rricharz
   9 (    4) Version 3.7 (20K)  01/08/82 rricharz
  10 (    4) 
  11 (    4) Recovered 2018 by rricharz (r77@bluewin.ch)
  12 (    4) Improved 2018-2024 by rricharz
  13 (    4) Version 4 with cpnt strings and exit statement
  14 (    4) Version 4.3 with include compiler directive
  15 (    4) 
  16 (    4) Original derived from the publication by
  17 (    4) Kin-Man Chung and Herbert Yen in
  18 (    4) Byte, Volume 3, Number 9 and Number 10, 1978
  19 (    4) 
  20 (    4) Adapted for the R65 computer system and
  21 (    4) substantially enhanced by rricharz 1978-2023
  22 (    4) 
  23 (    4) This is a Pascal derivative optimized for 8-bit
  24 (    4) microprocessors (integer type is 16 bit) with
  25 (    4) additional features (mem) to interact directly
  26 (    4) with the microprocessor hardware. Only one
  27 (    4) dimensional arrays and no records or user
  28 (    4) defined types. Floating point numbers (real)
  29 (    4) and file io to floppy disks are supported.
  30 (    4) 
  31 (    4) Precompiled libraries are merged in the loader.
  32 (    4) The table of reserved words and the library
  33 (    4) tables are loaded from the same drive as
  34 (    4) the compiler.
  35 (    4) 
  36 (    4) The output of the program is a loader file for
  37 (    4) the Pascal loader (compile2).
  38 (    4) 
  39 (    4) usage:
  40 (    4)  compile1 name[.cy[,drv]] [xxx]
  41 (    4)   where x:       l,p: no hard copy print
  42 (    4)                  i,r: index bound checking
  43 (    4)                  n: no loader file
  44 (    4)   [] means not required
  45 (    4) 
  46 (    4) The compiler uses 2 fixed memory areas to store
  47 (    4) the table of reserved words and the table of
  48 (    4) idents. The top of the Pascal stack (endstk) is
  49 (    4) adjusted accordingly. The reason for this hack
  50 (    4) is speed and convenience. A normal Pascal array
  51 (    4) of chars would store the chars as 16 bit
  52 (    4) numers and would therefore require twice the
  53 (    4) space. An array of packed chars would require
  54 (    4) more coding and slow the scanner module of the
  55 (    4) compiler down.                                }
  56 (    4) 
  57 (    4) program compile1;
  58 (    4) 
  59 (    4) uses syslib, arglib;

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 2

  60 ( 1093) 
  61 ( 1093) const version='4.4';
  62 ( 1100) 
  63 ( 1100)     table     =$97ff; {user ident table -1}
  64 ( 1100)     idtab     =$95ff; {resword table -1}
  65 ( 1100)     idlength  =64;    {max. length of ident}
  66 ( 1100)     stacksize =256;   {stack size}
  67 ( 1100)     pagelenght=60;    {no of lines per page}
  68 ( 1100)     nooutput  =@0;
  69 ( 1100)     maxfi     =3;     {max number of ins fls}
  70 ( 1100) 
  71 ( 1100)     nresw=63;   {number of res. words, max 64}
  72 ( 1100)     symbsize=256;     {id table entries}
  73 ( 1100)     reswtabpos=$c600; { up to $c7ff }
  74 ( 1100)     idtabpos=$be00;   { up to $c5ff }
  75 ( 1100) 
  76 ( 1100)     yesoutput=@255;
  77 ( 1100) 
  78 ( 1100) mem endstk  =$000e: integer;
  79 ( 1100)     reswtab =reswtabpos: array[$200] of char&;
  80 ( 1100)     idtab   =idtabpos: array[$800] of char&;
  81 ( 1100) 
  82 ( 1100) var tpos,pc,level,line,offset,dpnt,spnt,fipnt,
  83 ( 1100)     npara,i,stackpnt,stackmax,spntmax,numerr,
  84 ( 1100)     lineinc,linepage                 :integer;
  85 ( 1100) 
  86 ( 1100)     scyclus,sdrive,cdrive: integer;
  87 ( 1100) 
  88 ( 1100)     pname: array[15] of char;
  89 ( 1100) 
  90 ( 1100)     value: array[1] of integer;
  91 ( 1100) 
  92 ( 1100)     ch,restype,vartype:char;
  93 ( 1100) 
  94 ( 1100)     token: packed char;
  95 ( 1100) 
  96 ( 1100)     prt,libflg,icheck,ateof,lineflg,nlflg: boolean;
  97 ( 1100) 
  98 ( 1100)     fno,ofno,savefno: file;
  99 ( 1100) 
 100 ( 1100)     filstk: array[maxfi] of file;
 101 ( 1100) 
 102 ( 1100)     ident: array[idlength] of char;
 103 ( 1100)     { Only the first 8 characters are
 104 ( 1100)       used to find and differentiate ids }
 105 ( 1100) 
 106 ( 1100)     t0: array[symbsize] of packed char;
 107 ( 1100)            {type of symbol}
 108 ( 1100) 
 109 ( 1100)         {High letter:
 110 ( 1100)          a:array, c:constant, d;const parameter
 111 ( 1100)          e:constant array parameter, f:function
 112 ( 1100)          g:array function, h;8-bit memory var
 113 ( 1100)          i:8-bit array memory variable
 114 ( 1100)          m:16-bit memory variable
 115 ( 1100)          n:16-bit array memory variable
 116 ( 1100)          p:procedure
 117 ( 1100)          q:indexed cpnt
 118 ( 1100)          r,t:function result
 119 ( 1100)          s,u:array function result

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 3

 120 ( 1100)          v:variable, w:variable parameter
 121 ( 1100)          x:variable array parameter
 122 ( 1100) 
 123 ( 1100)          Low letter:
 124 ( 1100)          i:integer, c:char, p:packed char
 125 ( 1100)          q:cpnt (pointer to chars)
 126 ( 1100)          r:real(array multiple of two)
 127 ( 1100)          s:const cpnt
 128 ( 1100)          f:file, b:boolean, u:undefined  }
 129 ( 1100) 
 130 ( 1100)     t1: array[symbsize] of integer;
 131 ( 1100)          {level}
 132 ( 1100)     t2: array[symbsize] of integer;
 133 ( 1100)          {val,dis,addr}
 134 ( 1100)     t3: array[symbsize] of integer;
 135 ( 1100)          {stack pointer,size of array}
 136 ( 1100) 
 137 ( 1100)     reswcod:array[nresw] of packed char;
 138 ( 1100) 
 139 ( 1100)     stack: array[stacksize] of integer;
 140 ( 1100) 
 141 ( 1100) 
 142 ( 1100) {       * savebyte *    (global)        }
 143 ( 1100) 
 144 ( 1100) proc savebyte(x: integer);
 145 ( 1100) 
 146 ( 1100) begin
 147 ( 1100)     if ofno<>nooutput then begin
 148 ( 1112)       write(@ofno,
 149 ( 1115)         chr(((x and 255) shr 4)+ord('0')));
 150 ( 1136)       write(@ofno,chr((x and 15)+ord('0')))
 151 ( 1151)     end
 152 ( 1154) end {savebyte};
 153 ( 1154) 
 154 ( 1155) {       * crlf *        (global)        }
 155 ( 1155) 
 156 ( 1155) proc newpage; forward;
 157 ( 1158) 
 158 ( 1158) proc crlf;
 159 ( 1158)   var i: integer;
 160 ( 1161) begin
 161 ( 1161)   writeln;
 162 ( 1163)   line:=succ(line); lineinc:=succ(lineinc);
 163 ( 1182)   linepage:=succ(linepage);
 164 ( 1191)   if ((linepage div pagelenght)
 165 ( 1202)     * pagelength)=linepage then newpage;
 166 ( 1218) end {crlf};
 167 ( 1218) 
 168 ( 1219) {       error message   (global)        }
 169 ( 1219) 
 170 ( 1219) proc merror(x: integer; code: packed char);
 171 ( 1219) 
 172 ( 1219) var i: integer;
 173 ( 1222)     answer: char;
 174 ( 1222) 
 175 ( 1222) begin
 176 ( 1222)   crlf; numerr:=succ(numerr);
 177 ( 1232)   for i:=2 to tpos do write(' ');
 178 ( 1258)   write('^'); crlf;
 179 ( 1278)   write('*** (',numerr,',',pc,')   ');

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 4

 180 ( 1301)   case x of
 181 ( 1301)     01: write('Ident');
 182 ( 1318)     02: write('Ident ',code,' expected');
 183 ( 1354)     03: write('Var declaration');
 184 ( 1380)     04: write('Const expected');
 185 ( 1405)     05: write('Ident unknown');
 186 ( 1429)     06: write('Cannot be assigned');
 187 ( 1458)     07: write('Symbol table overflow');
 188 ( 1490)     08: write('Stack overflow');
 189 ( 1515)     09: write('Expression');
 190 ( 1536)     10: write('Statement');
 191 ( 1556)     11: write('Declaration');
 192 ( 1578)     12: write('Constant');
 193 ( 1597)     13: write('Forward reference: ',code);
 194 ( 1636)     14: write('Type mismatch: ',code);
 195 ( 1671)     15: write('Array size');
 196 ( 1692)     16: write('Array (8-bit)');
 197 ( 1716)     17: write('Real');
 198 ( 1731)     18: write('File table overflow');
 199 ( 1761)     19: write('Parameter');
 200 ( 1781)     20: write('Compiler directive syntax');
 201 ( 1817)     21: write('Nested include files');
 202 ( 1848)     22: write('Unexpected eof')
 203 ( 1873)   end {case};
 204 ( 1875)   writeln;
 205 ( 1875)   write('Continue?');
 206 ( 1891)   read(@key,answer);
 207 ( 1899)   if answer<>'Y' then begin
 208 ( 1907)     crlf; write(prtoff); setemucom(9); close(fno);
 209 ( 1931)     if (ofno<>nooutput) and (ofno<>yesoutput)
 210 ( 1944)       then close(ofno);
 211 ( 1955)     writeln('Aborting compile1 on request');
 212 ( 1990)     abort
 213 ( 1990)   end
 214 ( 1994)   else crlf;
 215 ( 2001)   if (ofno<>nooutput) and (ofno<>yesoutput)
 216 ( 2014)     then close(ofno);
 217 ( 2025)   ofno:=nooutput;
 218 ( 2027) end {merror};
 219 ( 2031) 
 220 ( 2032) proc error(x: integer);
 221 ( 2032) 
 222 ( 2032) begin
 223 ( 2032)   merror(x,'##')
 224 ( 2044) end;
 225 ( 2050) 
 226 ( 2051) {       * push & pop *  (global) }
 227 ( 2051) 
 228 ( 2051) proc push(x: %integer);
 229 ( 2051) 
 230 ( 2051) begin
 231 ( 2051)   if stackpnt>=stacksize then error(8)
 232 ( 2069)   else stackpnt:=succ(stackpnt);
 233 ( 2082)   if stackpnt>stackmax then stackmax:=stackpnt;
 234 ( 2099)   stack[stackpnt]:=x;
 235 ( 2116) end {push};
 236 ( 2124) 
 237 ( 2125) func pop: integer;
 238 ( 2125) 
 239 ( 2125) begin

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 5

 240 ( 2125)   pop:=stack[stackpnt];
 241 ( 2139)   stackpnt:=prec(stackpnt)
 242 ( 2147) end {pop};
 243 ( 2156) 
 244 ( 2157) {       * newpage *     (global) }
 245 ( 2157) 
 246 ( 2157) proc newpage;
 247 ( 2157) 
 248 ( 2157) var i: integer;
 249 ( 2160) 
 250 ( 2160) begin
 251 ( 2160)   if ((linepage)<>0) and prt then
 252 ( 2169)     write(@printer,formfeed);
 253 ( 2184)   writeln; { Do not count this line}
 254 ( 2190)   if pname[0]<>'x' then begin
 255 ( 2204)     write('R65 COMPILE ');
 256 ( 2220)     write(version);
 257 ( 2225)     if libflg then write(': library ')
 258 ( 2243)     else write(': program ');
 259 ( 2257)     prtext16(output,pname);
 260 ( 2271)   end;
 261 ( 2271)   write(' ');
 262 ( 2273)   prtdate(output);
 263 ( 2281)   writeln(' page ',
 264 ( 2288)     (linepage div pagelenght)+1);
 265 ( 2305)   writeln;
 266 ( 2305) end {newpage};
 267 ( 2311) 
 268 ( 2312) {        * code1 *      (global) }
 269 ( 2312) 
 270 ( 2312) proc code1(x: %integer);  {set one byte p-code}
 271 ( 2312) begin
 272 ( 2312)   savebyte(x); pc:=succ(pc)
 273 ( 2327) end;
 274 ( 2336) 
 275 ( 2337) {       * writenum *      (global) }
 276 ( 2337) 
 277 ( 2337) proc writenum(i: integer);
 278 ( 2337) begin
 279 ( 2337)   if i<=999 then write(' ');
 280 ( 2355)   if i<=99 then write(' ');
 281 ( 2367)   if i<=9 then write(' ');
 282 ( 2379)   write(i);
 283 ( 2384) end;
 284 ( 2384) 
 285 ( 2385) {       * nextline *      (global) }
 286 ( 2385) 
 287 ( 2385) proc nextline;
 288 ( 2385) begin
 289 ( 2385)   nlflg:=true;
 290 ( 2392)   if savefno=@0 then writenum(line)
 291 ( 2406)   else begin
 292 ( 2419)     write('{I} ');
 293 ( 2424)     line:=line-1; { do not count line }
 294 ( 2435)     writenum(lineinc);
 295 ( 2445)   end;
 296 ( 2445)   write(' (');
 297 ( 2448)   if (pc+2)<9999 then write(' ');
 298 ( 2464)   writenum(pc+2); write(') ');
 299 ( 2480) end;

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 6

 300 ( 2480) 
 301 ( 2481) {       * getchr *      (global) }
 302 ( 2481) 
 303 ( 2481) proc getchr;
 304 ( 2481) begin
 305 ( 2481)   if ateof then begin
 306 ( 2490)     if savefno<>@0 then begin
 307 ( 2500)       { end of include file, close it }
 308 ( 2503)       close(fno);
 309 ( 2509)       fno:=savefno;
 310 ( 2509)       { switch back to normal input file }
 311 ( 2517)       savefno:=@0;
 312 ( 2519)       ateof:=false;
 313 ( 2525)       if ch=cr then ch:=' ';
 314 ( 2541)     end else begin
 315 ( 2548)       error(22);
 316 ( 2556)       abort
 317 ( 2556)     end
 318 ( 2560)   end else begin
 319 ( 2563)     read(@fno,ch);
 320 ( 2573)     if ch=cr then begin
 321 ( 2581)       crlf;
 322 ( 2588)       nextline;
 323 ( 2592)       ch:=' ';
 324 ( 2594)     end {if}
 325 ( 2598)     else if ch=eof then begin
 326 ( 2608)       ateof:=true;
 327 ( 2613)       { we need to suppy one more char }
 328 ( 2617)       { for end. at end of file to work properly }
 329 ( 2617)       ch:=' ';
 330 ( 2619)     end {else if}
 331 ( 2623)     else write(ch);
 332 ( 2631)   end;
 333 ( 2631) end {getchr};
 334 ( 2631) 
 335 ( 2632) {       * splitconv *   (global) }
 336 ( 2632) 
 337 ( 2632) proc splitconv(a: array[1] of %integer;
 338 ( 2632)   var b:array[1] of %integer);
 339 ( 2632) 
 340 ( 2632) begin
 341 ( 2632)   b:=a;
 342 ( 2637) end;
 343 ( 2649) 
 344 ( 2650) {       * init *        (global) }
 345 ( 2650) 
 346 ( 2650) proc init;
 347 ( 2650) 
 348 ( 2650) const char96=chr(20);
 349 ( 2653) 
 350 ( 2653) var i,j,dummy: integer;
 351 ( 2653)     dch: char;
 352 ( 2653)     pch: packed char;
 353 ( 2653)     request: array[15] of char;
 354 ( 2653)     default: boolean;
 355 ( 2653) 
 356 ( 2653) begin {init}
 357 ( 2653)   writeln('R65 PASCAL COMPILER version ', version,
 358 ( 2687)     ', Pass  1');
 359 ( 2705)   ateof:=false; savefno:=@0;

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 7

 360 ( 2713)   cdrive:=fildrv; { drive of compile program }
 361 ( 2724)   fipnt:=-1;
 362 ( 2726)   endstk:=idtabpos-144;
 363 ( 2736)   pc:=2; dpnt:=0; spnt:=0; offset:=2;
 364 ( 2760)   npara:=0; level:=0;
 365 ( 2772)   stackpnt:=0; libflg:=false;
 366 ( 2784)   stackmax:=0;spntmax:=0; numerr:=0;
 367 ( 2802)   t0[0]:='vi'; t1[0]:=0; t2[0]:=0; t3[0]:=0;
 368 ( 2855)   { prepare resword table }
 369 ( 2859)   writeln('Reading list of reserved words');
 370 ( 2896)   asetfile('RESWORDS:W      ',0,cdrive,'W');
 371 ( 2928)   openr(fno);
 372 ( 2934)   for i:=0 to nresw do begin
 373 ( 2951)     read(@fno,pch,dch);
 374 ( 2968)     reswcod[i]:=pch;
 375 ( 2978)     for j:=0 to 7 do reswtab[8*i+j]:=' ';
 376 ( 3022)     j:=0;
 377 ( 3045)     while (j<8) and (dch<>cr) do begin
 378 ( 3067)       read(@fno,dch);
 379 ( 3077)       if (dch<>cr) then
 380 ( 3085)         reswtab[8*i+j]:=dch;
 381 ( 3105)       j:=succ(j)
 382 ( 3116)     end;
 383 ( 3125)     while (dch<>cr) and (dch<>eof) do
 384 ( 3142)       read(@fno,dch)
 385 ( 3151)   end;
 386 ( 3160)   close(fno);
 387 ( 3180) 
 388 ( 3180)   writeln;
 389 ( 3180) 
 390 ( 3186)   sdrive:=1; {default drive for source }
 391 ( 3192)   scyclus:=0;
 392 ( 3194)   agetstring(pname,default,scyclus,sdrive);
 393 ( 3238) 
 394 ( 3238)   agetstring(request,default,dummy,dummy);
 395 ( 3278)   icheck:=false;
 396 ( 3280)   prt:=true; ofno:=yesoutput; lineflg:=false;
 397 ( 3298)   if not default then begin
 398 ( 3307)     if request[0]<>'/' then argerror(103);
 399 ( 3335)     for i:=1 to 8 do
 400 ( 3343)       case request[i] of
 401 ( 3361)         'P': prt:=false;
 402 ( 3374)         'L': lineflg:=true;
 403 ( 3390)         'I','R': icheck:=true;
 404 ( 3413)         'N': ofno:=nooutput;
 405 ( 3429)         ' ': begin end
 406 ( 3443)         else argerror(104)
 407 ( 3448)       end; {case}
 408 ( 3470)   end;
 409 ( 3470) 
 410 ( 3470)   asetfile(pname,scyclus,sdrive,'P');
 411 ( 3492)   openr(fno);
 412 ( 3498)   scyclus:=filcyc; { may have changed }
 413 ( 3506) 
 414 ( 3506)   {save cyclus and drive for compile2}
 415 ( 3506)   arglist[8]:=scyclus;
 416 ( 3513)   arglist[9]:=sdrive;
 417 ( 3532)   numarg:=1;
 418 ( 3546) 
 419 ( 3550)   if prt then begin

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 8

 420 ( 3554)     write(prton);
 421 ( 3560)     setemucom(8);
 422 ( 3568)   end
 423 ( 3568) 
 424 ( 3568)   line:=0; lineinc:=0; linepage:=0;
 425 ( 3582)   newpage; crlf; line:=1; linepage:=1;
 426 ( 3602)   write('   1 (    4) '); getchr
 427 ( 3620) end {init};
 428 ( 3624) 
 429 ( 3625) 
 430 ( 3625) { ############################# }
 431 ( 3625) {       *scan*              (global)    }
 432 ( 3625) { ############################# }
 433 ( 3625) { scan input and make tokens }
 434 ( 3625) 
 435 ( 3625) proc scan;
 436 ( 3625) 
 437 ( 3625) var count,ll,hh,i,i1,co: integer;
 438 ( 3628)     name: array[7] of char;
 439 ( 3628) 
 440 ( 3628) {       * compresw*     (of scan)       }
 441 ( 3628) 
 442 ( 3628) func compresw(index: integer);
 443 ( 3628) 
 444 ( 3628) var addr,ci,i: integer;
 445 ( 3631) 
 446 ( 3631) begin
 447 ( 3631)   addr:=8*index; i:=0;
 448 ( 3646)   repeat
 449 ( 3650)     ci:=ord(ident[i+1])-ord(reswtab[addr+i]);
 450 ( 3685)     i:=succ(i)
 451 ( 3690)   until (ci<>0) or (i>=8);
 452 ( 3713)   compresw:=ci
 453 ( 3717) end {compresw};
 454 ( 3725) 
 455 ( 3726) {       * clear *       (of scan)              }
 456 ( 3726) 
 457 ( 3726) proc clear; {clears 8 chars of identifier}
 458 ( 3726) 
 459 ( 3726) var i: integer;
 460 ( 3729) 
 461 ( 3729) begin
 462 ( 3729)   for i:=1 to 8 do ident[i]:=' '
 463 ( 3757) end;
 464 ( 3777) 
 465 ( 3778) {       * pack *        (of scan)              }
 466 ( 3778) 
 467 ( 3778) proc pack;  {packs token and ch to token }
 468 ( 3778) 
 469 ( 3778) begin
 470 ( 3778)   token:=packed(low(token),ch); getchr
 471 ( 3797) end;
 472 ( 3801) 
 473 ( 3802) {       * setval *      (of scan)              }
 474 ( 3802) 
 475 ( 3802) proc setval;
 476 ( 3802) 
 477 ( 3802) var r: real;
 478 ( 3805)     n,n1: integer;
 479 ( 3805)     ems: boolean;

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 9

 480 ( 3805) 
 481 ( 3805)   func times10(r:real):real;
 482 ( 3805)   { slightly more accurate than 10.0*r }
 483 ( 3805)   var r2,r4:real;
 484 ( 3808)   begin
 485 ( 3808)     r2:=r+r;
 486 ( 3816)     r4:=r2+r2;
 487 ( 3835)     times10:=r2+r4+r4;
 488 ( 3861)   end;
 489 ( 3874) 
 490 ( 3875) begin
 491 ( 3875)   r:=0.0;
 492 ( 3883)   repeat
 493 ( 3889)     r:=times10(r)+conv(ord(ch)-ord('0'));
 494 ( 3910)     getchr;
 495 ( 3922)   until (ch<'0') or (ch>'9');
 496 ( 3936)   if ch<>'.' then begin {numeric integer}
 497 ( 3950)     token:='nu';
 498 ( 3953)     value[0]:=trunc(r+0.5);
 499 ( 3977)   end
 500 ( 3982)   else begin {numeric real}
 501 ( 3985)     n:=0; getchr;
 502 ( 3995)     while (ch<='9') and (ch>='0') do begin
 503 ( 4013)       r:=times10(r)+conv(ord(ch)-ord('0'));
 504 ( 4034)       n:=prec(n); getchr
 505 ( 4051)     end;
 506 ( 4055)     if ch='e' then begin
 507 ( 4065)       ems:=false; getchr;
 508 ( 4078)       case ch of
 509 ( 4078)         '+': getchr;
 510 ( 4093)         '-': begin ems:=true; getchr end
 511 ( 4113)       end;
 512 ( 4115)       if (ch>'9') or (ch<'0') then error(17)
 513 ( 4135)       else begin
 514 ( 4144)         n1:=ord(ch)-ord('0');
 515 ( 4150)         getchr;
 516 ( 4159)         if (ch<='9') and (ch>='0') then begin
 517 ( 4174)           n1:=10*n1+ord(ch)-ord('0');
 518 ( 4191)           getchr
 519 ( 4196)         end;
 520 ( 4200)         if ems then n:=n-n1 else n:=n+n1
 521 ( 4227)       end
 522 ( 4227)     end;
 523 ( 4236)     while n>0 do begin
 524 ( 4246)       n:=prec(n);
 525 ( 4250)       r:=times10(r);
 526 ( 4269)     end;
 527 ( 4275)     while n<0 do begin
 528 ( 4288)       n:=succ(n); r:=0.1*r;
 529 ( 4303)     end;
 530 ( 4316)     splitconv(r,value);
 531 ( 4343)     token:='ru'
 532 ( 4343)   end
 533 ( 4346) end {setval};
 534 ( 4350) 
 535 ( 4351) {       * directive *   (of scan               }
 536 ( 4351) 
 537 ( 4351) proc directive;
 538 ( 4351) var i,icyclus:integer;
 539 ( 4354)     name: array[15] of char;

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 10

 540 ( 4354) begin
 541 ( 4354)   getchr;
 542 ( 4360)   case ch of
 543 ( 4360)     'I': begin
 544 ( 4371)            if savefno<>@0 then error(21);
 545 ( 4389)            getchr; if ch<>' ' then error(20);
 546 ( 4411)            i:=0; getchr;
 547 ( 4421)            while (ch<>'}') and (i<16) do begin
 548 ( 4439)              name[i]:=ch; i:=i+1; getchr;
 549 ( 4471)            end;
 550 ( 4471)            while (i<16) do begin
 551 ( 4484)              name[i]:=' '; i:=i+1;
 552 ( 4505)            end;
 553 ( 4510)            icyclus:=0;
 554 ( 4515)            asetfile(name,icyclus,sdrive,'P');
 555 ( 4541)            savefno:=fno;
 556 ( 4541)            openr(fno);
 557 ( 4555)            lineinc:=0;
 558 ( 4557)            crlf;
 559 ( 4565)            nextline;
 560 ( 4569)            getchr; scan;
 561 ( 4577)          end
 562 ( 4577)     else error(20)
 563 ( 4582)   end {case}
 564 ( 4590) end;
 565 ( 4590) 
 566 ( 4591) {       * setid *       (of scan)              }
 567 ( 4591) 
 568 ( 4591) proc setid; {sets one char to ident}
 569 ( 4591) 
 570 ( 4591) begin
 571 ( 4591)   if count<=idlength then begin
 572 ( 4603)     ident[count]:=ch; count:=succ(count)
 573 ( 4623)   end;
 574 ( 4632)   getchr;
 575 ( 4636) end {setid};
 576 ( 4636) 
 577 ( 4637) begin { ***** body of scan ***** }
 578 ( 4637)   count:=1; while ch=' ' do getchr;
 579 ( 4659)   tpos:=curpos;
 580 ( 4665) 
 581 ( 4669)   { delayed because of token lookahead }
 582 ( 4669)   if nlflg then begin
 583 ( 4673)     if lineflg and (pc>2) then begin
 584 ( 4688)       code1($59);
 585 ( 4699)       code1((line) and 255);
 586 ( 4712)       code1((line) shr 8);
 587 ( 4725)     end;
 588 ( 4725)     nlflg:=false;
 589 ( 4727)   end;
 590 ( 4731) 
 591 ( 4731)   if (ch<'a') or (ch>'z') then begin {main if}
 592 ( 4749)     if (ch<'0') or (ch>'9') then begin {symb}
 593 ( 4767)       token:=packed(' ',ch); getchr;
 594 ( 4782)       case low(token) of
 595 ( 4786)         '<': if (ch='=') or (ch='>') then pack;
 596 ( 4816)         '>',':': if (ch='=') then pack;
 597 ( 4847)         '{': begin
 598 ( 4857)                if ch='$' then directive
 599 ( 4864)                else begin

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 11

 600 ( 4874)                  if ch<>'}' then
 601 ( 4880)                  repeat getchr until ch='}';
 602 ( 4894)                  getchr; scan
 603 ( 4902)                end
 604 ( 4906)              end;
 605 ( 4906)         '$': begin {hex constant}
 606 ( 4916)                token:='nu'; value[0]:=0;
 607 ( 4932)                while ((ch>='0')and(ch<='9'))
 608 ( 4950)                      or((ch>='a')and(ch<='f'))
 609 ( 4965)                      do begin
 610 ( 4970)                  if ch>'9' then
 611 ( 4976)                    value[0]:=(value[0] shl 4)
 612 ( 5000)                      +ord(ch)-ord('a')+10
 613 ( 5009)                  else
 614 ( 5011)                    value[0]:=(value[0] shl 4)
 615 ( 5039)                      +ord(ch)-ord('0');
 616 ( 5047)                  getchr
 617 ( 5052)                end {do}
 618 ( 5056)              end; {hex constant}
 619 ( 5062)         chr(39): begin {string}
 620 ( 5069)                token:='st';
 621 ( 5072)                repeat setid until ch=chr(39);
 622 ( 5086)                value[0]:=prec(count); getchr
 623 ( 5107)               end
 624 ( 5111)       end {case of token}
 625 ( 5113)     end {special symbols}
 626 ( 5113)     else setval {numeric value}
 627 ( 5120)   end {main if}
 628 ( 5120)   else begin {ident}
 629 ( 5123)     clear;
 630 ( 5127)     repeat
 631 ( 5127)       setid
 632 ( 5127)       until (ch<'0') or (ch>'z') or
 633 ( 5145)         ((ch>'9') and (ch<'A')) or
 634 ( 5161)         ((ch>'Z') and (ch<'a'));
 635 ( 5177)     ll:=0; hh:=nresw; {look up in resword table}
 636 ( 5193)     repeat
 637 ( 5193)       i:=(ll+hh) shr 1; co:=compresw(i);
 638 ( 5221)       if (co<0) then hh:=prec(i)
 639 ( 5235)       else ll:=succ(i);
 640 ( 5251)       until (co=0) or (ll>hh);
 641 ( 5272)     if (co=0) then
 642 ( 5283)       token:=reswcod[i] {reserved word found}
 643 ( 5295)     else token:='id' {ident}
 644 ( 5309)   end {odent}
 645 ( 5313) end {scan};
 646 ( 5313) 
 647 ( 5314) { * testto/parse * }
 648 ( 5314) 
 649 ( 5314) { parce source for specific token; else error }
 650 ( 5314) 
 651 ( 5314) proc testto(x: packed char); { current token }
 652 ( 5314) begin
 653 ( 5314)   if token<>x then merror(2,x)
 654 ( 5333) end;
 655 ( 5343) 
 656 ( 5344) proc parse(x: packed char); { next token }
 657 ( 5344) begin
 658 ( 5344)   scan; testto(x);
 659 ( 5363) end;

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 12

 660 ( 5363) 
 661 ( 5364) { * getlib * }
 662 ( 5364) 
 663 ( 5364) proc getlib;  { read library data }
 664 ( 5364) 
 665 ( 5364) var i,j,nent,addr,size,num,x,base: integer;
 666 ( 5367)     libfil: file;
 667 ( 5367)     ch,ltyp2,dummy: char;
 668 ( 5367)     name: array[7] of char;
 669 ( 5367) 
 670 ( 5367) begin
 671 ( 5367)   scan; if token=' ,' then scan;
 672 ( 5388)   testto('id');
 673 ( 5397)   base:=pc-2;
 674 ( 5403)   if (ofno<>nooutput) then write(@ofno,'L');
 675 ( 5426)   for i:=0 to 7 do begin
 676 ( 5443)     name[i]:=ident[succ(i)];
 677 ( 5462)     if ofno<>nooutput then
 678 ( 5476)       write(@ofno,ident[succ(i)])
 679 ( 5495)   end;
 680 ( 5501)   write(prtoff);
 681 ( 5518)   asetfile(name&'        ',0,cdrive,'L');
 682 ( 5548)   openr(libfil);  { get table file }
 683 ( 5554)   read(@libfil,nent,size);
 684 ( 5569)   {including cr,lf}
 685 ( 5570)   for i:=succ(spnt) to spnt+nent do begin
 686 ( 5597)     if spnt>symbsize then error(7);
 687 ( 5616)     spnt:=succ(spnt); addr:=8*i+1;
 688 ( 5634)     for j:=0 to 7 do begin
 689 ( 5656)       read(@libfil,ch);
 690 ( 5666)       idtab[addr+j]:=ch
 691 ( 5681)     end;
 692 ( 5692)     read(@libfil,ch);
 693 ( 5716)     read(@libfil,t0[i],dummy,t1[i],t2[i],t3[i]);
 694 ( 5785)     t1[i]:=t1[i]+level;
 695 ( 5808)     ltyp2:=high(t0[i]);
 696 ( 5830)     if (ltyp2='p')or(ltyp2='f')
 697 ( 5848)       or(ltyp2='g') then begin
 698 ( 5858)       t2[i]:=t2[i]+base;
 699 ( 5883)       if t3[i]<>0 then begin {stack data}
 700 ( 5911)         read(@libfil,num);
 701 ( 5921)         push(num); t3[i]:=stackpnt;
 702 ( 5941)         for j:=1 to num do begin
 703 ( 5968)           read(@libfil,x);
 704 ( 5978)           push(x);
 705 ( 5989)         end {for j};
 706 ( 5989)       end {stack data}
 707 ( 6003)     end {if ltyp2}
 708 ( 6003)   end {for i}
 709 ( 6003)   level:=succ(level); pc:=pc+size; offset:=pc;
 710 ( 6039)   close(libfil);
 711 ( 6053)   if spnt>spntmax then spntmax:=spnt;
 712 ( 6065)   if stackpnt>stackmax then stackmax:=stackpnt;
 713 ( 6085)   if prt then write(prton);
 714 ( 6103) end {getlib};
 715 ( 6103) 
 716 ( 6104) 
 717 ( 6104) { #################################### }
 718 ( 6104) {       * block * (global): handle one block }
 719 ( 6104) { #################################### }

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 13

 720 ( 6104) 
 721 ( 6104) 
 722 ( 6104) proc block(bottom: integer);
 723 ( 6104) 
 724 ( 6104) var l,f9,i,n,stackpn1,forwpn,find,cproc,
 725 ( 6107)     spnt1,dpnt1,parlevel: integer;
 726 ( 6107)     fortab: array[8] of integer;
 727 ( 6107) 
 728 ( 6107) { * find ident *    (of block) }
 729 ( 6107) { this is a fast version for compiler speed }
 730 ( 6107) 
 731 ( 6107) func findid; {search in table for id }
 732 ( 6107) 
 733 ( 6107) var k,i: integer;
 734 ( 6110)     id1: char;
 735 ( 6110) 
 736 ( 6110) begin
 737 ( 6110) 
 738 ( 6110)   i:=1; k:=8*spnt+9; id1:=ident[1];
 739 ( 6139) 
 740 ( 6147)   repeat
 741 ( 6147)     k:=k-8;
 742 ( 6153)     while (idtab[k]<>id1) and (k>0) do k:=k-8;
 743 ( 6194)     if k>0 then begin
 744 ( 6209)        i:=1;
 745 ( 6214)        repeat i:=succ(i)
 746 ( 6218)          until (i>8) or
 747 ( 6234)              (idtab[k+i-1]<>ident[i]);
 748 ( 6270)     end;
 749 ( 6274)     until (i>8) or (k<=0);
 750 ( 6288)   if k<=0 then begin
 751 ( 6299)     findid:=0;
 752 ( 6304)   end
 753 ( 6308)   else
 754 ( 6308)     findid:=(k-1) shr 3;
 755 ( 6320) end;
 756 ( 6325) 
 757 ( 6326) { * code2 *    (of block) }
 758 ( 6326) 
 759 ( 6326) proc code2(x,y: integer);
 760 ( 6326) begin
 761 ( 6326)   code1(x); code1(y);
 762 ( 6351) end;
 763 ( 6351) 
 764 ( 6352) { * code3 *    (of block) }
 765 ( 6352) 
 766 ( 6352) proc code3(x: integer; y1: %integer);
 767 ( 6352) 
 768 ( 6352) var y: integer;
 769 ( 6355) 
 770 ( 6355) begin {code3}
 771 ( 6355)   y:=y1;
 772 ( 6357)   if (x=34) and (y>=0) and (y<256) then
 773 ( 6388)     code2(32,y)
 774 ( 6394)   else begin
 775 ( 6407)     if (x=35) and (y>-128) and (y<=127) then
 776 ( 6430)       begin
 777 ( 6431)         if (y<0) then y:=y+256;
 778 ( 6451)         code2(33,y);
 779 ( 6468)       end

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 14

 780 ( 6468)     else begin
 781 ( 6471)       if (x>=36) and (x<=38) then y:=y-pc-1;
 782 ( 6500)       code1(x); code1(y and 255);
 783 ( 6528)       code1(y shr 8);
 784 ( 6541)     end
 785 ( 6541)   end
 786 ( 6541) end {code3};
 787 ( 6541) 
 788 ( 6542) { * testtype *      (of block) }
 789 ( 6542) 
 790 ( 6542) proc testtype(ttype: char);
 791 ( 6542) 
 792 ( 6542) begin
 793 ( 6542)   if restype<>ttype then
 794 ( 6551)     if (restype<>'u') and (ttype<>'u') then
 795 ( 6573)       merror(14,packed(ttype,restype));
 796 ( 6594) end;
 797 ( 6594) 
 798 ( 6595) { * putsym *   (of block) }
 799 ( 6595) 
 800 ( 6595) proc putsym(ltyp1,ltyp2: char);
 801 ( 6595) 
 802 ( 6595) var i,addr: integer;
 803 ( 6598) begin
 804 ( 6598)   if spnt>symbsize then error(7)
 805 ( 6613)   else spnt:=succ(spnt);
 806 ( 6626)   if spnt>spntmax then spntmax:=spnt;
 807 ( 6643)   t0[spnt]:=packed(ltyp1,ltyp2);
 808 ( 6669)   t3[spnt]:=0;
 809 ( 6684)   addr:=8*spnt;
 810 ( 6690)   for i:=1 to 8 do idtab[addr+i]:=ident[i];
 811 ( 6739)   if ltyp1='v' then begin
 812 ( 6771)     t2[spnt]:=dpnt; dpnt:=succ(dpnt);
 813 ( 6795)   end;
 814 ( 6800)   t1[spnt]:=level
 815 ( 6809) end {putsym};
 816 ( 6817) 
 817 ( 6818) { * checkindex *  (of block) }
 818 ( 6818) 
 819 ( 6818) proc checkindex(lowlim,highlim: integer);
 820 ( 6818) begin
 821 ( 6818)   if icheck then begin
 822 ( 6827)     code3($40,lowlim-1);
 823 ( 6845)     code2(highlim and 255, highlim shr 8)
 824 ( 6858)   end
 825 ( 6865) end;
 826 ( 6865) 
 827 ( 6866) { * getcon *      (of block) }
 828 ( 6866) 
 829 ( 6866) func getcon;
 830 ( 6866) 
 831 ( 6866) var idpnt,val,ii: integer;
 832 ( 6869)     rval: real;
 833 ( 6869)     sign: char;
 834 ( 6869) begin
 835 ( 6869)   restype:='i';
 836 ( 6873)   if token=' -' then begin
 837 ( 6885)     sign:='-'; scan
 838 ( 6894)   end else begin
 839 ( 6901)     sign:='+'; if token=' +' then scan

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 15

 840 ( 6915)   end;
 841 ( 6922)   case token of
 842 ( 6922)     'nu': val:=value[0];
 843 ( 6941)     'ru': begin val:=value[0];
 844 ( 6967)             restype:='r' end;
 845 ( 6981)     'st': if value[0]=1 then begin
 846 ( 7006)             restype:='c';
 847 ( 7011)             val:=ord(ident[1])
 848 ( 7022)           end else if value[0]=2 then begin
 849 ( 7047)             val:=(ord(ident[1]) shl 8) +
 850 ( 7064)               ord(ident[2]);
 851 ( 7075)             restype:='p';
 852 ( 7082)           end else if value[0]>2 then begin
 853 ( 7103)             val:=pc;
 854 ( 7106)             for ii:=1 to value[0] do
 855 ( 7127)                         code1(ord(ident[ii]));
 856 ( 7159)             code1(0); value[0]:=0; restype:='s';
 857 ( 7196)           end else error(15);
 858 ( 7211)     'cr': begin parse(' ('); scan; val:=getcon;
 859 ( 7241)             if (val>127) or (val<0) then
 860 ( 7259)               error(12);
 861 ( 7271)             testtype('i');
 862 ( 7279)             restype:='c'; parse(' )');
 863 ( 7294)           end;
 864 ( 7294)     'tr': begin val:=1; restype:='b' end;
 865 ( 7317)     'fa': begin val:=0; restype:='b' end;
 866 ( 7340)     'cp': begin
 867 ( 7351)             scan; val:=getcon;
 868 ( 7361)             testtype('i'); restype:='q';
 869 ( 7375)           end;
 870 ( 7379)     ' @': begin scan; val:=getcon;
 871 ( 7400)             if restype<>'q' then testtype('i');
 872 ( 7422)             restype:='f'
 873 ( 7422)           end
 874 ( 7424)     else begin
 875 ( 7431)       testto('id'); idpnt:=findid;
 876 ( 7446)       if (idpnt>0) and (high(t0[idpnt])='c')
 877 ( 7473)       then begin
 878 ( 7475)         val:=t2[idpnt];
 879 ( 7487)         restype:=low(t0[idpnt]);
 880 ( 7508)         if restype='r' then
 881 ( 7519)           value[1]:=t3[idpnt];
 882 ( 7539)       end
 883 ( 7547)       else begin error(4); val:=0;
 884 ( 7560)         restype:='i'
 885 ( 7564)       end
 886 ( 7566)     end
 887 ( 7570)   end {case};
 888 ( 7572)   if sign='-' then
 889 ( 7578)     case restype of
 890 ( 7582)       'i': getcon:=-val;
 891 ( 7593)       'r': begin value[0]:=val;
 892 ( 7619)              splitconv(value,rval);
 893 ( 7651)              splitconv(-rval,value);
 894 ( 7676)              getcon:=value[0]
 895 ( 7678)            end
 896 ( 7683)       else error(12)
 897 ( 7696)     end {case}
 898 ( 7704)   else getcon:=val;
 899 ( 7707) end {getcon};

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 16

 900 ( 7715) 
 901 ( 7716) { * deccon *         ( of block ) }
 902 ( 7716) 
 903 ( 7716) proc deccon;    { declare constant }
 904 ( 7716) begin
 905 ( 7716)   if token=' ;' then scan;
 906 ( 7736)   testto('id');
 907 ( 7745)   putsym('c','i');
 908 ( 7755)   parse(' ='); scan;
 909 ( 7768)   t2[spnt]:=getcon;
 910 ( 7783)   if (restype='r') then t3[spnt]:=value[1];
 911 ( 7813)   if restype<>'i' then
 912 ( 7827)     t0[spnt]:=packed('c',restype);
 913 ( 7847)   scan
 914 ( 7851) end {deccon};
 915 ( 7855) 
 916 ( 7856) { * decvar *          ( of block ) }
 917 ( 7856) 
 918 ( 7856) proc decvar(typ1,typ2: char);
 919 ( 7856) begin
 920 ( 7856)   if token=' ,' then scan;
 921 ( 7876)   testto('id');
 922 ( 7885)   putsym(typ1,typ2);
 923 ( 7899)   scan;
 924 ( 7903) end {decvar};
 925 ( 7903) 
 926 ( 7904) { * gettype *         ( of block ) }
 927 ( 7904) 
 928 ( 7904) proc gettype(var typ2: char;
 929 ( 7904)   var aflag,uflag: boolean; var n: integer);
 930 ( 7904) 
 931 ( 7904) begin
 932 ( 7904)   aflag:=false; n:=0; uflag:=false;
 933 ( 7923)   scan;
 934 ( 7931)   if token='ar' then begin
 935 ( 7939)     parse(' ['); scan;
 936 ( 7955)     n:=getcon; testtype('i');
 937 ( 7973)     if (n<1) then begin error(15); n:=1 end;
 938 ( 7997)     parse(' ]'); parse('of'); scan;
 939 ( 8019)     aflag:=true
 940 ( 8019)   end;
 941 ( 8025)   if token=' %' then begin
 942 ( 8033)     scan; uflag:=true
 943 ( 8040)   end;
 944 ( 8046)   case token of
 945 ( 8046)     'in': typ2:='i';
 946 ( 8060)     'ch': typ2:='c';
 947 ( 8077)     'pa': begin parse ('ch'); typ2:='p' end;
 948 ( 8107)     'bo': typ2:='b';
 949 ( 8120)     'rl': begin typ2:='r'; aflag:=true;
 950 ( 8143)             n:=prec(2*succ(n)) end;
 951 ( 8160)     'cp': typ2:='q';
 952 ( 8173)     'fl': typ2:='f'
 953 ( 8188)     else begin error(11); typ2:='i';end
 954 ( 8211)   end {case}
 955 ( 8213) end {gettype};
 956 ( 8213) 
 957 ( 8214) { * variable *        ( of block) }
 958 ( 8214) 
 959 ( 8214) proc variable;  { variable declarations }

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 17

 960 ( 8214) 
 961 ( 8214) var typ1,typ2: char;
 962 ( 8217)     i,l: integer;
 963 ( 8217)     aflag,uflag: boolean;
 964 ( 8217) 
 965 ( 8217) begin
 966 ( 8217)   scan;
 967 ( 8223)   repeat {main loop}
 968 ( 8223)     l:=0;
 969 ( 8225)     repeat decvar('v','i'); l:=succ(l);
 970 ( 8243)     until token<> ' ,';
 971 ( 8255)     testto(' :');
 972 ( 8268)     gettype(typ2,aflag,uflag,n);
 973 ( 8304)     if uflag then error(11);
 974 ( 8319)     if aflag then typ1:='a' else typ1:='v';
 975 ( 8337)     if typ1='a' then begin {array}
 976 ( 8351)        dpnt:=dpnt-l; {variable has been assumed}
 977 ( 8364)        for i:=succ(spnt-l) to spnt do begin
 978 ( 8391)          t2[i]:=dpnt; t3[i]:=n;
 979 ( 8417)          dpnt:=succ(dpnt+n);
 980 ( 8434)       end
 981 ( 8439)     end {array};
 982 ( 8453)     for i:=succ(spnt-l) to spnt do
 983 ( 8467)       t0[i]:=packed(typ1,typ2);
 984 ( 8498)     parse(' ;');scan
 985 ( 8525)   until token<>'id' {end main loop}
 986 ( 8536) end {variable};
 987 ( 8540) 
 988 ( 8541) { * fixup *           ( of block ) }
 989 ( 8541) 
 990 ( 8541) proc fixup(x: integer);
 991 ( 8541) begin
 992 ( 8541)   if ofno<>nooutput then begin
 993 ( 8553)     write(@ofno,'F');
 994 ( 8564)     savebyte(succ(x-offset) and 255);
 995 ( 8583)     savebyte(succ(x-offset) shr 8);
 996 ( 8602)     savebyte((pc-x-1) and 255);
 997 ( 8623)     savebyte((pc-x-1) shr 8);
 998 ( 8644)   end;
 999 ( 8644) end;
1000 ( 8644) 
1001 ( 8645) { * function *        ( of block ) }
1002 ( 8645) 
1003 ( 8645) proc function;
1004 ( 8645) 
1005 ( 8645) var n: integer;
1006 ( 8648)     typ1,typ2: char;
1007 ( 8648)     aflag,uflag: boolean;
1008 ( 8648) begin
1009 ( 8648)   if token<>' :' then begin
1010 ( 8658)     aflag:=false; uflag:=false; typ2:='i' end
1011 ( 8675)   else begin
1012 ( 8682)     gettype(typ2,aflag,uflag,n);
1013 ( 8718)     scan
1014 ( 8718)   end;
1015 ( 8722)   if aflag then begin
1016 ( 8726)     typ1:='s'; t3[succ(cproc)]:=n;
1017 ( 8745)     t2[succ(cproc)]:=t2[succ(cproc)]-n
1018 ( 8777)   end
1019 ( 8777)   else typ1:='r';

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 18

1020 ( 8791)   t0[succ(cproc)]:=packed(typ1,typ2);
1021 ( 8814)   if uflag then typ2:='u';
1022 ( 8827)   if aflag then typ1:='g'
1023 ( 8838)   else typ1:='f';
1024 ( 8849)   t0[cproc]:=packed(typ1,typ2);
1025 ( 8871) end {function};
1026 ( 8875) 
1027 ( 8876) { * parameter *       ( of block ) }
1028 ( 8876) 
1029 ( 8876) proc parameter;
1030 ( 8876) 
1031 ( 8876) var counter1,counter2,i,n,bs: integer;
1032 ( 8879)     aflag,uflag: boolean;
1033 ( 8879)     vtype1,vtype2: char;
1034 ( 8879)     vtype: packed char;
1035 ( 8879) 
1036 ( 8879) begin
1037 ( 8879)   push(0); { dummy size, fixed later }
1038 ( 8889)   if find=0 then t3[spnt-npara]:=stackpnt
1039 ( 8913)   else bs:=stackpnt;
1040 ( 8924)   counter1:=0
1041 ( 8932)   repeat {main loop}
1042 ( 8938)     counter2:=0;
1043 ( 8940)     vtype1:='d'; vtype2:='i';
1044 ( 8952)     scan;
1045 ( 8960)     if token='co' then scan
1046 ( 8968)     else if token='va' then begin
1047 ( 8986)       scan; vtype1:='w' end; {variable param}
1048 ( 8999)     end;
1049 ( 8999)     repeat {inner loop}
1050 ( 8999)       decvar(vtype1,vtype2);
1051 ( 9013)       t2[spnt]:=parlevel;
1052 ( 9022)       parlevel:=succ(parlevel);
1053 ( 9034)       npara:=succ(npara);
1054 ( 9043)       counter2:=succ(counter2);
1055 ( 9052)       until token<>' ,';
1056 ( 9064)     uflag:=false;aflag:=false; n:=0;
1057 ( 9082)     if token<>' :' then
1058 ( 9093)       vtype2:='i' {assume integer }
1059 ( 9099)     else begin
1060 ( 9106)       gettype(vtype2,aflag,uflag,n);
1061 ( 9142)       if n>63 then error(15);
1062 ( 9160)       scan
1063 ( 9160)     end;
1064 ( 9164)     if aflag then begin
1065 ( 9168)       vtype1:=succ(vtype1);
1066 ( 9175)       parlevel:=parlevel-counter2;
1067 ( 9184)     end;
1068 ( 9193)     vtype:=packed(vtype1,vtype2);
1069 ( 9202)     for i:=1 to counter2 do begin
1070 ( 9225)       if uflag then push(packed(vtype1,'u'))
1071 ( 9239)       else push(vtype);
1072 ( 9258)       if aflag then begin
1073 ( 9262)         push(n); t3[spnt-counter2+i]:=n;
1074 ( 9294)         t2[spnt-counter2+i]:=parlevel;
1075 ( 9321)         parlevel:=succ(parlevel)+n;
1076 ( 9334)       end {then};
1077 ( 9343)       t0[spnt-counter2+i]:=vtype;
1078 ( 9362)     end {for};
1079 ( 9370)     if aflag then counter2:=2*counter2;

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 19

1080 ( 9393)     counter1:=counter1+counter2;
1081 ( 9406)     until token<>' ;'; {outer loop}
1082 ( 9426)   testto(' )'); scan;
1083 ( 9439)   if find=0 then
1084 ( 9445)     stack[t3[spnt-npara]]:=counter1
1085 ( 9472)   else begin {information is allready there}
1086 ( 9483)     stack[bs]:=counter1;
1087 ( 9492)     n:=t3[fortab[find]]; {existing stack data}
1088 ( 9526)     for i:=0 to stackpnt-bs do
1089 ( 9536)       if stack[bs+1]<>stack[n+1]
1090 ( 9572)         then merror(13,'pa'); {parameter wrong}
1091 ( 9611)     stackpnt:=prec(bs) {clear the new info}
1092 ( 9615)   end  {else}
1093 ( 9620) end {parameter};
1094 ( 9620) 
1095 ( 9621) { * memory *              ( of block) }
1096 ( 9621) 
1097 ( 9621) proc memory;
1098 ( 9621) 
1099 ( 9621) var typ1,typ2:char;
1100 ( 9624)     i,l,n: integer;
1101 ( 9624)     aflag,uflag: boolean;
1102 ( 9624) 
1103 ( 9624) begin
1104 ( 9624)   scan;
1105 ( 9630)   repeat {main loop}
1106 ( 9630)     l:=0;
1107 ( 9632)     repeat
1108 ( 9636)       decvar('m','i');
1109 ( 9646)       l:=succ(l); testto(' ='); scan;
1110 ( 9668)       n:=getcon; testtype('i');
1111 ( 9686)       scan; t2[spnt]:=n;
1112 ( 9699)     until token<>' ,';
1113 ( 9714)     testto(' :');
1114 ( 9727)     gettype(typ2,aflag,uflag,n);
1115 ( 9763)     if uflag then error(11);
1116 ( 9778)     scan;
1117 ( 9782)     if token=' &' then begin {8-bit}
1118 ( 9793)       typ1:='h'; scan
1119 ( 9799)     end
1120 ( 9803)     else typ1:='m';
1121 ( 9808)     if aflag then typ1:=succ(typ1);
1122 ( 9823)     for i:=succ(spnt-l) to spnt do begin
1123 ( 9855)       t0[i]:=packed(typ1,typ2);
1124 ( 9873)       t3[i]:=n;
1125 ( 9886)     end;
1126 ( 9894)     testto(' ;'); scan;
1127 ( 9921)   until token<>'id';
1128 ( 9928) end {memory};
1129 ( 9932) 
1130 ( 9933) 
1131 ( 9933) {######################################}
1132 ( 9933) { * statement *           ( of block ) }
1133 ( 9933) {######################################}
1134 ( 9933) 
1135 ( 9933) proc statmnt;
1136 ( 9933) 
1137 ( 9933) var idpnt,relad,k2,savpc,bottom1: integer;
1138 ( 9936)     device,wln: boolean;
1139 ( 9936)     savtp1,vartyp2: char;

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 20

1140 ( 9936)     wl: boolean;
1141 ( 9936) 
1142 ( 9936) { * code4 *               ( of statement ) }
1143 ( 9936) 
1144 ( 9936) proc code4(x,y1,z1: integer); {set 4-byte code}
1145 ( 9936) 
1146 ( 9936) var y,z: integer;
1147 ( 9939) 
1148 ( 9939) begin
1149 ( 9939)   y:=y1; z:=z1;
1150 ( 9949)   if y<0 then y:=y+256;
1151 ( 9974)   if x=43 then z:=z-pc-2;
1152 (10000)   code1(x);code1(y);code1(z and 255);
1153 (10038)   code1(z shr 8)
1154 (10044) end {code4};
1155 (10051) 
1156 (10052) { * testferror *         ( of statement) ) }
1157 (10052) 
1158 (10052) proc testferror;
1159 (10052) begin
1160 (10052)   code1($4f);
1161 (10065) end;
1162 (10065) 
1163 (10066) { * gpval *              ( of statement ) }
1164 (10066) 
1165 (10066) proc gpval(idpnt: integer;
1166 (10066)   dir: boolean; typ: char);
1167 (10066) 
1168 (10066) var d: integer;
1169 (10069) 
1170 (10069) begin {gpval}
1171 (10069)   if dir then d:=1 else d:=0;
1172 (10089)   case typ of
1173 (10093)   'h':  begin code3($22,t2[idpnt]);
1174 (10125)           if dir then code1($3f);
1175 (10140)           code1($17+d) end;
1176 (10153)   'm':  begin code3($22,t2[idpnt]);
1177 (10184)           code1($3d+d) end;
1178 (10197)   'i':  begin
1179 (10207)           if dir then code1($3f);
1180 (10222)           code3($22,t2[idpnt]);
1181 (10243)           code1(3);
1182 (10251)           if dir then code1($3f);
1183 (10266)           code1($17+d) end;
1184 (10279)   'n':  begin if dir then code1($3f);
1185 (10304)           code3($22,1); code1($12);
1186 (10322)           code3($22,t2[idpnt]);
1187 (10343)           code1(3); code1($3d+d) end
1188 (10364)   else begin
1189 (10367)     if typ='q' then begin
1190 (10374)       { relad=1 bedeutet: s[i] Zugriff auf }
1191 (10377)       { cpnt-string-byte }
1192 (10377)       if relad=1 then begin
1193 (10384)         if t3[idpnt]=0 then
1194 (10402)           checkindex(0,63)
1195 (10410)         else
1196 (10416)           checkindex(0,t3[idpnt]);
1197 (10440)       end;
1198 (10440)       code4($55,level-t1[idpnt],2*t2[idpnt]);
1199 (10482)     end else

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 21

1200 (10482)       code4($27+2*d+relad,level-t1[idpnt],
1201 (10513)         2*t2[idpnt]);
1202 (10540)     end
1203 (10540)   end {case}
1204 (10542) end;
1205 (10542) 
1206 (10543) { FORWARD decl. of mainexp (of statement) }
1207 (10543) 
1208 (10543) proc mainexp(reqtype: char;
1209 (10543)   var arsize: integer); forward;
1210 (10546) 
1211 (10546) { * express *           ( of statement ) }
1212 (10546) 
1213 (10546) proc express; {requests a normal 16-bit result }
1214 (10546) 
1215 (10546) var resultsize: integer;
1216 (10549) 
1217 (10549) begin {express}
1218 (10549)   mainexp('n',resultsize);
1219 (10567)   if resultsize<>0 then error(15)
1220 (10579) end {express};
1221 (10585) 
1222 (10586) { * arrayexp *          ( of mainexp) }
1223 (10586) 
1224 (10586) proc arrayexp(size: integer; eltype: char);
1225 (10586) 
1226 (10586) var resultsize: integer;
1227 (10589) 
1228 (10589) begin
1229 (10589)   mainexp(eltype,resultsize);
1230 (10609)   if resultsize<>size then error(15);
1231 (10629)   testtype(eltype);
1232 (10639) end;
1233 (10639) 
1234 (10640) { * getvar *            ( of statement ) }
1235 (10640) 
1236 (10640) proc getvar;
1237 (10640) begin
1238 (10640)   vartyp2:=high(t0[idpnt]);
1239 (10658)   vartype:=low(t0[idpnt]);
1240 (10676)   scan;
1241 (10685)   if (vartype='q') and (token=' [') and
1242 (10700)     ((vartyp2='v') or (vartyp2='d')) then begin
1243 (10717)     vartyp2:='q'; vartype:='c';
1244 (10728)   end;
1245 (10732)   case vartyp2 of
1246 (10732)   'a','x','s','i','n','q':
1247 (10775)       begin
1248 (10778)         if token=' [' then begin
1249 (10786)           scan; express; relad:=1;
1250 (10799)           if vartyp2='r' then begin
1251 (10810)             relad:=3;
1252 (10815)             code3($22,1); code1($12)
1253 (10831)           end;
1254 (10837)           if (vartyp2='q') and (t3[idpnt]=0) then
1255 (10860)             checkindex(0,63)
1256 (10868)           else
1257 (10874)             checkindex(0,t3[idpnt]);
1258 (10898)           testtype('i'); testto(' ]'); scan;
1259 (10919)         end else relad:=2;

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 22

1260 (10924)       end;
1261 (10928)   'v','w','r','h','m': relad:=0;
1262 (10968)   'c','d','e','t','u': error(6)
1263 (11012)   else error(1)
1264 (11023)   end {case}
1265 (11031) end {getvar};
1266 (11031) 
1267 (11032) { * prcall *            ( of statement ) }
1268 (11032) 
1269 (11032) proc prcall (idpn1: integer);
1270 (11032) 
1271 (11032) var bstack,numpar,i,n,n2: integer;
1272 (11035) 
1273 (11035) { body of prcall follows later }
1274 (11035) 
1275 (11035) { * prcall1 *           ( of prcall ) }
1276 (11035) 
1277 (11035) proc prcall1;
1278 (11035) var ressize:integer;
1279 (11038) 
1280 (11038)   proc prcall3;
1281 (11038)   begin {prcall3}
1282 (11041)     testto('id');
1283 (11052)     idpnt:=findid;
1284 (11058)     if idpnt=0 then error(5);
1285 (11080)     getvar;
1286 (11084)     if chr(stack[i] and 255)<>vartype then
1287 (11101)       if chr(stack[i] and 255)<>'u' then
1288 (11128)         merror(14,'01');
1289 (11143)       push(idpnt);
1290 (11153)   end {prcall3};
1291 (11153) 
1292 (11154) begin {prcall1}
1293 (11154)   case chr(stack[i] shr 8) of
1294 (11172)     'd':  begin
1295 (11180)             if chr(stack[i] and 255) = 'q' then
1296 (11199)               mainexp('q',ressize)
1297 (11205)             else
1298 (11219)               express;
1299 (11226)             if chr(stack[i] and 255)<>'u' then
1300 (11245)               testtype(chr(stack[i] and 255));
1301 (11272)           end;
1302 (11272)     'e':  begin
1303 (11282)             arrayexp(stack[succ(i)],
1304 (11292)               chr(stack[i]));
1305 (11316)             i:=succ(i);
1306 (11320)           end;
1307 (11325)     'w':  begin
1308 (11335)             prcall3;
1309 (11339)             if relad<>0 then merror(14,'02');
1310 (11360)             gpval(idpnt,false,vartyp2);
1311 (11376)           end;
1312 (11376)     'x':  begin
1313 (11386)             prcall3;
1314 (11390)             if relad<>2 then merror(14,'03');
1315 (11411)             if vartyp2='i' then error(16);
1316 (11429)             i:=succ(i);
1317 (11433)             if stack[i]<>t3[idpnt] then
1318 (11460)               error(15);
1319 (11476)             if vartyp2='n' then begin

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 23

1320 (11483)               code3($22,t2[idpnt]);
1321 (11507)               code1($3d);
1322 (11515)             end else code4($27,level-t1[idpnt],
1323 (11533)               2*t2[idpnt]);
1324 (11560)             code2($3b,stack[i]);
1325 (11581)           end
1326 (11581)     else merror(14,'04')
1327 (11589)   end {case}
1328 (11597) end {prcall1};
1329 (11597) 
1330 (11598) proc prcall2;
1331 (11598) begin
1332 (11598)   if n>0 then code3(35,-2*n);
1333 (11629)   n:=0
1334 (11629) end {prcall2};
1335 (11635) 
1336 (11636) begin {body of prcall}
1337 (11636)   if t3[idpn1]<>0 then begin
1338 (11654)     bstack:=t3[idpn1];
1339 (11666)     numpar:=stack[bstack];
1340 (11683)     parse(' ('); scan;
1341 (11704)     for i:=succ(bstack) to bstack+numpar do
1342 (11717)     begin
1343 (11731)       prcall1;
1344 (11735)       if i<bstack+numpar then begin
1345 (11749)         testto(' ,'); scan
1346 (11761)       end
1347 (11765)     end;
1348 (11765)     testto(' )');
1349 (11788)   end {then};
1350 (11788)   code4(43,level-t1[idpn1],t2[idpn1]);
1351 (11827)   if t3[idpn1]<>0 then begin
1352 (11843)     n:=0; i:=bstack+numpar;
1353 (11856)     repeat
1354 (11865)       case chr(stack[i] shr 8) of
1355 (11881)       'd':  n:=succ(n);
1356 (11893)       'w':  begin
1357 (11908)               prcall2; idpnt:=pop;
1358 (11918)               gpval(idpnt,true,
1359 (11928)                   high(t0[idpnt]));
1360 (11948)             end;
1361 (11948)       chr(0): begin
1362 (11958)             n2:=stack[i];
1363 (11967)             i:=i-1;
1364 (11981)             case chr(stack[i] shr 8) of
1365 (12002)               'e':  n:=succ(n+n2);
1366 (12019)               'x':  begin
1367 (12034)                       prcall2;
1368 (12038)                       idpnt:=pop;
1369 (12044)                       if high(t0[idpnt])='n'
1370 (12062)                       then begin
1371 (12065)                         code3($22,t2[idpnt]+
1372 (12079)                           2*t3[idpnt]);
1373 (12106)                         code1($3e)
1374 (12108)                       end else
1375 (12114)                         code4(41,
1376 (12119)                           level-t1[idpnt],
1377 (12132)                           2*(t2[idpnt]+
1378 (12148)                           t3[idpnt]));
1379 (12173)                       code2($3c,t3[idpnt])

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 24

1380 (12184)                     end
1381 (12194)               end {case}
1382 (12196)             end
1383 (12196)       end; {case}
1384 (12198)       i:=prec(i);
1385 (12202)     until i=bstack;
1386 (12211)     prcall2
1387 (12219)   end
1388 (12223) end {prcall};
1389 (12223) 
1390 (12224) 
1391 (12224) {###################################}
1392 (12224) { * mainexp *       ( of statement) }
1393 (12224) {###################################}
1394 (12224) {  see forward declaration above    }
1395 (12224) 
1396 (12224) proc mainexp(reqtype: char;
1397 (12224)   var arsize: integer);
1398 (12224) 
1399 (12224) { variables of mainexp}
1400 (12224) var opcode,roff: integer;
1401 (12227)     savtype: char;
1402 (12227) 
1403 (12227) { * argument *         ( of mainexp ) }
1404 (12227) 
1405 (12227) proc argument(rtype: char);
1406 (12227) begin
1407 (12227)   parse(' ('); scan; express;
1408 (12249)   testtype(rtype);
1409 (12259)   testto(' )'); scan
1410 (12268) end; {argument}
1411 (12273) 
1412 (12273) {#######################################}
1413 (12273) { * simexp *             ( of mainexp ) }
1414 (12273) {#######################################}
1415 (12273) 
1416 (12273) proc simexp(var arsize1: integer);
1417 (12273) 
1418 (12273) var opcode: integer;
1419 (12276)     sign: char;
1420 (12276) 
1421 (12276) {body of simexp  follows later }
1422 (12276) 
1423 (12276) {#######################################}
1424 (12276) { * term *               ( of simexp )  }
1425 (12276) {#######################################}
1426 (12276) 
1427 (12276) proc term(var arsize2: integer);
1428 (12276) 
1429 (12276) var opcode: integer;
1430 (12279) 
1431 (12279) { body of term follows later }
1432 (12279) 
1433 (12279) {#######################################}
1434 (12279) { * factor *             ( of term )    }
1435 (12279) {#######################################}
1436 (12279) 
1437 (12279) proc factor(var arsize3: integer);
1438 (12279) 
1439 (12279) var i, idpnt: integer;

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 25

1440 (12282)     h: char;
1441 (12282) 
1442 (12282) { * index *              ( of factor )  }
1443 (12282) 
1444 (12282) proc index(chk: boolean);
1445 (12282) 
1446 (12282) var savtype: char;
1447 (12285) 
1448 (12285) begin {index}
1449 (12285)   scan; savtype:=restype;
1450 (12291)   express; testtype('i'); testto(' ]');
1451 (12320)   if savtype='r' then begin
1452 (12327)     code3($22,1); code1($12);
1453 (12348)   end;
1454 (12348)   if chk then begin
1455 (12352)     if (savtype='q') and (t3[idpnt]=0) then
1456 (12378)       { is an arrayed cpnt }
1457 (12379)       checkindex(0,63)
1458 (12386)     else
1459 (12392)       checkindex(0,t3[idpnt]);
1460 (12416)   end;
1461 (12416)   restype:=savtype; scan
1462 (12424) end;
1463 (12428) 
1464 (12429) 
1465 (12429) begin { *** body of factor *** }
1466 (12429)   arsize3:=0;
1467 (12433)   case token of
1468 (12437)     'id': begin {identifier }
1469 (12449)             idpnt:=findid;
1470 (12455)             if idpnt=0 then error(5);
1471 (12477)             restype:=low(t0[idpnt]);
1472 (12490)             h:=high(t0[idpnt]);
1473 (12508)             case h of
1474 (12513)               'v','w','d':
1475 (12535)                     begin
1476 (12538)                       scan;
1477 (12542)                       if (restype='q') and (token=' [')
1478 (12556)                       then begin
1479 (12558)                         code4(39,level-t1[idpnt],
1480 (12576)                           2*t2[idpnt]);
1481 (12603)                         index(true);
1482 (12611)                         code1($03);
1483 (12619)                         code1($54);
1484 (12627)                         restype:='c';
1485 (12629)                       end else
1486 (12633)                         code4(39,level-t1[idpnt],
1487 (12651)                           2*t2[idpnt]);
1488 (12678)                     end;
1489 (12678)               'h':  begin code3($22,t2[idpnt]);
1490 (12709)                       code1($17); scan end;
1491 (12721)               'i':  begin code3($22,t2[idpnt]);
1492 (12752)                       scan;
1493 (12756)                       if token=' [' then begin
1494 (12764)                         index(true); code1($03);
1495 (12783)                         code1($17)
1496 (12785)                       end else begin
1497 (12794)                         error(16)
1498 (12796)                       end
1499 (12802)                     end;

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 26

1500 (12802)               'm':  begin code3($22,t2[idpnt]);
1501 (12833)                       code1($3d); scan
1502 (12841)                     end;
1503 (12845)               'n':  begin code3($22,t2[idpnt]);
1504 (12876)                       scan;
1505 (12880)                       if token=' [' then begin
1506 (12888)                         index(true);
1507 (12899)                         code3($22,1);code1($12);
1508 (12917)                         code1($03); code1($3d);
1509 (12933)                         if restype='r' then
1510 (12939)                         begin
1511 (12940)                           code2($3b,1);
1512 (12953)                           arsize3:=1
1513 (12953)                         end
1514 (12955)                       end else begin
1515 (12962)                         code1($3d);
1516 (12970)                         code2($3b,t3[idpnt]);
1517 (12991)                         arsize3:=t3[idpnt];
1518 (13000)                       end
1519 (13008)                     end;
1520 (13008)               'r','t': begin
1521 (13025)                       code3(35,2);
1522 (13035)                       idpnt:=prec(idpnt);
1523 (13039)                       prcall(idpnt); scan;
1524 (13058)                       restype:=low(t0[idpnt]);
1525 (13071)                     end;
1526 (13076)               'c':  if low(t0[idpnt])<>'r' then begin
1527 (13103)                       code3(34,t2[idpnt]);
1528 (13127)                       scan;
1529 (13131)                       if restype='s' then begin
1530 (13138)                         if token=' [' then begin
1531 (13149)                           index(true);
1532 (13160)                           code1($03);
1533 (13168)                           code1($58);
1534 (13176)                           code1($54);
1535 (13184)                           restype:='c';
1536 (13186)                         end else begin
1537 (13193)                           code1($58);
1538 (13201)                           restype:='q';
1539 (13203)                         end;
1540 (13207)                       end;
1541 (13207)                       {scan;}
1542 (13207)                     end else begin
1543 (13210)                       code2($3a,2);
1544 (13220)                       code2(t2[idpnt] and 255,
1545 (13235)                         t2[idpnt] shr 8);
1546 (13258)                       code2(t3[idpnt] and 255,
1547 (13273)                         t3[idpnt] shr 8);
1548 (13296)                       arsize3:=1; scan
1549 (13302)                     end;
1550 (13306)               'a','e','x':
1551 (13327)                     begin scan;
1552 (13334)                       if token=' [' then begin
1553 (13342)                         index(true);
1554 (13353)                         code4($28,
1555 (13355)                             level-t1[idpnt],
1556 (13368)                             2*t2[idpnt]);
1557 (13395)                         if restype='r' then
1558 (13401)                         begin
1559 (13402)                           code2($3b,1);

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 27

1560 (13415)                           arsize3:=1
1561 (13415)                         end
1562 (13417)                       end else begin
1563 (13424)                         code4($27,
1564 (13426)                             level-t1[idpnt],
1565 (13439)                             2*t2[idpnt]);
1566 (13466)                         code2($3b,t3[idpnt]);
1567 (13487)                         arsize3:=t3[idpnt];
1568 (13496)                       end
1569 (13504)                     end;
1570 (13504)               's','u':
1571 (13518)                     begin
1572 (13521)                       code3(35,2*t3[idpnt]+2);
1573 (13548)                       idpnt:=prec(idpnt);
1574 (13552)                       prcall(idpnt); scan;
1575 (13571)                       restype:=low(t0[idpnt]);
1576 (13584)                       idpnt:=succ(idpnt);
1577 (13593)                       arsize3:=t3[idpnt]
1578 (13598)                     end
1579 (13607)               else error(1)
1580 (13620)             end {case}
1581 (13628)           end; {identifier}
1582 (13631)     'nu': begin code3(34,value[0]); scan;
1583 (13662)             restype:='i'
1584 (13662)           end;
1585 (13668)     'ru': begin code2($3a,2);
1586 (13689)             code2(value[0] and 255,
1587 (13702)               value[0] shr 8);
1588 (13723)             code2(value[1] and 255,
1589 (13736)               value[1] shr 8);
1590 (13757)             scan; restype:='r';
1591 (13763)             arsize3:=1
1592 (13767)           end;
1593 (13773)     'st': begin
1594 (13784)           if (reqtype='n') and (value[0]<3)
1595 (13804)             then begin
1596 (13806)               if value[0]<2 then begin
1597 (13823)                 code3(34,ord(ident[1]));
1598 (13845)                 restype:='c'
1599 (13845)               end else begin
1600 (13854)                 code3(34,packed(ident[1],
1601 (13863)                   ident[2]));
1602 (13885)                 restype:='p'
1603 (13885)               end
1604 (13887)             end else begin
1605 (13894)               case reqtype of
1606 (13894)                 'c','u','n','q':
1607 (13923)                     begin
1608 (13926)                       if (vartype='q') or
1609 (13933)                          (reqtype='q') then begin
1610 (13941)                         arsize3:=0;
1611 (13946)                         restype:='q';
1612 (13952)                         code2($56,value[0]);
1613 (13975)                       end else begin
1614 (13978)                         arsize3:=prec(value[0]);
1615 (13989)                         restype:='c';
1616 (13996)                         code2($39,value[0]);
1617 (14019)                       end;
1618 (14019)                       for i:=1 to value[0] do
1619 (14032)                         code1(ord(ident[i]));

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 28

1620 (14064)                       if (vartype='q') or
1621 (14085)                          (reqtype='q') then code1(0);
1622 (14104)                     end;
1623 (14104)                 'p': begin
1624 (14114)                       if odd(value[0]) then
1625 (14125)                         error(15);
1626 (14137)                       value[0]:=value[0] shr 1;
1627 (14157)                       arsize3:=prec(value[0]);
1628 (14173)                       restype:='p';
1629 (14180)                       code2($3a,value[0]);
1630 (14203)                       for i:=1 to value[0] do
1631 (14216)                         begin
1632 (14229)                         code1(ident[2*i]);
1633 (14251)                         code1(ident[2*i-1]);
1634 (14276)                       end
1635 (14276)                     end
1636 (14276)                 else merror(14,'05')
1637 (14298)               end {case}
1638 (14306)             end;
1639 (14306)             scan
1640 (14306)           end;
1641 (14310)     'od': begin
1642 (14321)             argument('i'); code1(7);
1643 (14337)             restype:='b'
1644 (14337)           end;
1645 (14343)     'me': begin
1646 (14354)             parse(' ['); index(false);
1647 (14371)             code1(23); restype:='i';
1648 (14381)           end;
1649 (14385)     ' (': begin
1650 (14396)             scan; mainexp(reqtype,arsize3);
1651 (14418)             testto(' )'); scan
1652 (14427)           end; {no type change}
1653 (14434)     'no': begin
1654 (14442)             scan; factor(arsize3);
1655 (14458)             if (arsize3<>0) then error(15);
1656 (14476)             code1($11);
1657 (14484)             if restype<>'i' then
1658 (14490)               testtype('b')
1659 (14496)           end;
1660 (14502)     'cr': begin
1661 (14513)             argument('i'); code1(52);
1662 (14529)             restype:='c'
1663 (14529)           end;
1664 (14535)     'hi': begin
1665 (14546)             argument('p'); code1(51);
1666 (14562)             restype:='c'
1667 (14562)           end;
1668 (14568)     'lo': begin
1669 (14579)             argument('p'); code1(52);
1670 (14595)             restype:='c'
1671 (14595)           end;
1672 (14601)     'su': begin
1673 (14612)             argument('u'); code1($14);
1674 (14628)           end;
1675 (14628)     'pc': begin
1676 (14639)             argument('u'); code1($15)
1677 (14649)           end;
1678 (14655)     'cp': begin
1679 (14666)             argument('i'); restype:='q';

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 29

1680 (14676)           end;
1681 (14680)     'ni': begin
1682 (14691)             code3(34,0); scan; restype:='q';
1683 (14707)           end;
1684 (14711)     'ox': begin
1685 (14722)             argument('u');
1686 (14730)             restype:='i'
1687 (14730)           end;
1688 (14736)     ' @': begin
1689 (14747)             scan; factor(arsize3);
1690 (14763)             if arsize3<>0 then error(15);
1691 (14781)             if restype<>'q' then testtype('i');
1692 (14799)             restype:='f'
1693 (14799)           end;
1694 (14805)     'tr': begin
1695 (14816)             code3(34,1); scan;
1696 (14830)             restype:='b';
1697 (14832)           end;
1698 (14836)     'fa': begin
1699 (14847)             code3(34,0); scan;
1700 (14861)             restype:='b'
1701 (14861)           end;
1702 (14867)     'tc': begin
1703 (14878)             parse(' ('); scan;
1704 (14891)             arrayexp(1,'r');
1705 (14901)             testto(' )'); scan;
1706 (14914)             code1($47); restype:='i';
1707 (14924)           end;
1708 (14928)     'cv': begin
1709 (14939)             argument('i');
1710 (14947)             code1($46); arsize3:=1;
1711 (14957)             restype:='r'
1712 (14961)           end;
1713 (14967)     'pa': begin
1714 (14978)             parse(' ('); scan; express;
1715 (14995)             testtype('c');
1716 (15003)             if token=' ,' then begin
1717 (15011)               scan; express; testtype('c');
1718 (15030)               code1(53)
1719 (15032)             end;
1720 (15038)             testto(' )'); scan; restype:='p'
1721 (15051)           end
1722 (15053)     else error(1)
1723 (15062)   end {case of token}
1724 (15070) end {factor};
1725 (15070) 
1726 (15071) begin  { *** body of term *** }
1727 (15071)   factor(arsize2);
1728 (15085)   repeat
1729 (15085)     case token of
1730 (15085)       ' *': opcode:=5;
1731 (15099)       'di': opcode:=6;
1732 (15116)       'an': opcode:=15;
1733 (15133)       'sh': opcode:=18;
1734 (15150)       'sr': opcode:=19;
1735 (15167)       ' /': opcode:=$45
1736 (15182)       else opcode:=0
1737 (15191)     end {case};
1738 (15199)     if opcode>0 then begin
1739 (15206)       if (restype='r') and

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 30

1740 (15216)             (arsize2=1) then begin
1741 (15224)         scan; factor(arsize2);
1742 (15243)         if (restype<>'r') or (arsize2<>1) then
1743 (15257)           merror(14,'06');
1744 (15272)         case opcode of
1745 (15272)           5: code1($44);
1746 (15291)           $45: code1($45)
1747 (15303)           else error(17)
1748 (15314)         end{case}
1749 (15322)       end else begin
1750 (15325)         if opcode=$45 then error(9);
1751 (15343)         if arsize2<>0 then error(15);
1752 (15361)         if (restype='b') and (opcode=15)
1753 (15374)           then begin
1754 (15376)           scan; factor(arsize2);
1755 (15395)           if arsize2<>0 then error(15);
1756 (15413)           testtype('b');
1757 (15421)           code1(opcode)
1758 (15421)         end else begin
1759 (15434)           testtype('i'); scan;
1760 (15446)           factor(arsize2);
1761 (15458)           if arsize2<>0 then error(15);
1762 (15476)           testtype('i'); code1(opcode);
1763 (15494)         end
1764 (15494)       end
1765 (15494)     end;
1766 (15494)   until opcode=0;
1767 (15500) end {term};
1768 (15504) 
1769 (15505) 
1770 (15505) begin { *** body of simexp *** }
1771 (15505)   sign:=' ';
1772 (15509)   if token=' +' then begin
1773 (15521)     sign:='+'; scan
1774 (15530)   end else if token=' -' then begin
1775 (15545)     sign:='-'; scan
1776 (15554)   end;
1777 (15558)   term(arsize1);
1778 (15570)   if sign<>' ' then begin
1779 (15577)     if (restype='r')and (arsize1=1) then begin
1780 (15595)       if sign='-' then code1($4e)
1781 (15610)     end else begin
1782 (15619)       testtype('i');
1783 (15627)       if arsize1<>0 then error(15);
1784 (15645)       if sign='-' then code1(2);
1785 (15663)     end
1786 (15663)   end;
1787 (15663)   repeat
1788 (15663)     case token of
1789 (15663)       ' &': opcode:=1;
1790 (15677)       ' +': opcode:=3;
1791 (15694)       ' -': opcode:=4;
1792 (15711)       'or': opcode:=14;
1793 (15728)       'xo': opcode:=16
1794 (15743)       else opcode:=0
1795 (15752)     end {case};
1796 (15760)     if opcode>1 then begin {if 1}
1797 (15770)       if (restype='r') and (arsize1=1)
1798 (15783)         then begin {real}
1799 (15788)         scan; term(arsize1);

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 31

1800 (15804)         if (restype<>'r') or (arsize1<>1) then
1801 (15818)           error(17);
1802 (15830)         case opcode of
1803 (15830)           3:  code1($42);
1804 (15849)           4:  code1($43)
1805 (15861)           else error(17)
1806 (15872)         end {case}
1807 (15880)       end {real}
1808 (15880)       else begin {not real}
1809 (15883)         if (arsize1<>0) then error(15);
1810 (15901)         if (restype='b') and (opcode>=14)
1811 (15914)           then begin {boolean}
1812 (15919)           scan; term(arsize1);
1813 (15935)           if arsize1<>0 then error(15);
1814 (15953)           testtype('b'); code1(opcode)
1815 (15961)         end {boolean}
1816 (15971)         else begin {not boolean}
1817 (15974)           testtype('i'); scan;
1818 (15986)           term(arsize1);
1819 (15998)           if arsize1<>0 then error(15);
1820 (16016)           testtype('i'); code1(opcode);
1821 (16034)         end {not boolean}
1822 (16034)       end {not real}
1823 (16034)     end {if 1}
1824 (16034)     else if opcode=1 then begin {else 1}
1825 (16047)       sign:=restype;
1826 (16047)       scan; term(opcode);
1827 (16071)       arsize1:=arsize1+opcode+1;
1828 (16082)       testtype(sign)
1829 (16087)     end {else 1}
1830 (16097)   until opcode=0
1831 (16101) end {simexp};
1832 (16107) 
1833 (16108) 
1834 (16108) begin { *** body of mainexp *** }
1835 (16108)   roff:=0;
1836 (16112)   simexp(arsize);
1837 (16128)   if (restype='r') and (arsize=1) then
1838 (16142)     roff:=$40;
1839 (16148)   case token of
1840 (16152)     ' =': opcode:=8;
1841 (16166)     ' <': opcode:=10;
1842 (16183)     ' >': opcode:=12;
1843 (16200)     '<>': opcode:=9;
1844 (16217)     '<=': opcode:=13;
1845 (16234)     '>=': opcode:=11
1846 (16249)     else opcode:=0
1847 (16258)   end {case};
1848 (16266)   if opcode>0 then begin
1849 (16273)     if (arsize<>0) and (roff=0) then
1850 (16290)       error(15);
1851 (16302)     scan; savtype:=restype; simexp(arsize);
1852 (16326)     if ((roff=0) and (arsize<>0))
1853 (16340)       or((roff<>0) and (arsize>1)) then
1854 (16356)       error(15);
1855 (16368)     testtype(savtype); code1(opcode+roff);
1856 (16393)     arsize:=0; restype:='b'
1857 (16399)   end
1858 (16401) end {mainexp};
1859 (16405) 

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 32

1860 (16406) 
1861 (16406) {#########################################}
1862 (16406) { * assign *             ( of statement ) }
1863 (16406) {#########################################}
1864 (16406) 
1865 (16406) proc assign;
1866 (16406) 
1867 (16406) var savetype: char;
1868 (16409) 
1869 (16409)   proc assign1;
1870 (16409)   begin
1871 (16409)     testto(':='); scan; express;
1872 (16431)     if (vartype='q') and (restype='s') then begin
1873 (16446)       code1($58); restype:='q';
1874 (16459)     end;
1875 (16463)     gpval(idpnt,true,vartyp2);
1876 (16479)   end {assign1};
1877 (16479) 
1878 (16480) begin {assign}
1879 (16480)   idpnt:=findid;
1880 (16488)   if idpnt=0 then error(5);
1881 (16510)   if t0[idpnt]='pr' then begin
1882 (16527)     prcall(idpnt);scan end
1883 (16544)   else begin
1884 (16547)     getvar; savetype:=vartype;
1885 (16551)     if relad<2 then begin
1886 (16566)       assign1; testtype(vartype)
1887 (16573)     end else begin
1888 (16586)       if vartyp2='i' then error(16); {8-bit mem}
1889 (16604)       testto(':='); scan;
1890 (16617)       if relad=3 then begin
1891 (16624)         arrayexp(1,vartype); relad:=1;
1892 (16641)         code1($53);
1893 (16653)         if vartyp2='n' then begin
1894 (16660)           code1($3f);
1895 (16671)           code3($22,1);code1($12);
1896 (16689)           code3($22,t2[idpnt]+2);
1897 (16713)           code1($3);code1($3e)
1898 (16723)         end else
1899 (16729)           code4($2a,level-t1[idpnt],
1900 (16747)             2*t2[idpnt]+2);
1901 (16777)         code2($3c,1)
1902 (16781)       end else begin
1903 (16790)         arrayexp(t3[idpnt],vartype);
1904 (16813)         if vartyp2='n' then begin
1905 (16820)           code3($22,t2[idpnt]+2*t3[idpnt]);
1906 (16861)           code1($3e);
1907 (16869)         end else
1908 (16869)           code4($29,level-t1[idpnt],
1909 (16887)             2*(t2[idpnt]+t3[idpnt]));
1910 (16928)         code2($3c,t3[idpnt]);
1911 (16949)       end
1912 (16949)     end
1913 (16949)   end
1914 (16949) end {assign};
1915 (16949) 
1916 (16950) { * case1 *             ( of statement ) }
1917 (16950) 
1918 (16950) proc case1;
1919 (16950) 

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 33

1920 (16950) var i1,i2,casave: integer;
1921 (16953)     savetype: char;
1922 (16953) 
1923 (16953)   proc case2;
1924 (16953) 
1925 (16953)     proc case3;
1926 (16956)     begin
1927 (16956)       scan; code1(22); code3(34,getcon);
1928 (16987)       testtype(savetype);
1929 (16997)       code1(8); scan
1930 (17005)     end;
1931 (17009) 
1932 (17010)   begin {case2}
1933 (17010)     i1:=0; case3;
1934 (17022)     while token=' ,' do begin
1935 (17033)       push(pc); code3(38,0); i1:=succ(i1);
1936 (17057)       case3
1937 (17062)     end;
1938 (17066)     testto(' :'); savpc:=pc; code3(37,0);
1939 (17096)     for k2:=1 to i1 do fixup(pop);
1940 (17127)     push(savpc);
1941 (17151)     scan; statmnt
1942 (17155)   end {case2};
1943 (17159) 
1944 (17160) begin {case1}
1945 (17160)   scan; express; testto('of');
1946 (17179)   savetype:=restype; i2:=1; case2;
1947 (17197)   while token=' ;' do begin
1948 (17208)     casave:=pc; code3(36,0); fixup(pop);
1949 (17238)     push(casave); i2:=succ(i2); case2
1950 (17257)   end;
1951 (17261)   if token='el' then begin
1952 (17272)     casave:=pc; code3(36,0); fixup(pop);
1953 (17305)     push(casave); scan; statmnt
1954 (17319)   end;
1955 (17323)   testto('en'); for k2:=1 to i2 do fixup(pop);
1956 (17363)   code3(35,-2); scan
1957 (17388) end {case1};
1958 (17392) 
1959 (17393) { * openrw *              ( of statement ) }
1960 (17393) 
1961 (17393) proc openrw(x: integer);
1962 (17393) begin
1963 (17393)   parse(' ('); parse('id');
1964 (17416)   idpnt:=findid;
1965 (17422)   if idpnt=0 then error(5);
1966 (17444)   getvar; code1(x);
1967 (17458)   testferror;
1968 (17462)   if relad=2 then error(15);
1969 (17480)   if vartype<>'f' then merror(14,'07');
1970 (17501)   gpval(idpnt,true,vartyp2);
1971 (17517)   testto(' )'); scan
1972 (17526) end {openrw};
1973 (17530) 
1974 (17531) { * gpsec *               ( of statement )  }
1975 (17531) 
1976 (17531) proc gpsec(code);   { get/put sector }
1977 (17531) 
1978 (17531)   proc gpsec1;
1979 (17534)   begin

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 34

1980 (17534)     scan; express; testtype('i');
1981 (17555)     testto(' ,');
1982 (17564)   end;
1983 (17564) 
1984 (17565) begin {gpsec}
1985 (17565)   parse(' ('); gpsec1; gpsec1; gpsec1;
1986 (17588)   code1(code);
1987 (17598)   parse('id'); idpnt:=findid;
1988 (17613)   if idpnt=0 then error(5);
1989 (17635)   getvar; code3(34,$db); { get file error code }
1990 (17649)   if relad=2 then error(15);
1991 (17667)   code1(23); if vartype<>'i' then merror(14,'08');
1992 (17696)   gpval(idpnt,true,vartyp2);
1993 (17712)   testto(' )');
1994 (17721) end {gpsec};
1995 (17721) 
1996 (17722) 
1997 (17722) begin {body of statement }
1998 (17722)   if token=' ;' then scan;
1999 (17739)   case token of
2000 (17739)     'id': assign;
2001 (17755) 
2002 (17758)     'if': begin {if}
2003 (17766)             scan; express; testtype('b');
2004 (17782)             testto('th'); scan;  savpc:=pc;
2005 (17795)             code3(37,0); statmnt;
2006 (17817)             if token='el' then begin {else}
2007 (17828)               k2:=pc; code3(36,0);
2008 (17846)               fixup(savpc); scan; statmnt;
2009 (17864)               fixup(k2)
2010 (17864)             end else fixup(savpc)
2011 (17877)           end; {if}
2012 (17890) 
2013 (17890)     'be':  begin {begin}
2014 (17898)             repeat
2015 (17898)               scan; statmnt
2016 (17902)             until token<>(' ;');
2017 (17913)             testto('en'); scan
2018 (17926)           end; {begin}
2019 (17933) 
2020 (17933)     'rp': begin {repeat}
2021 (17941)             savpc:=pc;
2022 (17941)             repeat
2023 (17949)               scan; statmnt
2024 (17953)             until token='un';
2025 (17964)             scan; express; testtype('b');
2026 (17984)             code3(37,savpc)
2027 (17986)           end {repeat};
2028 (17996) 
2029 (17999)     're': begin {read}
2030 (18007)             parse(' ('); scan;
2031 (18020)             if token=' @' then begin
2032 (18028)               scan; express; testtype('f');
2033 (18047)               device:=true;
2034 (18049)               code1(44); testto(' ,')
2035 (18064)             end
2036 (18070)             else begin
2037 (18073)               device:=false; code1(26)
2038 (18081)             end;
2039 (18087)             repeat

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 35

2040 (18087)               begin {main loop of read}
2041 (18087)                 if token=' ,' then scan;
2042 (18102)                 testto('id'); idpnt:=findid;
2043 (18117)                 if idpnt=0 then error(5);
2044 (18139)                 getvar;
2045 (18143)                 if relad=2 then error(15);
2046 (18161)                 case vartype of
2047 (18161)                   'i':  code1(28);
2048 (18180)                   'c':  code1(27);
2049 (18198)                   'p':  begin
2050 (18208)                         code1(27); code1(27);
2051 (18224)                         code1(53)
2052 (18226)                         end
2053 (18232)                   else error(114)
2054 (18237)                 end {case};
2055 (18245)                 gpval(idpnt,true,vartyp2)
2056 (18251)               end {mainloop of read}
2057 (18261)             until token<>' ,';
2058 (18268)             testto(' )'); scan;
2059 (18285)             if device then code1(45);
2060 (18300)           end {read};
2061 (18300) 
2062 (18303)     'wr','wl':
2063 (18316)           begin {write,writeln}
2064 (18319)             if token='wl' then wln:=true
2065 (18330)             else wln:=false;
2066 (18341)             scan;
2067 (18349)             if token=' (' then begin
2068 (18357)               scan;
2069 (18364)               if token=' @' then begin
2070 (18372)                 scan; express;
2071 (18383)                 if restype='q' then restype:='f';
2072 (18395)                 testtype('f');
2073 (18407)                 device:=true; code1(44);
2074 (18421)                 testto(' ,');
2075 (18430)               end else device:=false;
2076 (18435)               repeat
2077 (18439)                 if token=' ,' then scan;
2078 (18454)                 if (token=' )') and device
2079 (18462)                        and wln then
2080 (18467)                    {empty writeln except device}
2081 (18472)                    k2:=k2 {do nothing}
2082 (18475)                 else if token='st' then begin
2083 (18494)                   {string}
2084 (18497)                   code1(50);
2085 (18505)                   for k2:=1 to value[0]-1 do
2086 (18524)                     code1(ord(ident[k2])
2087 (18543)                         and 127);
2088 (18556)                   code1(ord(ident[value[0]])
2089 (18586)                       or 128);
2090 (18599)                   scan
2091 (18599)                 end else begin
2092 (18606)                   {expression}
2093 (18606)                   express;
2094 (18610)                   case restype of
2095 (18610)                     'i':  code1(30);
2096 (18629)                     'c':  code1(29);
2097 (18647)                     'q':  code1($57);
2098 (18665)                     's':  begin
2099 (18675)                             code1($58);

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 36

2100 (18683)                             code1($57);
2101 (18691)                           end;
2102 (18691)                     'p':  begin
2103 (18701)                             code1(22);
2104 (18709)                             code1(51);
2105 (18717)                             code1(29);
2106 (18725)                             code1(52);
2107 (18733)                             code1(29);
2108 (18741)                           end
2109 (18741)                     else merror(14,'09')
2110 (18749)                   end {case}
2111 (18757)                 end {expression}
2112 (18757)               until token<>' ,';
2113 (18764)               if wln then begin {writeln(..)}
2114 (18775)                 code2(32,13); code1(29);
2115 (18793)                 code2(32,10); code1(29);
2116 (18811)               end;
2117 (18811)               if device then code1(45);
2118 (18826)               testto(' )'); scan
2119 (18835)             end {if}
2120 (18839)             else if wln then begin {writeln}
2121 (18849)               code2(32,13); code1(29);
2122 (18867)               code2(32,10); code1(29);
2123 (18885)             end
2124 (18885)           end {write, writeln};
2125 (18885) 
2126 (18888)     'cs': case1; {case statement}
2127 (18903) 
2128 (18903)     'wh': begin {while}
2129 (18911)             scan; savpc:=pc; express;
2130 (18927)             testtype('b');
2131 (18935)             k2:=pc; code3(37,0);
2132 (18953)             testto('do'); scan; statmnt;
2133 (18970)             code3(36,savpc); fixup(k2)
2134 (18982)           end {while};
2135 (18992) 
2136 (18995)     'fo': begin {for}
2137 (19003)             parse('id'); assign;
2138 (19016)             if t0[idpnt]='pr' then error(1);
2139 (19044)             savtp1:=low(t0[idpnt]);
2140 (19057)             case token of
2141 (19062)               'to': k2:=1;
2142 (19076)               'dw': k2:=0
2143 (19091)               else merror(2,'to')
2144 (19105)             end {case of token};
2145 (19113)             scan; express; testtype(savtp1);
2146 (19131)             bottom1:=pc; code1(22);
2147 (19147)             gpval(idpnt,false,vartyp2);
2148 (19163)             code1(13-k2-k2);
2149 (19181)             savpc:=pc; code3(37,0);
2150 (19199)             testto('do'); scan; statmnt;
2151 (19216)             gpval(idpnt,false,vartyp2);
2152 (19232)             code1(21-k2);
2153 (19245)             gpval(idpnt,true,vartyp2);
2154 (19261)             code3(36,bottom1); fixup(savpc);
2155 (19283)             code3(35,-2);
2156 (19294)           end {for};
2157 (19294) 
2158 (19297)     'me': begin {mem}
2159 (19305)             parse(' ['); scan; express;

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 37

2160 (19322)             testtype('i');
2161 (19330)             testto(' ]'); parse(':=');
2162 (19348)             scan; express; code1(24);
2163 (19364)             testtype('i');
2164 (19372)           end {mem};
2165 (19372) 
2166 (19375)     'ca': begin {call}
2167 (19383)             parse(' ('); scan; express;
2168 (19400)             testtype('i');
2169 (19408)             testto(' )'); code1(25); scan
2170 (19425)           end {call};
2171 (19429) 
2172 (19432)     'op': openrw(47);
2173 (19448) 
2174 (19451)     'ow': openrw(48);
2175 (19467) 
2176 (19470)     'ob': openrw(80);
2177 (19486) 
2178 (19489)     'gb': begin
2179 (19497)             parse(' ('); scan; express;
2180 (19514)             testtype('f'); testto(' ,');
2181 (19531)             scan; express; testtype('i');
2182 (19547)             testto(' ,'); scan; testto('id');
2183 (19569)             idpnt:=findid;
2184 (19575)             if idpnt=0 then error(5);
2185 (19597)             getvar;
2186 (19601)             if relad<>0 then error(15);
2187 (19619)             code1($51); testferror;
2188 (19631)             gpval(idpnt,true,vartyp2);
2189 (19647)             testto(' )'); scan
2190 (19656)           end;
2191 (19660) 
2192 (19663)     'pb': begin
2193 (19671)             parse(' ('); scan; express;
2194 (19688)             testtype('f'); testto(' ,');
2195 (19705)             scan; express; testtype('i');
2196 (19721)             testto(' ,'); scan; express;
2197 (19738)             code1($52);testferror;
2198 (19750)             testto(' )');
2199 (19759)             scan
2200 (19759)           end;
2201 (19763) 
2202 (19766)     'ru': begin
2203 (19774)             code1($41); scan;
2204 (19786)           end;
2205 (19786) 
2206 (19789)     'fi': begin
2207 (19797)             code1(46); scan
2208 (19805)           end;
2209 (19809) 
2210 (19812)     'ge': gpsec(55);
2211 (19828) 
2212 (19831)     'pu': gpsec(56);
2213 (19847) 
2214 (19850)     'ex': begin {exit}
2215 (19858)             if level>0 then code1(1) else code1(0);
2216 (19887)             scan;
2217 (19891)           end;
2218 (19891) 
2219 (19894)     'cl': begin {close}

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 38

2220 (19902)             parse(' (');
2221 (19911)             repeat
2222 (19911)               scan; express; code1(49);
2223 (19927)               testtype('f');
2224 (19935)               testferror
2225 (19935)             until token<>' ,';
2226 (19946)             testto(' )'); scan;
2227 (19963)           end {close}
2228 (19963) 
2229 (19963)     else if (token<>'en') and (token<>' ;')
2230 (19981)       and (token<>'un') then begin
2231 (19992)       error(10); scan
2232 (20003)     end
2233 (20007)   end {case of statements}
2234 (20009) end;
2235 (20009) 
2236 (20010) { * findforw *          ( of block ) }
2237 (20010) 
2238 (20010) func findforw;
2239 (20010) 
2240 (20010) var i,j,sav1: integer;
2241 (20013)     done: boolean;
2242 (20013) 
2243 (20013)   func found(start: integer):boolean;
2244 (20013)   var ii,i9: integer;
2245 (20016)   begin {compare}
2246 (20016)     ii:= 0;
2247 (20020)     repeat
2248 (20024)       ii:=succ(ii);
2249 (20028)     until (ii >= 8) or
2250 (20040)       (ident[ii] <> idtab[start+ii]);
2251 (20073)     found:=(ii >= 8);
2252 (20084)   end {compare};
2253 (20088) 
2254 (20089) 
2255 (20089) begin {findforw}
2256 (20089)   i:=succ(forwpn);
2257 (20095)   repeat
2258 (20100)     i:=prec(i);
2259 (20104)     done := (i = 0);
2260 (20116)     if not done then
2261 (20120)       done := found(8*fortab[i]);
2262 (20152)   until done;
2263 (20156)   findforw:=i;
2264 (20163)   if i>0 then
2265 (20177)     if i=forwpn then forwpn:=forwpn-1
2266 (20197)     else begin
2267 (20207)       sav1:=fortab[i];
2268 (20216)       for j:=1 to forwpn-1 do
2269 (20236)       fortab[j]:=fortab[succ(j)];
2270 (20265)       fortab[forwpn]:=sav1;
2271 (20296)       findforw:=forwpn;
2272 (20304)       forwpn:=forwpn-1
2273 (20316)     end
2274 (20318) end {findforw};
2275 (20323) 
2276 (20324) 
2277 (20324) begin { *** body of block *** }
2278 (20324)   dpnt:=3; t2[bottom]:=pc;
2279 (20341)   code3(36,0);

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 39

2280 (20359)   stackpn1:=stackpnt; forwpn:=0;
2281 (20369) 
2282 (20373)   if token='co' then begin    { * const * }
2283 (20384)     scan;
2284 (20388)     repeat
2285 (20388)       deccon; testto(' ;'); scan
2286 (20401)     until token <> 'id';
2287 (20412)   end {const};
2288 (20416) 
2289 (20416)   if token='me' then memory;  { * mem * }
2290 (20431) 
2291 (20431)   if token='va' then variable;{ * var * }
2292 (20446) 
2293 (20446)   while (token='pr')or (token='fu') do begin
2294 (20466)     parlevel:=0;
2295 (20468)     case token of
2296 (20472)     'pr': begin               { * proc * }
2297 (20484)             parse('id'); npara:=0;
2298 (20495)             putsym('p','r'); cproc:=spnt;
2299 (20509)             level:=succ(level);
2300 (20521)           end;
2301 (20526)     'fu': begin               { * func * }
2302 (20537)             parse('id'); npara:=1;
2303 (20548)             putsym('f','i');
2304 (20562)             cproc:=spnt; level:=succ(level);
2305 (20574)             putsym('f','i');
2306 (20589)             t2[spnt]:=parlevel;
2307 (20598)             parlevel:=succ(parlevel);
2308 (20610)           end
2309 (20615)     end; {case of token}
2310 (20617)     if forwpn=0 then find:=0
2311 (20627)     else find:=findforw;
2312 (20642)     if find<>0 then begin
2313 (20653)       spnt:=spnt-npara-1;
2314 (20667)       cproc:=fortab[find];
2315 (20681)       fixup(t2[cproc]);
2316 (20708)     end;
2317 (20708)     scan; spnt1:=spnt;
2318 (20712)     dpnt1:=dpnt;
2319 (20720)     if token=' (' then parameter;
2320 (20743)     if t0[cproc]='fi' then function;
2321 (20767)     testto(' ;');
2322 (20776)     for i:=1 to npara do
2323 (20782)     t2[succ(spnt-i)]:=t2[succ(spnt-i)]
2324 (20819)           -parlevel;
2325 (20829)     scan;
2326 (20856)     if token='fw' then begin
2327 (20864)       if forwpn=8 then merror(13,'ov');
2328 (20888)       forwpn:=succ(forwpn);
2329 (20892)       fortab[forwpn]:=cproc;
2330 (20906)       t2[cproc]:=pc;
2331 (20923)       code3(36,0);
2332 (20941)       scan
2333 (20941)     end else block(cproc);
2334 (20958)     level:=prec(level);
2335 (20962)     dpnt:=dpnt1; spnt:=spnt1;
2336 (20975)     case high(t0[spnt]) of
2337 (20996)       'r':  t0[spnt]:=packed('t',low(t0[spnt]));
2338 (21030)       's':  t0[spnt]:=packed('u',low(t0[spnt]))
2339 (21068)     end {case};

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 40

2340 (21076)     testto(' ;'); scan
2341 (21085)   end {procedure of function};
2342 (21089) 
2343 (21092)   testto('be');     { * begin * }
2344 (21101)   if forwpn<>0 then merror(13,'ur');
2345 (21122)   fixup(t2[bottom]);
2346 (21141)   t2[bottom]:=pc;
2347 (21150)   scan;
2348 (21162)   code3(35,2*dpnt);
2349 (21177)   repeat
2350 (21177)     statmnt
2351 (21177)   until token='en';
2352 (21188)   scan;
2353 (21196)   if level>0 then code1(1) else code1(0);
2354 (21225)   stackpnt:=stackpn1;
2355 (21225) end {block};
2356 (21233) 
2357 (21234) { * savtable *    ( global) }
2358 (21234) 
2359 (21234) proc savtable; { save lib table in @ofno }
2360 (21234) 
2361 (21234) var i,j,num: integer;
2362 (21237)     vtype1: char;
2363 (21237) 
2364 (21237) begin
2365 (21237)   writeln(@ofno,spnt,',',pc+2);
2366 (21266)   for i:=1 to spnt do begin {for every entry }
2367 (21285)     for j:=1 to 8 do begin
2368 (21302)       write(@ofno,idtab[8*i+j])
2369 (21327)     end;
2370 (21331)     writeln(@ofno,',',t0[i],',',t1[i],',',
2371 (21388)       t2[i],',',t3[i]);
2372 (21425)     vtype1:=high(t0[i]);
2373 (21438)     if ((vtype1='p') or (vtype1='f') or
2374 (21457)       (vtype1='g')) and (t3[i]<>0) then begin
2375 (21483)       num:=stack[t3[i]];
2376 (21504)       write(@ofno,num);
2377 (21523)       for j:=1 to num do
2378 (21529)         write(@ofno,',',stack[t3[i]+j]);
2379 (21578)       write(@ofno,cr,lf);
2380 (21604)     end {then};
2381 (21604)   end {for}
2382 (21604) end {savtable};
2383 (21618) 
2384 (21619) { * main program * }
2385 (21619) 
2386 (21619) begin {main}
2387 (21619)   nlflg:=false;
2388 (21624)   init;scan;
2389 (21636)   case token of
2390 (21636)     'pg': begin
2391 (21648)             libflg:=false;
2392 (21650)             asetfile(pname,scyclus,sdrive,'Q');
2393 (21676)           end;
2394 (21676)     'li': begin
2395 (21687)             libflg:=true;
2396 (21689)             asetfile(pname,scyclus,sdrive,'T');
2397 (21715)           end
2398 (21715)     else
2399 (21715)       merror(2,'pg')

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE1         1/3/26 page 41

2400 (21723)   end {case}
2401 (21731)   parse('id');
2402 (21740)   i:=0;
2403 (21742)   repeat
2404 (21746)     i:=succ(i);
2405 (21750)   until (i>7) or (pname[i] = ':') or
2406 (21778)       (pname[i]<>uppercase(ident[i+1]));
2407 (21817)   if i<8 then
2408 (21827)     merror(2,packed(pname[0],pname[1]));
2409 (21862)     { name differs from filename }
2410 (21862)   parse(' ;');
2411 (21871)   if ofno<>nooutput then openw(ofno);
2412 (21887)   scan;
2413 (21891)   if (token='us') and (libflg=false) then begin
2414 (21907)     repeat
2415 (21910)       getlib; scan
2416 (21914)     until token<>' ,';
2417 (21925)     testto(' ;'); scan
2418 (21938)   end;
2419 (21942)   block(0); testto(' .');
2420 (21959)   if ofno<>nooutput then begin
2421 (21966)     write(@ofno,'E');
2422 (21977)     savebyte(pc and 255);
2423 (21990)     savebyte(pc shr 8);
2424 (22003)     close(ofno);
2425 (22009)     if libflg then begin
2426 (22013)       asetfile(pname,scyclus,sdrive,'L');
2427 (22038)       openw(ofno);
2428 (22044)       savtable;
2429 (22048)       close(ofno)
2430 (22048)     end
2431 (22054)   end else
2432 (22054)     runerr:=$87; {no loader file}
2433 (22063)   writeln;
2434 (22063)   writeln;
2435 (22069)   writeln('End compile');
2436 (22093)   writeln;
2437 (22093)   writeln('Code lenght:          ',pc);
2438 (22133)   writeln('Compiler stack size:  ',stackmax);
2439 (22167)   writeln('Ident stack size:     ',spntmax);
2440 (22201)   write('Pascal errors:        ');
2441 (22224)   if numerr>0 then write(invvid);
2442 (22237)   writeln(numerr,norvid);
2443 (22251)   if prt then begin
2444 (22255)     write(prtoff);
2445 (22261)     setemucom(9);
2446 (22269)   end;
2447 (22269)   close(fno);
2448 (22275)   { check whether second pass is not required }
2449 (22275)   if (runerr=0) and libflg then runerr:=-1;
2450 (22291) end {main}.
2451 (22296) 

End compile

Code lenght:          22295
Compiler stack size:  136
Ident stack size:     216
Pascal errors:        0
