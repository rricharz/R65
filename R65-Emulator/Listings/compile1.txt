
R65 Pascal program COMPILE1        11/11/23     page 1


                   1 (    4) {   ********************************
                   2 (    4)     *                              *
                   3 (    4)     *  R65 "Tiny" Pascal Compiler  *
                   4 (    4)     *            Pass 1            *
                   5 (    4)     *                              *
                   6 (    4)     ********************************
                   7 (    4) 
                   8 (    4) First version 1978 by rricharz
                   9 (    4) Original version 3.7 (20K)  01/08/82 rricharz
                  10 (    4) 
                  11 (    4) Recovered 2018 by rricharz (r77@bluewin.ch)
                  12 (    4) Improved 2018-2023 by rricharz
                  13 (    4) Version 4 with cpnt strings
                  14 (    4) 
                  15 (    4) Original derived from the publication by
                  16 (    4) Kin-Man Chung and Herbert Yen in
                  17 (    4) Byte, Volume 3, Number 9 and Number 10, 1978
                  18 (    4) 
                  19 (    4) Adapted for the R65 computer system and
                  20 (    4) substantially enhanced by rricharz 1978-1982
                  21 (    4) 
                  22 (    4) This is a Pascal derivative optimized for 8-bit
                  23 (    4) microprocessors (integer type is 16 bit) with
                  24 (    4) additional features (mem) to interact directly
                  25 (    4) with the microprocessor hardware. Only one
                  26 (    4) dimensional arrays and no records or user
                  27 (    4) defined types. Floating point numbers (real)
                  28 (    4) and file io to floppy disks are supported.
                  29 (    4) 
                  30 (    4) Precompiled libraries are merged in the loader.
                  31 (    4) The table of reserved words and the library
                  32 (    4) tables are loaded from the same drive as
                  33 (    4) the compiler.
                  34 (    4) 
                  35 (    4) The output of the program is a loader file for
                  36 (    4) the Pascal loader (compile2).
                  37 (    4) 
                  38 (    4) usage:
                  39 (    4)  compile1 name[.cy[,drv]] [xxx]
                  40 (    4)   where x:       l,p: no hard copy print
                  41 (    4)                  i,r: index bound checking
                  42 (    4)                  n: no loader file
                  43 (    4)   [] means not required                     }
                  44 (    4) 
                  45 (    4) program compile1;
                  46 (    4) 
                  47 (    4) uses syslib, arglib;
                  48 ( 1093) 
                  49 ( 1093) const title='R65 PASCAL COMPILER Version 4.2, Pass 1';
                  50 ( 1136) 
                  51 ( 1136)       table     =$97ff; {user ident table -1}
                  52 ( 1136)       idtab     =$95ff; {resword table -1}
                  53 ( 1136)       idlength  =64;    {max. length of ident}
                  54 ( 1136)       stacksize =256;   {stack size}
                  55 ( 1136)       pagelenght=60;    {no of lines per page}
                  56 ( 1136)       nooutput  =@0;
                  57 ( 1136)       maxfi     =3;     {max number of ins fls}
                  58 ( 1136) 
                  59 ( 1136) {

----------------------------------------------------------------------

R65 Pascal program COMPILE1        11/11/23     page 2

                  60 ( 1136) The compiler uses 2 fixed memory areas to store
                  61 ( 1136) the table of reserved words and the table of
                  62 ( 1136) idents. The top of the Pascal stack (endstk) is
                  63 ( 1136) adjusted accordingly. The reason for this hack
                  64 ( 1136) is speed and convenience. A normal Pascal array
                  65 ( 1136) of chars would store the chars as 16 bit
                  66 ( 1136) numers and would therefore require twice the
                  67 ( 1136) space. An array of packed chars would require
                  68 ( 1136) more coding and slow the scanner module of the
                  69 ( 1136) compiler down.                               }
                  70 ( 1136) 
                  71 ( 1136)     nresw=61;   {number of res. words, max 64}
                  72 ( 1136)     symbsize=256;     {id table entries}
                  73 ( 1136)     reswtabpos=$c600; { up to $c7ff }
                  74 ( 1136)     idtabpos=$be00;   { up to $c5ff }
                  75 ( 1136) 
                  76 ( 1136)     yesoutput=@255;
                  77 ( 1136) 
                  78 ( 1136) mem endstk  =$000e: integer;
                  79 ( 1136)     reswtab =reswtabpos: array[$200] of char&;
                  80 ( 1136)     idtab   =idtabpos: array[$800] of char&;
                  81 ( 1136) 
                  82 ( 1136) var tpos,pc,level,line,offset,dpnt,spnt,fipnt,
                  83 ( 1136)     npara,i,stackpnt,stackmax,spntmax,numerr
                  84 ( 1136)                               :integer;
                  85 ( 1136) 
                  86 ( 1136)     scyclus,sdrive,cdrive: integer;
                  87 ( 1136) 
                  88 ( 1136)     pname: array[15] of char;
                  89 ( 1136) 
                  90 ( 1136)     value: array[1] of integer;
                  91 ( 1136) 
                  92 ( 1136)     ch,restype,vartype:char;
                  93 ( 1136) 
                  94 ( 1136)     token: packed char;
                  95 ( 1136) 
                  96 ( 1136)     prt,libflg,icheck,ateof: boolean;
                  97 ( 1136) 
                  98 ( 1136)     fno,ofno: file;
                  99 ( 1136) 
                 100 ( 1136)     filstk: array[maxfi] of file;
                 101 ( 1136) 
                 102 ( 1136)     ident: array[idlength] of char;
                 103 ( 1136)     { Only the first 8 characters are
                 104 ( 1136)       used to find and differentiate ids }
                 105 ( 1136) 
                 106 ( 1136)     t0: array[symbsize] of packed char;
                 107 ( 1136)            {type of symbol}
                 108 ( 1136) 
                 109 ( 1136)         {High letter:
                 110 ( 1136)          a:array, c:constant, d;const parameter
                 111 ( 1136)          e:constant array parameter, f:function
                 112 ( 1136)          g:array function, h;8-bit memory var
                 113 ( 1136)          i:8-bit array memory variable
                 114 ( 1136)          m:16-bit memory variable
                 115 ( 1136)          n:16-bit array memory variable
                 116 ( 1136)          p:procedure
                 117 ( 1136)          q:indexed cpnt
                 118 ( 1136)          r,t:function result
                 119 ( 1136)          s,u:array function result

----------------------------------------------------------------------

R65 Pascal program COMPILE1        11/11/23     page 3

                 120 ( 1136)          v:variable, w:variable parameter
                 121 ( 1136)          x:variable array parameter
                 122 ( 1136) 
                 123 ( 1136)          Low letter:
                 124 ( 1136)          i:integer, c:char, p:packed char
                 125 ( 1136)          q:cpoint (pointer to char)
                 126 ( 1136)          r:real(array multiple of two)
                 127 ( 1136)          s:const cpnt
                 128 ( 1136)          f:file, b:boolean, u:undefined  }
                 129 ( 1136) 
                 130 ( 1136)     t1: array[symbsize] of integer;
                 131 ( 1136)          {level}
                 132 ( 1136)     t2: array[symbsize] of integer;
                 133 ( 1136)          {val,dis,addr}
                 134 ( 1136)     t3: array[symbsize] of integer;
                 135 ( 1136)          {stack pointer,size of array}
                 136 ( 1136) 
                 137 ( 1136)     reswcod:array[nresw] of packed char;
                 138 ( 1136) 
                 139 ( 1136)     stack: array[stacksize] of integer;
                 140 ( 1136) 
                 141 ( 1136) 
                 142 ( 1136) {       * savebyte *    (global)        }
                 143 ( 1136) 
                 144 ( 1136) proc savebyte(x: integer);
                 145 ( 1136) 
                 146 ( 1136) begin
                 147 ( 1136)     if ofno<>nooutput then begin
                 148 ( 1148)       write(@ofno,
                 149 ( 1151)         chr(((x and 255) shr 4)+ord('0')));
                 150 ( 1172)       write(@ofno,chr((x and 15)+ord('0')))
                 151 ( 1187)     end
                 152 ( 1190) end {savebyte};
                 153 ( 1190) 
                 154 ( 1191) {       * crlf *        (global)        }
                 155 ( 1191) 
                 156 ( 1191) proc newpage; forward;
                 157 ( 1194) 
                 158 ( 1194) proc crlf;
                 159 ( 1194)   var i: integer;
                 160 ( 1197) begin
                 161 ( 1197)   writeln;
                 162 ( 1199)   line:=succ(line);
                 163 ( 1209)   if (line div pagelenght)*pagelength=line
                 164 ( 1224)     then newpage;
                 165 ( 1236)   if prt then
                 166 ( 1236)     for i:=1 to 16 do write(@printer,' ')
                 167 ( 1265) end {crlf};
                 168 ( 1280) 
                 169 ( 1281) {       error message   (global)        }
                 170 ( 1281) 
                 171 ( 1281) proc merror(x: integer; code: packed char);
                 172 ( 1281) 
                 173 ( 1281) var i: integer;
                 174 ( 1284)     answer: char;
                 175 ( 1284) 
                 176 ( 1284) begin
                 177 ( 1284)   crlf; numerr:=succ(numerr);
                 178 ( 1294)   for i:=2 to tpos do write(' ');
                 179 ( 1320)   write('^'); crlf;

----------------------------------------------------------------------

R65 Pascal program COMPILE1        11/11/23     page 4

                 180 ( 1340)   write('*** (',numerr,',',pc,')   ');
                 181 ( 1363)   case x of
                 182 ( 1363)     01: write('Ident');
                 183 ( 1380)     02: write('Ident ',code,' expected');
                 184 ( 1416)     03: write('Var declaration');
                 185 ( 1442)     04: write('Const expected');
                 186 ( 1467)     05: write('Ident unknown');
                 187 ( 1491)     06: write('Cannot be assigned');
                 188 ( 1520)     07: write('Symbol table overflow');
                 189 ( 1552)     08: write('Stack overflow');
                 190 ( 1577)     09: write('Expression');
                 191 ( 1598)     10: write('Statement');
                 192 ( 1618)     11: write('Declaration');
                 193 ( 1640)     12: write('Constant');
                 194 ( 1659)     13: write('Forward reference: ',code);
                 195 ( 1698)     14: write('Type mismatch: ',code);
                 196 ( 1733)     15: write('Array size');
                 197 ( 1754)     16: write('Array (8-bit)');
                 198 ( 1778)     17: write('Real');
                 199 ( 1793)     18: write('File table overflow');
                 200 ( 1823)     19: write('Parameter')
                 201 ( 1843)   end {case};
                 202 ( 1845)   writeln;
                 203 ( 1845)   write('Continue?');
                 204 ( 1861)   read(@key,answer);
                 205 ( 1869)   if answer<>'Y' then begin
                 206 ( 1877)     crlf; write(prtoff); setemucom(9); close(fno);
                 207 ( 1901)     if (ofno<>nooutput) and (ofno<>yesoutput)
                 208 ( 1914)       then close(ofno);
                 209 ( 1925)     writeln('Aborting compile1 on request');
                 210 ( 1960)     abort
                 211 ( 1960)   end
                 212 ( 1964)   else crlf;
                 213 ( 1971)   if (ofno<>nooutput) and (ofno<>yesoutput)
                 214 ( 1984)     then close(ofno);
                 215 ( 1995)   ofno:=nooutput;
                 216 ( 1997) end {merror};
                 217 ( 2001) 
                 218 ( 2002) proc error(x: integer);
                 219 ( 2002) 
                 220 ( 2002) begin
                 221 ( 2002)   merror(x,'##')
                 222 ( 2014) end;
                 223 ( 2020) 
                 224 ( 2021) {       * push & pop *  (global) }
                 225 ( 2021) 
                 226 ( 2021) proc push(x: %integer);
                 227 ( 2021) 
                 228 ( 2021) begin
                 229 ( 2021)   if stackpnt>=stacksize then error(8)
                 230 ( 2039)   else stackpnt:=succ(stackpnt);
                 231 ( 2052)   if stackpnt>stackmax then stackmax:=stackpnt;
                 232 ( 2069)   stack[stackpnt]:=x;
                 233 ( 2081) end {push};
                 234 ( 2089) 
                 235 ( 2090) func pop: integer;
                 236 ( 2090) 
                 237 ( 2090) begin
                 238 ( 2090)   pop:=stack[stackpnt];
                 239 ( 2099)   stackpnt:=prec(stackpnt)

----------------------------------------------------------------------

R65 Pascal program COMPILE1        11/11/23     page 5

                 240 ( 2107) end {pop};
                 241 ( 2116) 
                 242 ( 2117) {       * newpage *     (global) }
                 243 ( 2117) 
                 244 ( 2117) proc newpage;
                 245 ( 2117) 
                 246 ( 2117) var i: integer;
                 247 ( 2120) 
                 248 ( 2120) begin
                 249 ( 2120)   if (line<>0) and prt then
                 250 ( 2129)     write(@printer,formfeed);
                 251 ( 2144)   writeln; { Do not count this line}
                 252 ( 2150)   if pname[0]<>'x' then begin
                 253 ( 2159)     write('R65 Pascal ');
                 254 ( 2174)     if libflg then write('library ')
                 255 ( 2190)     else write('program ');
                 256 ( 2202)     prtext16(output,pname);
                 257 ( 2216)   end;
                 258 ( 2216)   tab(34);
                 259 ( 2224)   prtdate(output); write('     ');
                 260 ( 2238)   writeln('page ',(line div pagelenght)+1);
                 261 ( 2261)   writeln;
                 262 ( 2261) end {newpage};
                 263 ( 2267) 
                 264 ( 2268) {       * getchr *      (global) }
                 265 ( 2268) 
                 266 ( 2268) proc getchr;
                 267 ( 2268) 
                 268 ( 2268)   proc writenum(i: integer);
                 269 ( 2271)   begin
                 270 ( 2271)     if i<=999 then write(' ');
                 271 ( 2289)     if i<=99 then write(' ');
                 272 ( 2301)     if i<=9 then write(' ');
                 273 ( 2313)     write(i);
                 274 ( 2318)   end;
                 275 ( 2318) 
                 276 ( 2319) begin
                 277 ( 2319)   if ateof then begin
                 278 ( 2325)     writeln('Unexpected eof');
                 279 ( 2349)     abort;
                 280 ( 2353)   end else begin
                 281 ( 2356)     read(@fno,ch);
                 282 ( 2366)     if ch=cr then begin
                 283 ( 2374)       crlf;
                 284 ( 2381)       writenum(line); write(' (');
                 285 ( 2394)       if (pc+2)<9999 then write(' ');
                 286 ( 2410)       writenum(pc+2); write(') ');
                 287 ( 2426)       ch:=' ';
                 288 ( 2428)     end {if}
                 289 ( 2432)     else if ch=eof then begin
                 290 ( 2442)       ateof:=true;
                 291 ( 2447)       { we need to suppy one more char }
                 292 ( 2451)       { for end. at end of file to work properly }
                 293 ( 2451)       ch:=' ';
                 294 ( 2453)     end {else if}
                 295 ( 2457)     else write(ch);
                 296 ( 2465)   end;
                 297 ( 2465) end {getchr};
                 298 ( 2465) 
                 299 ( 2466) {       * splitconv *   (global) }

----------------------------------------------------------------------

R65 Pascal program COMPILE1        11/11/23     page 6

                 300 ( 2466) 
                 301 ( 2466) proc splitconv(a: array[1] of %integer;
                 302 ( 2466)   var b:array[1] of %integer);
                 303 ( 2466) 
                 304 ( 2466) begin
                 305 ( 2466)   b:=a;
                 306 ( 2471) end;
                 307 ( 2483) 
                 308 ( 2484) {       * init *        (global) }
                 309 ( 2484) 
                 310 ( 2484) proc init;
                 311 ( 2484) 
                 312 ( 2484) const char96=chr(20);
                 313 ( 2487) 
                 314 ( 2487) var i,j,dummy: integer;
                 315 ( 2487)     dch: char;
                 316 ( 2487)     pch: packed char;
                 317 ( 2487)     request: array[15] of char;
                 318 ( 2487)     default: boolean;
                 319 ( 2487) 
                 320 ( 2487) begin {init}
                 321 ( 2487)   ateof:=false;
                 322 ( 2491)   cdrive:=fildrv; { drive of compile program }
                 323 ( 2502)   fipnt:=-1;
                 324 ( 2504)   endstk:=idtabpos-144;
                 325 ( 2514)   pc:=2; dpnt:=0; spnt:=0; offset:=2;
                 326 ( 2538)   npara:=0; level:=0;
                 327 ( 2550)   stackpnt:=0; libflg:=false;
                 328 ( 2562)   stackmax:=0;spntmax:=0; numerr:=0;
                 329 ( 2580)   t0[0]:='vi'; t1[0]:=0; t2[0]:=0; t3[0]:=0;
                 330 ( 2613)   { prepare resword table }
                 331 ( 2617)   writeln('Reading list of reserved words');
                 332 ( 2654)   asetfile('RESWORDS:W      ',0,cdrive,'W');
                 333 ( 2686)   openr(fno);
                 334 ( 2692)   for i:=0 to nresw do begin
                 335 ( 2709)     read(@fno,pch,dch);
                 336 ( 2726)     reswcod[i]:=pch;
                 337 ( 2731)     for j:=0 to 7 do reswtab[8*i+j]:=' ';
                 338 ( 2770)     j:=0;
                 339 ( 2793)     while (j<8) and (dch<>cr) do begin
                 340 ( 2815)       read(@fno,dch);
                 341 ( 2825)       if (dch<>cr) then
                 342 ( 2833)         reswtab[8*i+j]:=dch;
                 343 ( 2848)       j:=succ(j)
                 344 ( 2859)     end;
                 345 ( 2868)     while (dch<>cr) and (dch<>eof) do
                 346 ( 2885)       read(@fno,dch)
                 347 ( 2894)   end;
                 348 ( 2903)   close(fno);
                 349 ( 2923) 
                 350 ( 2923)   writeln;
                 351 ( 2923)   writeln(title);
                 352 ( 2940) 
                 353 ( 2940)   sdrive:=1; {default drive for source }
                 354 ( 2946)   scyclus:=0;
                 355 ( 2948)   agetstring(pname,default,scyclus,sdrive);
                 356 ( 2992) 
                 357 ( 2992)   agetstring(request,default,dummy,dummy);
                 358 ( 3032)   icheck:=false;
                 359 ( 3034)   prt:=true; ofno:=yesoutput;

----------------------------------------------------------------------

R65 Pascal program COMPILE1        11/11/23     page 7

                 360 ( 3046)   if not default then begin
                 361 ( 3055)     if request[0]<>'/' then argerror(103);
                 362 ( 3078)     for i:=1 to 8 do
                 363 ( 3086)       case request[i] of
                 364 ( 3099)         'P','L': prt:=false;
                 365 ( 3119)         'I','R': icheck:=true;
                 366 ( 3142)         'N': ofno:=nooutput;
                 367 ( 3158)         ' ': begin end
                 368 ( 3172)         else argerror(104)
                 369 ( 3177)       end; {case}
                 370 ( 3199)   end;
                 371 ( 3199) 
                 372 ( 3199)   asetfile(pname,scyclus,sdrive,'P');
                 373 ( 3221)   openr(fno);
                 374 ( 3227)   scyclus:=filcyc; { may have changed }
                 375 ( 3235) 
                 376 ( 3235)   {save cyclus and drive for compile2}
                 377 ( 3235)   arglist[8]:=scyclus;
                 378 ( 3237)   arglist[9]:=sdrive;
                 379 ( 3251)   numarg:=1;
                 380 ( 3265) 
                 381 ( 3269)   if prt then begin
                 382 ( 3273)     write(prton);
                 383 ( 3279)     setemucom(8);
                 384 ( 3287)   end
                 385 ( 3287) 
                 386 ( 3287)   line:=0; newpage; crlf; line:=1;
                 387 ( 3303)   write('   1 (    4) '); getchr
                 388 ( 3321) end {init};
                 389 ( 3325) 
                 390 ( 3326) 
                 391 ( 3326) { ############################# }
                 392 ( 3326) {       *scan*              (global)    }
                 393 ( 3326) { ############################# }
                 394 ( 3326) { scan input and make tokens }
                 395 ( 3326) 
                 396 ( 3326) proc scan;
                 397 ( 3326) 
                 398 ( 3326) var count,ll,hh,i,i1,co: integer;
                 399 ( 3329)     name: array[7] of char;
                 400 ( 3329) 
                 401 ( 3329) {       * compresw*     (of scan)       }
                 402 ( 3329) 
                 403 ( 3329) func compresw(index: integer);
                 404 ( 3329) 
                 405 ( 3329) var addr,ci,i: integer;
                 406 ( 3332) 
                 407 ( 3332) begin
                 408 ( 3332)   addr:=8*index; i:=0;
                 409 ( 3347)   repeat
                 410 ( 3351)     ci:=ord(ident[i+1])-ord(reswtab[addr+i]);
                 411 ( 3376)     i:=succ(i)
                 412 ( 3381)   until (ci<>0) or (i>=8);
                 413 ( 3404)   compresw:=ci
                 414 ( 3408) end {compresw};
                 415 ( 3416) 
                 416 ( 3417) {       * clear *       (of scan)              }
                 417 ( 3417) 
                 418 ( 3417) proc clear; {clears 8 chars of identifier}
                 419 ( 3417) 

----------------------------------------------------------------------

R65 Pascal program COMPILE1        11/11/23     page 8

                 420 ( 3417) var i: integer;
                 421 ( 3420) 
                 422 ( 3420) begin
                 423 ( 3420)   for i:=1 to 8 do ident[i]:=' '
                 424 ( 3443) end;
                 425 ( 3463) 
                 426 ( 3464) {       * pack *        (of scan)              }
                 427 ( 3464) 
                 428 ( 3464) proc pack;  {packs token and ch to token }
                 429 ( 3464) 
                 430 ( 3464) begin
                 431 ( 3464)   token:=packed(low(token),ch); getchr
                 432 ( 3483) end;
                 433 ( 3487) 
                 434 ( 3488) {       * setval *      (of scan)              }
                 435 ( 3488) 
                 436 ( 3488) proc setval;
                 437 ( 3488) 
                 438 ( 3488) var r: real;
                 439 ( 3491)     n,n1: integer;
                 440 ( 3491)     ems: boolean;
                 441 ( 3491) 
                 442 ( 3491)   func times10(r:real):real;
                 443 ( 3491)   { slightly more accurate than 10.0*r }
                 444 ( 3491)   var r2,r4:real;
                 445 ( 3494)   begin
                 446 ( 3494)     r2:=r+r;
                 447 ( 3502)     r4:=r2+r2;
                 448 ( 3521)     times10:=r2+r4+r4;
                 449 ( 3547)   end;
                 450 ( 3560) 
                 451 ( 3561) begin
                 452 ( 3561)   r:=0.0;
                 453 ( 3569)   repeat
                 454 ( 3575)     r:=times10(r)+conv(ord(ch)-ord('0'));
                 455 ( 3596)     getchr;
                 456 ( 3608)   until (ch<'0') or (ch>'9');
                 457 ( 3622)   if ch<>'.' then begin {numeric integer}
                 458 ( 3636)     token:='nu';
                 459 ( 3639)     value[0]:=trunc(r+0.5);
                 460 ( 3658)   end
                 461 ( 3663)   else begin {numeric real}
                 462 ( 3666)     n:=0; getchr;
                 463 ( 3676)     while (ch<='9') and (ch>='0') do begin
                 464 ( 3694)       r:=times10(r)+conv(ord(ch)-ord('0'));
                 465 ( 3715)       n:=prec(n); getchr
                 466 ( 3732)     end;
                 467 ( 3736)     if ch='e' then begin
                 468 ( 3746)       ems:=false; getchr;
                 469 ( 3759)       case ch of
                 470 ( 3759)         '+': getchr;
                 471 ( 3774)         '-': begin ems:=true; getchr end
                 472 ( 3794)       end;
                 473 ( 3796)       if (ch>'9') or (ch<'0') then error(17)
                 474 ( 3816)       else begin
                 475 ( 3825)         n1:=ord(ch)-ord('0');
                 476 ( 3831)         getchr;
                 477 ( 3840)         if (ch<='9') and (ch>='0') then begin
                 478 ( 3855)           n1:=10*n1+ord(ch)-ord('0');
                 479 ( 3872)           getchr

----------------------------------------------------------------------

R65 Pascal program COMPILE1        11/11/23     page 9

                 480 ( 3877)         end;
                 481 ( 3881)         if ems then n:=n-n1 else n:=n+n1
                 482 ( 3908)       end
                 483 ( 3908)     end;
                 484 ( 3917)     while n>0 do begin
                 485 ( 3927)       n:=prec(n);
                 486 ( 3931)       r:=times10(r);
                 487 ( 3950)     end;
                 488 ( 3956)     while n<0 do begin
                 489 ( 3969)       n:=succ(n); r:=0.1*r;
                 490 ( 3984)     end;
                 491 ( 3997)     splitconv(r,value);
                 492 ( 4024)     token:='ru'
                 493 ( 4024)   end
                 494 ( 4027) end {setval};
                 495 ( 4031) 
                 496 ( 4032) {       * setid *       (of scan)              }
                 497 ( 4032) 
                 498 ( 4032) proc setid; {sets one char to ident}
                 499 ( 4032) 
                 500 ( 4032) begin
                 501 ( 4032)   if count<=idlength then begin
                 502 ( 4044)     ident[count]:=ch; count:=succ(count)
                 503 ( 4059)   end;
                 504 ( 4068)   getchr;
                 505 ( 4072) end {setid};
                 506 ( 4072) 
                 507 ( 4073) begin { ***** body of scan ***** }
                 508 ( 4073)   count:=1; while ch=' ' do getchr;
                 509 ( 4095)   tpos:=curpos;
                 510 ( 4101) 
                 511 ( 4105)   if (ch<'a') or (ch>'z') then begin {main if}
                 512 ( 4123)     if (ch<'0') or (ch>'9') then begin {symb}
                 513 ( 4141)       token:=packed(' ',ch); getchr;
                 514 ( 4156)       case low(token) of
                 515 ( 4160)         '<': if (ch='=') or (ch='>') then pack;
                 516 ( 4190)         '>',':': if (ch='=') then pack;
                 517 ( 4221)         '{': begin repeat
                 518 ( 4231)                getchr until ch='}'; getchr; scan
                 519 ( 4249)              end;
                 520 ( 4253)         '$': begin {hex constant}
                 521 ( 4263)                token:='nu'; value[0]:=0;
                 522 ( 4274)                while ((ch>='0')and(ch<='9'))
                 523 ( 4292)                      or((ch>='a')and(ch<='f'))
                 524 ( 4307)                      do begin
                 525 ( 4312)                  if ch>'9' then
                 526 ( 4318)                    value[0]:=(value[0] shl 4)
                 527 ( 4332)                      +ord(ch)-ord('a')+10
                 528 ( 4341)                  else
                 529 ( 4343)                    value[0]:=(value[0] shl 4)
                 530 ( 4361)                      +ord(ch)-ord('0');
                 531 ( 4369)                  getchr
                 532 ( 4374)                end {do}
                 533 ( 4378)              end; {hex constant}
                 534 ( 4384)         chr(39): begin {string}
                 535 ( 4391)                token:='st';
                 536 ( 4394)                repeat setid until ch=chr(39);
                 537 ( 4408)                value[0]:=prec(count); getchr
                 538 ( 4424)               end
                 539 ( 4428)       end {case of token}

----------------------------------------------------------------------

R65 Pascal program COMPILE1        11/11/23     page 10

                 540 ( 4430)     end {special symbols}
                 541 ( 4430)     else setval {numeric value}
                 542 ( 4437)   end {main if}
                 543 ( 4437)   else begin {ident}
                 544 ( 4440)     clear;
                 545 ( 4444)     repeat
                 546 ( 4444)       setid
                 547 ( 4444)       until (ch<'0') or (ch>'z') or
                 548 ( 4462)         ((ch>'9') and (ch<'A')) or
                 549 ( 4478)         ((ch>'Z') and (ch<'a'));
                 550 ( 4494)     ll:=0; hh:=nresw; {look up in resword table}
                 551 ( 4510)     repeat
                 552 ( 4510)       i:=(ll+hh) shr 1; co:=compresw(i);
                 553 ( 4538)       if (co<0) then hh:=prec(i)
                 554 ( 4552)       else ll:=succ(i);
                 555 ( 4568)       until (co=0) or (ll>hh);
                 556 ( 4589)     if (co=0) then
                 557 ( 4600)       token:=reswcod[i] {reserved word found}
                 558 ( 4607)     else token:='id' {ident}
                 559 ( 4621)   end {odent}
                 560 ( 4625) end {scan};
                 561 ( 4625) 
                 562 ( 4626) { * testto/parse * }
                 563 ( 4626) 
                 564 ( 4626) { parce source for specific token; else error }
                 565 ( 4626) 
                 566 ( 4626) proc testto(x: packed char); { current token }
                 567 ( 4626) begin
                 568 ( 4626)   if token<>x then merror(2,x)
                 569 ( 4645) end;
                 570 ( 4655) 
                 571 ( 4656) proc parse(x: packed char); { next token }
                 572 ( 4656) begin
                 573 ( 4656)   scan; testto(x);
                 574 ( 4675) end;
                 575 ( 4675) 
                 576 ( 4676) { * getlib * }
                 577 ( 4676) 
                 578 ( 4676) proc getlib;  { read library data }
                 579 ( 4676) 
                 580 ( 4676) var i,j,nent,addr,size,num,x,base: integer;
                 581 ( 4679)     libfil: file;
                 582 ( 4679)     ch,ltyp2,dummy: char;
                 583 ( 4679)     name: array[7] of char;
                 584 ( 4679) 
                 585 ( 4679) begin
                 586 ( 4679)   scan; if token=' ,' then scan;
                 587 ( 4700)   testto('id');
                 588 ( 4709)   base:=pc-2;
                 589 ( 4715)   if (ofno<>nooutput) then write(@ofno,'L');
                 590 ( 4738)   for i:=0 to 7 do begin
                 591 ( 4755)     name[i]:=ident[succ(i)];
                 592 ( 4764)     if ofno<>nooutput then
                 593 ( 4778)       write(@ofno,ident[succ(i)])
                 594 ( 4792)   end;
                 595 ( 4798)   write(prtoff);
                 596 ( 4815)   asetfile(name&'        ',0,cdrive,'L');
                 597 ( 4845)   openr(libfil);  { get table file }
                 598 ( 4851)   read(@libfil,nent,size);
                 599 ( 4866)   {including cr,lf}

----------------------------------------------------------------------

R65 Pascal program COMPILE1        11/11/23     page 11

                 600 ( 4867)   for i:=succ(spnt) to spnt+nent do begin
                 601 ( 4894)     if spnt>symbsize then error(7);
                 602 ( 4913)     spnt:=succ(spnt); addr:=8*i+1;
                 603 ( 4931)     for j:=0 to 7 do begin
                 604 ( 4953)       read(@libfil,ch);
                 605 ( 4963)       idtab[addr+j]:=ch
                 606 ( 4973)     end;
                 607 ( 4984)     read(@libfil,ch);
                 608 ( 5008)     read(@libfil,t0[i],dummy,t1[i],t2[i],t3[i]);
                 609 ( 5057)     t1[i]:=t1[i]+level;
                 610 ( 5070)     ltyp2:=high(t0[i]);
                 611 ( 5087)     if (ltyp2='p')or(ltyp2='f')
                 612 ( 5105)       or(ltyp2='g') then begin
                 613 ( 5115)       t2[i]:=t2[i]+base;
                 614 ( 5130)       if t3[i]<>0 then begin {stack data}
                 615 ( 5153)         read(@libfil,num);
                 616 ( 5163)         push(num); t3[i]:=stackpnt;
                 617 ( 5178)         for j:=1 to num do begin
                 618 ( 5205)           read(@libfil,x);
                 619 ( 5215)           push(x);
                 620 ( 5226)         end {for j};
                 621 ( 5226)       end {stack data}
                 622 ( 5240)     end {if ltyp2}
                 623 ( 5240)   end {for i}
                 624 ( 5240)   level:=succ(level); pc:=pc+size; offset:=pc;
                 625 ( 5276)   close(libfil);
                 626 ( 5290)   if spnt>spntmax then spntmax:=spnt;
                 627 ( 5302)   if stackpnt>stackmax then stackmax:=stackpnt;
                 628 ( 5322)   if prt then write(prton);
                 629 ( 5340) end {getlib};
                 630 ( 5340) 
                 631 ( 5341) 
                 632 ( 5341) { #################################### }
                 633 ( 5341) {       * block * (global): handle one block }
                 634 ( 5341) { #################################### }
                 635 ( 5341) 
                 636 ( 5341) 
                 637 ( 5341) proc block(bottom: integer);
                 638 ( 5341) 
                 639 ( 5341) var l,f9,i,n,stackpn1,forwpn,find,cproc,
                 640 ( 5344)     spnt1,dpnt1,parlevel: integer;
                 641 ( 5344)     fortab: array[8] of integer;
                 642 ( 5344) 
                 643 ( 5344) { * find ident *    (of block) }
                 644 ( 5344) { this is a fast version for compiler speed }
                 645 ( 5344) 
                 646 ( 5344) func findid; {search in table for id }
                 647 ( 5344) 
                 648 ( 5344) var k,i: integer;
                 649 ( 5347)     id1: char;
                 650 ( 5347) 
                 651 ( 5347) begin
                 652 ( 5347) 
                 653 ( 5347)   i:=1; k:=8*spnt+9; id1:=ident[1];
                 654 ( 5371) 
                 655 ( 5379)   repeat
                 656 ( 5379)     k:=k-8;
                 657 ( 5385)     while (idtab[k]<>id1) and (k>0) do k:=k-8;
                 658 ( 5421)     if k>0 then begin
                 659 ( 5436)        i:=1;

----------------------------------------------------------------------

R65 Pascal program COMPILE1        11/11/23     page 12

                 660 ( 5441)        repeat i:=succ(i)
                 661 ( 5445)          until (i>8) or
                 662 ( 5461)              (idtab[k+i-1]<>ident[i]);
                 663 ( 5487)     end;
                 664 ( 5491)     until (i>8) or (k<=0);
                 665 ( 5505)   if k<=0 then begin
                 666 ( 5516)     findid:=0;
                 667 ( 5521)   end
                 668 ( 5525)   else
                 669 ( 5525)     findid:=(k-1) shr 3;
                 670 ( 5537) end;
                 671 ( 5542) 
                 672 ( 5543) { * code1 *      (of block) }
                 673 ( 5543) 
                 674 ( 5543) proc code1(x: %integer);  {set one byte p-code}
                 675 ( 5543) begin
                 676 ( 5543)   savebyte(x); pc:=succ(pc)
                 677 ( 5558) end;
                 678 ( 5567) 
                 679 ( 5568) { * code2 *    (of block) }
                 680 ( 5568) 
                 681 ( 5568) proc code2(x,y: integer);
                 682 ( 5568) begin
                 683 ( 5568)   code1(x); code1(y);
                 684 ( 5593) end;
                 685 ( 5593) 
                 686 ( 5594) { * code3 *    (of block) }
                 687 ( 5594) 
                 688 ( 5594) proc code3(x: integer; y1: %integer);
                 689 ( 5594) 
                 690 ( 5594) var y: integer;
                 691 ( 5597) 
                 692 ( 5597) begin {code3}
                 693 ( 5597)   y:=y1;
                 694 ( 5599)   if (x=34) and (y>=0) and (y<256) then
                 695 ( 5630)     code2(32,y)
                 696 ( 5636)   else begin
                 697 ( 5649)     if (x=35) and (y>-128) and (y<=127) then
                 698 ( 5672)       begin
                 699 ( 5673)         if (y<0) then y:=y+256;
                 700 ( 5693)         code2(33,y);
                 701 ( 5710)       end
                 702 ( 5710)     else begin
                 703 ( 5713)       if (x>=36) and (x<=38) then y:=y-pc-1;
                 704 ( 5742)       code1(x); code1(y and 255);
                 705 ( 5770)       code1(y shr 8);
                 706 ( 5783)     end
                 707 ( 5783)   end
                 708 ( 5783) end {code3};
                 709 ( 5783) 
                 710 ( 5784) { * testtype *      (of block) }
                 711 ( 5784) 
                 712 ( 5784) proc testtype(ttype: char);
                 713 ( 5784) 
                 714 ( 5784) begin
                 715 ( 5784)   if restype<>ttype then
                 716 ( 5793)     if (restype<>'u') and (ttype<>'u') then
                 717 ( 5815)       merror(14,packed(ttype,restype));
                 718 ( 5836) end;
                 719 ( 5836) 

----------------------------------------------------------------------

R65 Pascal program COMPILE1        11/11/23     page 13

                 720 ( 5837) { * putsym *   (of block) }
                 721 ( 5837) 
                 722 ( 5837) proc putsym(ltyp1,ltyp2: char);
                 723 ( 5837) 
                 724 ( 5837) var i,addr: integer;
                 725 ( 5840) begin
                 726 ( 5840)   if spnt>symbsize then error(7)
                 727 ( 5855)   else spnt:=succ(spnt);
                 728 ( 5868)   if spnt>spntmax then spntmax:=spnt;
                 729 ( 5885)   t0[spnt]:=packed(ltyp1,ltyp2);
                 730 ( 5906)   t3[spnt]:=0;
                 731 ( 5916)   addr:=8*spnt;
                 732 ( 5922)   for i:=1 to 8 do idtab[addr+i]:=ident[i];
                 733 ( 5961)   if ltyp1='v' then begin
                 734 ( 5993)     t2[spnt]:=dpnt; dpnt:=succ(dpnt);
                 735 ( 6012)   end;
                 736 ( 6017)   t1[spnt]:=level
                 737 ( 6021) end {putsym};
                 738 ( 6029) 
                 739 ( 6030) { * checkindex *  (of block) }
                 740 ( 6030) 
                 741 ( 6030) proc checkindex(lowlim,highlim: integer);
                 742 ( 6030) begin
                 743 ( 6030)   if icheck then begin
                 744 ( 6039)     code3($40,lowlim-1);
                 745 ( 6057)     code2(highlim and 255, highlim shr 8)
                 746 ( 6070)   end
                 747 ( 6077) end;
                 748 ( 6077) 
                 749 ( 6078) { * getcon *      (of block) }
                 750 ( 6078) 
                 751 ( 6078) func getcon;
                 752 ( 6078) 
                 753 ( 6078) var idpnt,val,ii: integer;
                 754 ( 6081)     rval: real;
                 755 ( 6081)     sign: char;
                 756 ( 6081) begin
                 757 ( 6081)   restype:='i';
                 758 ( 6085)   if token=' -' then begin
                 759 ( 6097)     sign:='-'; scan
                 760 ( 6106)   end else begin
                 761 ( 6113)     sign:='+'; if token=' +' then scan
                 762 ( 6127)   end;
                 763 ( 6134)   case token of
                 764 ( 6134)     'nu': val:=value[0];
                 765 ( 6148)     'ru': begin val:=value[0];
                 766 ( 6169)             restype:='r' end;
                 767 ( 6183)     'st': if value[0]=1 then begin
                 768 ( 6203)             restype:='c';
                 769 ( 6208)             val:=ord(ident[1])
                 770 ( 6214)           end else if value[0]=2 then begin
                 771 ( 6234)             val:=(ord(ident[1]) shl 8) +
                 772 ( 6246)               ord(ident[2]);
                 773 ( 6252)             restype:='p';
                 774 ( 6259)           end else if value[0]>2 then begin
                 775 ( 6275)             val:=pc;
                 776 ( 6278)             for ii:=1 to value[0] do
                 777 ( 6294)                         code1(ord(ident[ii]));
                 778 ( 6321)             code1(0); value[0]:=0; restype:='s';
                 779 ( 6353)           end else error(15);

----------------------------------------------------------------------

R65 Pascal program COMPILE1        11/11/23     page 14

                 780 ( 6368)     'cr': begin parse(' ('); scan; val:=getcon;
                 781 ( 6398)             if (val>127) or (val<0) then
                 782 ( 6416)               error(12);
                 783 ( 6428)             testtype('i');
                 784 ( 6436)             restype:='c'; parse(' )');
                 785 ( 6451)           end;
                 786 ( 6451)     'tr': begin val:=1; restype:='b' end;
                 787 ( 6474)     'fa': begin val:=0; restype:='b' end;
                 788 ( 6497)     'cp': begin
                 789 ( 6508)             scan; val:=getcon;
                 790 ( 6518)             testtype('i'); restype:='q';
                 791 ( 6532)           end;
                 792 ( 6536)     ' @': begin scan; val:=getcon;
                 793 ( 6557)             testtype('i'); restype:='f'
                 794 ( 6569)           end
                 795 ( 6571)     else begin
                 796 ( 6578)       testto('id'); idpnt:=findid;
                 797 ( 6593)       if (idpnt>0) and (high(t0[idpnt])='c')
                 798 ( 6615)       then begin
                 799 ( 6617)         val:=t2[idpnt];
                 800 ( 6624)         restype:=low(t0[idpnt]);
                 801 ( 6640)         if restype='r' then
                 802 ( 6651)           value[1]:=t3[idpnt];
                 803 ( 6661)       end
                 804 ( 6669)       else begin error(4); val:=0;
                 805 ( 6682)         restype:='i'
                 806 ( 6686)       end
                 807 ( 6688)     end
                 808 ( 6692)   end {case};
                 809 ( 6694)   if sign='-' then
                 810 ( 6700)     case restype of
                 811 ( 6704)       'i': getcon:=-val;
                 812 ( 6715)       'r': begin value[0]:=val;
                 813 ( 6736)              splitconv(value,rval);
                 814 ( 6768)              splitconv(-rval,value);
                 815 ( 6793)              getcon:=value[0]
                 816 ( 6795)            end
                 817 ( 6795)       else error(12)
                 818 ( 6808)     end {case}
                 819 ( 6816)   else getcon:=val;
                 820 ( 6819) end {getcon};
                 821 ( 6827) 
                 822 ( 6828) { * deccon *         ( of block ) }
                 823 ( 6828) 
                 824 ( 6828) proc deccon;    { declare constant }
                 825 ( 6828) begin
                 826 ( 6828)   if token=' ;' then scan;
                 827 ( 6848)   testto('id');
                 828 ( 6857)   putsym('c','i');
                 829 ( 6867)   parse(' ='); scan;
                 830 ( 6880)   t2[spnt]:=getcon;
                 831 ( 6890)   if (restype='r') then t3[spnt]:=value[1];
                 832 ( 6910)   if restype<>'i' then
                 833 ( 6924)     t0[spnt]:=packed('c',restype);
                 834 ( 6939)   scan
                 835 ( 6943) end {deccon};
                 836 ( 6947) 
                 837 ( 6948) { * decvar *          ( of block ) }
                 838 ( 6948) 
                 839 ( 6948) proc decvar(typ1,typ2: char);

----------------------------------------------------------------------

R65 Pascal program COMPILE1        11/11/23     page 15

                 840 ( 6948) begin
                 841 ( 6948)   if token=' ,' then scan;
                 842 ( 6968)   testto('id');
                 843 ( 6977)   putsym(typ1,typ2);
                 844 ( 6991)   scan;
                 845 ( 6995) end {decvar};
                 846 ( 6995) 
                 847 ( 6996) { * gettype *         ( of block ) }
                 848 ( 6996) 
                 849 ( 6996) proc gettype(var typ2: char;
                 850 ( 6996)   var aflag,uflag: boolean; var n: integer);
                 851 ( 6996) 
                 852 ( 6996) begin
                 853 ( 6996)   aflag:=false; n:=0; uflag:=false;
                 854 ( 7015)   scan;
                 855 ( 7023)   if token='ar' then begin
                 856 ( 7031)     parse(' ['); scan;
                 857 ( 7047)     n:=getcon; testtype('i');
                 858 ( 7065)     if (n<1) then begin error(15); n:=1 end;
                 859 ( 7089)     parse(' ]'); parse('of'); scan;
                 860 ( 7111)     aflag:=true
                 861 ( 7111)   end;
                 862 ( 7117)   if token=' %' then begin
                 863 ( 7125)     scan; uflag:=true
                 864 ( 7132)   end;
                 865 ( 7138)   case token of
                 866 ( 7138)     'in': typ2:='i';
                 867 ( 7152)     'ch': typ2:='c';
                 868 ( 7169)     'pa': begin parse ('ch'); typ2:='p' end;
                 869 ( 7199)     'bo': typ2:='b';
                 870 ( 7212)     'rl': begin typ2:='r'; aflag:=true;
                 871 ( 7235)             n:=prec(2*succ(n)) end;
                 872 ( 7252)     'cp': typ2:='q';
                 873 ( 7265)     'fl': typ2:='f'
                 874 ( 7280)     else begin error(11); typ2:='i';end
                 875 ( 7303)   end {case}
                 876 ( 7305) end {gettype};
                 877 ( 7305) 
                 878 ( 7306) { * variable *        ( of block) }
                 879 ( 7306) 
                 880 ( 7306) proc variable;  { variable declarations }
                 881 ( 7306) 
                 882 ( 7306) var typ1,typ2: char;
                 883 ( 7309)     i,l: integer;
                 884 ( 7309)     aflag,uflag: boolean;
                 885 ( 7309) 
                 886 ( 7309) begin
                 887 ( 7309)   scan;
                 888 ( 7315)   repeat {main loop}
                 889 ( 7315)     l:=0;
                 890 ( 7317)     repeat decvar('v','i'); l:=succ(l);
                 891 ( 7335)     until token<> ' ,';
                 892 ( 7347)     testto(' :');
                 893 ( 7360)     gettype(typ2,aflag,uflag,n);
                 894 ( 7396)     if uflag then error(11);
                 895 ( 7411)     if aflag then typ1:='a' else typ1:='v';
                 896 ( 7429)     if typ1='a' then begin {array}
                 897 ( 7443)        dpnt:=dpnt-l; {variable has been assumed}
                 898 ( 7456)        for i:=succ(spnt-l) to spnt do begin
                 899 ( 7483)          t2[i]:=dpnt; t3[i]:=n;

----------------------------------------------------------------------

R65 Pascal program COMPILE1        11/11/23     page 16

                 900 ( 7499)          dpnt:=succ(dpnt+n);
                 901 ( 7516)       end
                 902 ( 7521)     end {array};
                 903 ( 7535)     for i:=succ(spnt-l) to spnt do
                 904 ( 7549)       t0[i]:=packed(typ1,typ2);
                 905 ( 7575)     parse(' ;');scan
                 906 ( 7602)   until token<>'id' {end main loop}
                 907 ( 7613) end {variable};
                 908 ( 7617) 
                 909 ( 7618) { * fixup *           ( of block ) }
                 910 ( 7618) 
                 911 ( 7618) proc fixup(x: integer);
                 912 ( 7618) begin
                 913 ( 7618)   if ofno<>nooutput then begin
                 914 ( 7630)     write(@ofno,'F');
                 915 ( 7641)     savebyte(succ(x-offset) and 255);
                 916 ( 7660)     savebyte(succ(x-offset) shr 8);
                 917 ( 7679)     savebyte((pc-x-1) and 255);
                 918 ( 7700)     savebyte((pc-x-1) shr 8);
                 919 ( 7721)   end;
                 920 ( 7721) end;
                 921 ( 7721) 
                 922 ( 7722) { * function *        ( of block ) }
                 923 ( 7722) 
                 924 ( 7722) proc function;
                 925 ( 7722) 
                 926 ( 7722) var n: integer;
                 927 ( 7725)     typ1,typ2: char;
                 928 ( 7725)     aflag,uflag: boolean;
                 929 ( 7725) begin
                 930 ( 7725)   if token<>' :' then begin
                 931 ( 7735)     aflag:=false; uflag:=false; typ2:='i' end
                 932 ( 7752)   else begin
                 933 ( 7759)     gettype(typ2,aflag,uflag,n);
                 934 ( 7795)     scan
                 935 ( 7795)   end;
                 936 ( 7799)   if aflag then begin
                 937 ( 7803)     typ1:='s'; t3[succ(cproc)]:=n;
                 938 ( 7817)     t2[succ(cproc)]:=t2[succ(cproc)]-n
                 939 ( 7839)   end
                 940 ( 7839)   else typ1:='r';
                 941 ( 7853)   t0[succ(cproc)]:=packed(typ1,typ2);
                 942 ( 7871)   if uflag then typ2:='u';
                 943 ( 7884)   if aflag then typ1:='g'
                 944 ( 7895)   else typ1:='f';
                 945 ( 7906)   t0[cproc]:=packed(typ1,typ2);
                 946 ( 7923) end {function};
                 947 ( 7927) 
                 948 ( 7928) { * parameter *       ( of block ) }
                 949 ( 7928) 
                 950 ( 7928) proc parameter;
                 951 ( 7928) 
                 952 ( 7928) var counter1,counter2,i,n,bs: integer;
                 953 ( 7931)     aflag,uflag: boolean;
                 954 ( 7931)     vtype1,vtype2: char;
                 955 ( 7931)     vtype: packed char;
                 956 ( 7931) 
                 957 ( 7931) begin
                 958 ( 7931)   push(0); { dummy size, fixed later }
                 959 ( 7941)   if find=0 then t3[spnt-npara]:=stackpnt

----------------------------------------------------------------------

R65 Pascal program COMPILE1        11/11/23     page 17

                 960 ( 7960)   else bs:=stackpnt;
                 961 ( 7971)   counter1:=0
                 962 ( 7979)   repeat {main loop}
                 963 ( 7985)     counter2:=0;
                 964 ( 7987)     vtype1:='d'; vtype2:='i';
                 965 ( 7999)     scan;
                 966 ( 8007)     if token='co' then scan
                 967 ( 8015)     else if token='va' then begin
                 968 ( 8033)       scan; vtype1:='w' end; {variable param}
                 969 ( 8046)     end;
                 970 ( 8046)     repeat {inner loop}
                 971 ( 8046)       decvar(vtype1,vtype2);
                 972 ( 8060)       t2[spnt]:=parlevel;
                 973 ( 8064)       parlevel:=succ(parlevel);
                 974 ( 8076)       npara:=succ(npara);
                 975 ( 8085)       counter2:=succ(counter2);
                 976 ( 8094)       until token<>' ,';
                 977 ( 8106)     uflag:=false;aflag:=false; n:=0;
                 978 ( 8124)     if token<>' :' then
                 979 ( 8135)       vtype2:='i' {assume integer }
                 980 ( 8141)     else begin
                 981 ( 8148)       gettype(vtype2,aflag,uflag,n);
                 982 ( 8184)       if n>63 then error(15);
                 983 ( 8202)       scan
                 984 ( 8202)     end;
                 985 ( 8206)     if aflag then begin
                 986 ( 8210)       vtype1:=succ(vtype1);
                 987 ( 8217)       parlevel:=parlevel-counter2;
                 988 ( 8226)     end;
                 989 ( 8235)     vtype:=packed(vtype1,vtype2);
                 990 ( 8244)     for i:=1 to counter2 do begin
                 991 ( 8267)       if uflag then push(packed(vtype1,'u'))
                 992 ( 8281)       else push(vtype);
                 993 ( 8300)       if aflag then begin
                 994 ( 8304)         push(n); t3[spnt-counter2+i]:=n;
                 995 ( 8331)         t2[spnt-counter2+i]:=parlevel;
                 996 ( 8353)         parlevel:=succ(parlevel)+n;
                 997 ( 8366)       end {then};
                 998 ( 8375)       t0[spnt-counter2+i]:=vtype;
                 999 ( 8389)     end {for};
                1000 ( 8397)     if aflag then counter2:=2*counter2;
                1001 ( 8420)     counter1:=counter1+counter2;
                1002 ( 8433)     until token<>' ;'; {outer loop}
                1003 ( 8453)   testto(' )'); scan;
                1004 ( 8466)   if find=0 then
                1005 ( 8472)     stack[t3[spnt-npara]]:=counter1
                1006 ( 8489)   else begin {information is allready there}
                1007 ( 8500)     stack[bs]:=counter1;
                1008 ( 8504)     n:=t3[fortab[find]]; {existing stack data}
                1009 ( 8528)     for i:=0 to stackpnt-bs do
                1010 ( 8538)       if stack[bs+1]<>stack[n+1]
                1011 ( 8569)         then merror(13,'pa'); {parameter wrong}
                1012 ( 8603)     stackpnt:=prec(bs) {clear the new info}
                1013 ( 8607)   end  {else}
                1014 ( 8612) end {parameter};
                1015 ( 8612) 
                1016 ( 8613) { * memory *              ( of block) }
                1017 ( 8613) 
                1018 ( 8613) proc memory;
                1019 ( 8613) 

----------------------------------------------------------------------

R65 Pascal program COMPILE1        11/11/23     page 18

                1020 ( 8613) var typ1,typ2:char;
                1021 ( 8616)     i,l,n: integer;
                1022 ( 8616)     aflag,uflag: boolean;
                1023 ( 8616) 
                1024 ( 8616) begin
                1025 ( 8616)   scan;
                1026 ( 8622)   repeat {main loop}
                1027 ( 8622)     l:=0;
                1028 ( 8624)     repeat
                1029 ( 8628)       decvar('m','i');
                1030 ( 8638)       l:=succ(l); testto(' ='); scan;
                1031 ( 8660)       n:=getcon; testtype('i');
                1032 ( 8678)       scan; t2[spnt]:=n;
                1033 ( 8686)     until token<>' ,';
                1034 ( 8701)     testto(' :');
                1035 ( 8714)     gettype(typ2,aflag,uflag,n);
                1036 ( 8750)     if uflag then error(11);
                1037 ( 8765)     scan;
                1038 ( 8769)     if token=' &' then begin {8-bit}
                1039 ( 8780)       typ1:='h'; scan
                1040 ( 8786)     end
                1041 ( 8790)     else typ1:='m';
                1042 ( 8795)     if aflag then typ1:=succ(typ1);
                1043 ( 8810)     for i:=succ(spnt-l) to spnt do begin
                1044 ( 8842)       t0[i]:=packed(typ1,typ2);
                1045 ( 8855)       t3[i]:=n;
                1046 ( 8863)     end;
                1047 ( 8871)     testto(' ;'); scan;
                1048 ( 8898)   until token<>'id';
                1049 ( 8905) end {memory};
                1050 ( 8909) 
                1051 ( 8910) 
                1052 ( 8910) {######################################}
                1053 ( 8910) { * statement *           ( of block ) }
                1054 ( 8910) {######################################}
                1055 ( 8910) 
                1056 ( 8910) proc statmnt;
                1057 ( 8910) 
                1058 ( 8910) var idpnt,relad,k2,savpc,bottom1: integer;
                1059 ( 8913)     device,wln: boolean;
                1060 ( 8913)     savtp1,vartyp2: char;
                1061 ( 8913)     wl: boolean;
                1062 ( 8913) 
                1063 ( 8913) { * code4 *               ( of statement ) }
                1064 ( 8913) 
                1065 ( 8913) proc code4(x,y1,z1: integer); {set 4-byte code}
                1066 ( 8913) 
                1067 ( 8913) var y,z: integer;
                1068 ( 8916) 
                1069 ( 8916) begin
                1070 ( 8916)   y:=y1; z:=z1;
                1071 ( 8926)   if y<0 then y:=y+256;
                1072 ( 8951)   if x=43 then z:=z-pc-2;
                1073 ( 8977)   code1(x);code1(y);code1(z and 255);
                1074 ( 9015)   code1(z shr 8)
                1075 ( 9021) end {code4};
                1076 ( 9028) 
                1077 ( 9029) { * testferror *         ( of statement) ) }
                1078 ( 9029) 
                1079 ( 9029) proc testferror;

----------------------------------------------------------------------

R65 Pascal program COMPILE1        11/11/23     page 19

                1080 ( 9029) begin
                1081 ( 9029)   code1($4f);
                1082 ( 9042) end;
                1083 ( 9042) 
                1084 ( 9043) { * gpval *              ( of statement ) }
                1085 ( 9043) 
                1086 ( 9043) proc gpval(idpnt: integer;
                1087 ( 9043)   dir: boolean; typ: char);
                1088 ( 9043) 
                1089 ( 9043) var d: integer;
                1090 ( 9046) 
                1091 ( 9046) begin {gpval}
                1092 ( 9046)   if dir then d:=1 else d:=0;
                1093 ( 9066)   case typ of
                1094 ( 9070)   'h':  begin code3($22,t2[idpnt]);
                1095 ( 9097)           if dir then code1($3f);
                1096 ( 9112)           code1($17+d) end;
                1097 ( 9125)   'm':  begin code3($22,t2[idpnt]);
                1098 ( 9151)           code1($3d+d) end;
                1099 ( 9164)   'i':  begin
                1100 ( 9174)           if dir then code1($3f);
                1101 ( 9189)           code3($22,t2[idpnt]);
                1102 ( 9205)           code1(3);
                1103 ( 9213)           if dir then code1($3f);
                1104 ( 9228)           code1($17+d) end;
                1105 ( 9241)   'n':  begin if dir then code1($3f);
                1106 ( 9266)           code3($22,1); code1($12);
                1107 ( 9284)           code3($22,t2[idpnt]);
                1108 ( 9300)           code1(3); code1($3d+d) end
                1109 ( 9321)   else begin
                1110 ( 9324)     if typ='q' then begin
                1111 ( 9331)       code4($55,level-t1[idpnt],2*t2[idpnt]);
                1112 ( 9366)     end else
                1113 ( 9366)       code4($27+2*d+relad,level-t1[idpnt],
                1114 ( 9392)         2*t2[idpnt]);
                1115 ( 9414)     end
                1116 ( 9414)   end {case}
                1117 ( 9416) end;
                1118 ( 9416) 
                1119 ( 9417) { FORWARD decl. of mainexp (of statement) }
                1120 ( 9417) 
                1121 ( 9417) proc mainexp(reqtype: char;
                1122 ( 9417)   var arsize: integer); forward;
                1123 ( 9420) 
                1124 ( 9420) { * express *           ( of statement ) }
                1125 ( 9420) 
                1126 ( 9420) proc express; {requests a normal 16-bit result }
                1127 ( 9420) 
                1128 ( 9420) var resultsize: integer;
                1129 ( 9423) 
                1130 ( 9423) begin {express}
                1131 ( 9423)   mainexp('n',resultsize);
                1132 ( 9441)   if resultsize<>0 then error(15)
                1133 ( 9453) end {express};
                1134 ( 9459) 
                1135 ( 9460) { * arrayexp *          ( of mainexp) }
                1136 ( 9460) 
                1137 ( 9460) proc arrayexp(size: integer; eltype: char);
                1138 ( 9460) 
                1139 ( 9460) var resultsize: integer;

----------------------------------------------------------------------

R65 Pascal program COMPILE1        11/11/23     page 20

                1140 ( 9463) 
                1141 ( 9463) begin
                1142 ( 9463)   mainexp(eltype,resultsize);
                1143 ( 9483)   if resultsize<>size then error(15);
                1144 ( 9503)   testtype(eltype);
                1145 ( 9513) end;
                1146 ( 9513) 
                1147 ( 9514) { * getvar *            ( of statement ) }
                1148 ( 9514) 
                1149 ( 9514) proc getvar;
                1150 ( 9514) begin
                1151 ( 9514)   vartyp2:=high(t0[idpnt]);
                1152 ( 9527)   vartype:=low(t0[idpnt]);
                1153 ( 9540)   scan;
                1154 ( 9549)   if (vartype='q') and (token=' [') and
                1155 ( 9564)     ((vartyp2='v') or (vartyp2='d')) then begin
                1156 ( 9581)     vartyp2:='q'; vartype:='c';
                1157 ( 9592)   end;
                1158 ( 9596)   case vartyp2 of
                1159 ( 9596)   'a','x','s','i','n','q':
                1160 ( 9639)       begin
                1161 ( 9642)         if token=' [' then begin
                1162 ( 9650)           scan; express; relad:=1;
                1163 ( 9663)           if vartyp2='r' then begin
                1164 ( 9674)             relad:=3;
                1165 ( 9679)             code3($22,1); code1($12)
                1166 ( 9695)           end;
                1167 ( 9701)           if (vartyp2='q') and (t3[idpnt]=0) then
                1168 ( 9719)             checkindex(0,63)
                1169 ( 9727)           else
                1170 ( 9733)             checkindex(0,t3[idpnt]);
                1171 ( 9752)           testtype('i'); testto(' ]'); scan;
                1172 ( 9773)         end else relad:=2;
                1173 ( 9778)       end;
                1174 ( 9782)   'v','w','r','h','m': relad:=0;
                1175 ( 9822)   'c','d','e','t','u': error(6)
                1176 ( 9866)   else error(1)
                1177 ( 9877)   end {case}
                1178 ( 9885) end {getvar};
                1179 ( 9885) 
                1180 ( 9886) { * prcall *            ( of statement ) }
                1181 ( 9886) 
                1182 ( 9886) proc prcall (idpn1: integer);
                1183 ( 9886) 
                1184 ( 9886) var bstack,numpar,i,n,n2: integer;
                1185 ( 9889) 
                1186 ( 9889) { body of prcall follows later }
                1187 ( 9889) 
                1188 ( 9889) { * prcall1 *           ( of prcall ) }
                1189 ( 9889) 
                1190 ( 9889) proc prcall1;
                1191 ( 9889) var ressize:integer;
                1192 ( 9892) 
                1193 ( 9892)   proc prcall3;
                1194 ( 9892)   begin {prcall3}
                1195 ( 9895)     testto('id');
                1196 ( 9906)     idpnt:=findid;
                1197 ( 9912)     if idpnt=0 then error(5);
                1198 ( 9934)     getvar;
                1199 ( 9938)     if chr(stack[i] and 255)<>vartype then

----------------------------------------------------------------------

R65 Pascal program COMPILE1        11/11/23     page 21

                1200 ( 9950)       if chr(stack[i] and 255)<>'u' then
                1201 ( 9972)         merror(14,'01');
                1202 ( 9987)       push(idpnt);
                1203 ( 9997)   end {prcall3};
                1204 ( 9997) 
                1205 ( 9998) begin {prcall1}
                1206 ( 9998)   case chr(stack[i] shr 8) of
                1207 (10011)     'd':  begin
                1208 (10019)             if chr(stack[i] and 255) = 'q' then
                1209 (10033)               mainexp('q',ressize)
                1210 (10039)             else
                1211 (10053)               express;
                1212 (10060)             if chr(stack[i] and 255)<>'u' then
                1213 (10074)               testtype(chr(stack[i] and 255));
                1214 (10096)           end;
                1215 (10096)     'e':  begin
                1216 (10106)             arrayexp(stack[succ(i)],
                1217 (10111)               chr(stack[i]));
                1218 (10130)             i:=succ(i);
                1219 (10134)           end;
                1220 (10139)     'w':  begin
                1221 (10149)             prcall3;
                1222 (10153)             if relad<>0 then merror(14,'02');
                1223 (10174)             gpval(idpnt,false,vartyp2);
                1224 (10190)           end;
                1225 (10190)     'x':  begin
                1226 (10200)             prcall3;
                1227 (10204)             if relad<>2 then merror(14,'03');
                1228 (10225)             if vartyp2='i' then error(16);
                1229 (10243)             i:=succ(i);
                1230 (10247)             if stack[i]<>t3[idpnt] then
                1231 (10264)               error(15);
                1232 (10280)             if vartyp2='n' then begin
                1233 (10287)               code3($22,t2[idpnt]);
                1234 (10306)               code1($3d);
                1235 (10314)             end else code4($27,level-t1[idpnt],
                1236 (10327)               2*t2[idpnt]);
                1237 (10349)             code2($3b,stack[i]);
                1238 (10365)           end
                1239 (10365)     else merror(14,'04')
                1240 (10373)   end {case}
                1241 (10381) end {prcall1};
                1242 (10381) 
                1243 (10382) proc prcall2;
                1244 (10382) begin
                1245 (10382)   if n>0 then code3(35,-2*n);
                1246 (10413)   n:=0
                1247 (10413) end {prcall2};
                1248 (10419) 
                1249 (10420) begin {body of prcall}
                1250 (10420)   if t3[idpn1]<>0 then begin
                1251 (10433)     bstack:=t3[idpn1];
                1252 (10440)     numpar:=stack[bstack];
                1253 (10452)     parse(' ('); scan;
                1254 (10473)     for i:=succ(bstack) to bstack+numpar do
                1255 (10486)     begin
                1256 (10500)       prcall1;
                1257 (10504)       if i<bstack+numpar then begin
                1258 (10518)         testto(' ,'); scan
                1259 (10530)       end

----------------------------------------------------------------------

R65 Pascal program COMPILE1        11/11/23     page 22

                1260 (10534)     end;
                1261 (10534)     testto(' )');
                1262 (10557)   end {then};
                1263 (10557)   code4(43,level-t1[idpn1],t2[idpn1]);
                1264 (10586)   if t3[idpn1]<>0 then begin
                1265 (10597)     n:=0; i:=bstack+numpar;
                1266 (10610)     repeat
                1267 (10619)       case chr(stack[i] shr 8) of
                1268 (10630)       'd':  n:=succ(n);
                1269 (10642)       'w':  begin
                1270 (10657)               prcall2; idpnt:=pop;
                1271 (10667)               gpval(idpnt,true,
                1272 (10677)                   high(t0[idpnt]));
                1273 (10692)             end;
                1274 (10692)       chr(0): begin
                1275 (10702)             n2:=stack[i];
                1276 (10706)             i:=i-1;
                1277 (10720)             case chr(stack[i] shr 8) of
                1278 (10736)               'e':  n:=succ(n+n2);
                1279 (10753)               'x':  begin
                1280 (10768)                       prcall2;
                1281 (10772)                       idpnt:=pop;
                1282 (10778)                       if high(t0[idpnt])='n'
                1283 (10791)                       then begin
                1284 (10794)                         code3($22,t2[idpnt]+
                1285 (10803)                           2*t3[idpnt]);
                1286 (10825)                         code1($3e)
                1287 (10827)                       end else
                1288 (10833)                         code4(41,
                1289 (10838)                           level-t1[idpnt],
                1290 (10846)                           2*(t2[idpnt]+
                1291 (10857)                           t3[idpnt]));
                1292 (10877)                       code2($3c,t3[idpnt])
                1293 (10883)                     end
                1294 (10893)               end {case}
                1295 (10895)             end
                1296 (10895)       end; {case}
                1297 (10897)       i:=prec(i);
                1298 (10901)     until i=bstack;
                1299 (10910)     prcall2
                1300 (10918)   end
                1301 (10922) end {prcall};
                1302 (10922) 
                1303 (10923) 
                1304 (10923) {###################################}
                1305 (10923) { * mainexp *       ( of statement) }
                1306 (10923) {###################################}
                1307 (10923) {  see forward declaration above    }
                1308 (10923) 
                1309 (10923) proc mainexp(reqtype: char;
                1310 (10923)   var arsize: integer);
                1311 (10923) 
                1312 (10923) { variables of mainexp}
                1313 (10923) var opcode,roff: integer;
                1314 (10926)     savtype: char;
                1315 (10926) 
                1316 (10926) { * argument *         ( of mainexp ) }
                1317 (10926) 
                1318 (10926) proc argument(rtype: char);
                1319 (10926) begin

----------------------------------------------------------------------

R65 Pascal program COMPILE1        11/11/23     page 23

                1320 (10926)   parse(' ('); scan; express;
                1321 (10948)   testtype(rtype);
                1322 (10958)   testto(' )'); scan
                1323 (10967) end; {argument}
                1324 (10972) 
                1325 (10972) {#######################################}
                1326 (10972) { * simexp *             ( of mainexp ) }
                1327 (10972) {#######################################}
                1328 (10972) 
                1329 (10972) proc simexp(var arsize1: integer);
                1330 (10972) 
                1331 (10972) var opcode: integer;
                1332 (10975)     sign: char;
                1333 (10975) 
                1334 (10975) {body of simexp  follows later }
                1335 (10975) 
                1336 (10975) {#######################################}
                1337 (10975) { * term *               ( of simexp )  }
                1338 (10975) {#######################################}
                1339 (10975) 
                1340 (10975) proc term(var arsize2: integer);
                1341 (10975) 
                1342 (10975) var opcode: integer;
                1343 (10978) 
                1344 (10978) { body of term follows later }
                1345 (10978) 
                1346 (10978) {#######################################}
                1347 (10978) { * factor *             ( of term )    }
                1348 (10978) {#######################################}
                1349 (10978) 
                1350 (10978) proc factor(var arsize3: integer);
                1351 (10978) 
                1352 (10978) var i, idpnt: integer;
                1353 (10981)     h: char;
                1354 (10981) 
                1355 (10981) { * index *              ( of factor )  }
                1356 (10981) 
                1357 (10981) proc index(chk: boolean);
                1358 (10981) 
                1359 (10981) var savtype: char;
                1360 (10984) 
                1361 (10984) begin {index}
                1362 (10984)   scan; savtype:=restype;
                1363 (10990)   express; testtype('i'); testto(' ]');
                1364 (11019)   if savtype='r' then begin
                1365 (11026)     code3($22,1); code1($12);
                1366 (11047)   end;
                1367 (11047)   if chk then begin
                1368 (11051)     if (savtype='q') and (t3[idpnt]=0) then
                1369 (11072)       { is an arrayed cpnt }
                1370 (11073)       checkindex(0,63)
                1371 (11080)     else
                1372 (11086)       checkindex(0,t3[idpnt]);
                1373 (11105)   end;
                1374 (11105)   restype:=savtype; scan
                1375 (11113) end;
                1376 (11117) 
                1377 (11118) 
                1378 (11118) begin { *** body of factor *** }
                1379 (11118)   arsize3:=0;

----------------------------------------------------------------------

R65 Pascal program COMPILE1        11/11/23     page 24

                1380 (11122)   case token of
                1381 (11126)     'id': begin {identifier }
                1382 (11138)             idpnt:=findid;
                1383 (11144)             if idpnt=0 then error(5);
                1384 (11166)             restype:=low(t0[idpnt]);
                1385 (11174)             h:=high(t0[idpnt]);
                1386 (11187)             case h of
                1387 (11192)               'v','w','d':
                1388 (11214)                     begin
                1389 (11217)                       scan;
                1390 (11221)                       if (restype='q') and (token=' [')
                1391 (11235)                       then begin
                1392 (11237)                         code4(39,level-t1[idpnt],
                1393 (11250)                           2*t2[idpnt]);
                1394 (11272)                         index(true);
                1395 (11280)                         code1($03);
                1396 (11288)                         code1($54);
                1397 (11296)                         restype:='c';
                1398 (11298)                       end else
                1399 (11302)                         code4(39,level-t1[idpnt],
                1400 (11315)                           2*t2[idpnt]);
                1401 (11337)                     end;
                1402 (11337)               'h':  begin code3($22,t2[idpnt]);
                1403 (11363)                       code1($17); scan end;
                1404 (11375)               'i':  begin code3($22,t2[idpnt]);
                1405 (11401)                       scan;
                1406 (11405)                       if token=' [' then begin
                1407 (11413)                         index(true); code1($03);
                1408 (11432)                         code1($17)
                1409 (11434)                       end else begin
                1410 (11443)                         error(16)
                1411 (11445)                       end
                1412 (11451)                     end;
                1413 (11451)               'm':  begin code3($22,t2[idpnt]);
                1414 (11477)                       code1($3d); scan
                1415 (11485)                     end;
                1416 (11489)               'n':  begin code3($22,t2[idpnt]);
                1417 (11515)                       scan;
                1418 (11519)                       if token=' [' then begin
                1419 (11527)                         index(true);
                1420 (11538)                         code3($22,1);code1($12);
                1421 (11556)                         code1($03); code1($3d);
                1422 (11572)                         if restype='r' then
                1423 (11578)                         begin
                1424 (11579)                           code2($3b,1);
                1425 (11592)                           arsize3:=1
                1426 (11592)                         end
                1427 (11594)                       end else begin
                1428 (11601)                         code1($3d);
                1429 (11609)                         code2($3b,t3[idpnt]);
                1430 (11625)                         arsize3:=t3[idpnt];
                1431 (11629)                       end
                1432 (11637)                     end;
                1433 (11637)               'r','t': begin
                1434 (11654)                       code3(35,2);
                1435 (11664)                       idpnt:=prec(idpnt);
                1436 (11668)                       prcall(idpnt); scan;
                1437 (11687)                       restype:=low(t0[idpnt]);
                1438 (11695)                     end;
                1439 (11700)               'c':  if low(t0[idpnt])<>'r' then begin

----------------------------------------------------------------------

R65 Pascal program COMPILE1        11/11/23     page 25

                1440 (11722)                       code3(34,t2[idpnt]);
                1441 (11741)                       scan;
                1442 (11745)                       if restype='s' then begin
                1443 (11752)                         if token=' [' then begin
                1444 (11763)                           index(true);
                1445 (11774)                           code1($03);
                1446 (11782)                           code1($58);
                1447 (11790)                           code1($54);
                1448 (11798)                           restype:='c';
                1449 (11800)                         end else begin
                1450 (11807)                           code1($58);
                1451 (11815)                           restype:='q';
                1452 (11817)                         end;
                1453 (11821)                       end;
                1454 (11821)                       {scan;}
                1455 (11821)                     end else begin
                1456 (11824)                       code2($3a,2);
                1457 (11834)                       code2(t2[idpnt] and 255,
                1458 (11844)                         t2[idpnt] shr 8);
                1459 (11862)                       code2(t3[idpnt] and 255,
                1460 (11872)                         t3[idpnt] shr 8);
                1461 (11890)                       arsize3:=1; scan
                1462 (11896)                     end;
                1463 (11900)               'a','e','x':
                1464 (11921)                     begin scan;
                1465 (11928)                       if token=' [' then begin
                1466 (11936)                         index(true);
                1467 (11947)                         code4($28,
                1468 (11949)                             level-t1[idpnt],
                1469 (11957)                             2*t2[idpnt]);
                1470 (11979)                         if restype='r' then
                1471 (11985)                         begin
                1472 (11986)                           code2($3b,1);
                1473 (11999)                           arsize3:=1
                1474 (11999)                         end
                1475 (12001)                       end else begin
                1476 (12008)                         code4($27,
                1477 (12010)                             level-t1[idpnt],
                1478 (12018)                             2*t2[idpnt]);
                1479 (12040)                         code2($3b,t3[idpnt]);
                1480 (12056)                         arsize3:=t3[idpnt];
                1481 (12060)                       end
                1482 (12068)                     end;
                1483 (12068)               's','u':
                1484 (12082)                     begin
                1485 (12085)                       code3(35,2*t3[idpnt]+2);
                1486 (12107)                       idpnt:=prec(idpnt);
                1487 (12111)                       prcall(idpnt); scan;
                1488 (12130)                       restype:=low(t0[idpnt]);
                1489 (12138)                       idpnt:=succ(idpnt);
                1490 (12147)                       arsize3:=t3[idpnt]
                1491 (12152)                     end
                1492 (12156)               else error(1)
                1493 (12169)             end {case}
                1494 (12177)           end; {identifier}
                1495 (12180)     'nu': begin code3(34,value[0]); scan;
                1496 (12206)             restype:='i'
                1497 (12206)           end;
                1498 (12212)     'ru': begin code2($3a,2);
                1499 (12233)             code2(value[0] and 255,

----------------------------------------------------------------------

R65 Pascal program COMPILE1        11/11/23     page 26

                1500 (12241)               value[0] shr 8);
                1501 (12257)             code2(value[1] and 255,
                1502 (12265)               value[1] shr 8);
                1503 (12281)             scan; restype:='r';
                1504 (12287)             arsize3:=1
                1505 (12291)           end;
                1506 (12297)     'st': begin
                1507 (12308)           if (reqtype='n') and (value[0]<3)
                1508 (12323)             then begin
                1509 (12325)               if value[0]<2 then begin
                1510 (12337)                 code3(34,ord(ident[1]));
                1511 (12354)                 restype:='c'
                1512 (12354)               end else begin
                1513 (12363)                 code3(34,packed(ident[1],
                1514 (12367)                   ident[2]));
                1515 (12384)                 restype:='p'
                1516 (12384)               end
                1517 (12386)             end else begin
                1518 (12393)               case reqtype of
                1519 (12393)                 'c','u','n','q':
                1520 (12422)                     begin
                1521 (12425)                       if (vartype='q') or
                1522 (12432)                          (reqtype='q') then begin
                1523 (12440)                         arsize3:=0;
                1524 (12445)                         restype:='q';
                1525 (12451)                         code2($56,value[0]);
                1526 (12469)                       end else begin
                1527 (12472)                         arsize3:=prec(value[0]);
                1528 (12478)                         restype:='c';
                1529 (12485)                         code2($39,value[0]);
                1530 (12503)                       end;
                1531 (12503)                       for i:=1 to value[0] do
                1532 (12511)                         code1(ord(ident[i]));
                1533 (12538)                       if (vartype='q') or
                1534 (12559)                          (reqtype='q') then code1(0);
                1535 (12578)                     end;
                1536 (12578)                 'p': begin
                1537 (12588)                       if odd(value[0]) then
                1538 (12594)                         error(15);
                1539 (12606)                       value[0]:=value[0] shr 1;
                1540 (12616)                       arsize3:=prec(value[0]);
                1541 (12627)                       restype:='p';
                1542 (12634)                       code2($3a,value[0]);
                1543 (12652)                       for i:=1 to value[0] do
                1544 (12660)                         begin
                1545 (12673)                         code1(ident[2*i]);
                1546 (12690)                         code1(ident[2*i-1]);
                1547 (12710)                       end
                1548 (12710)                     end
                1549 (12710)                 else merror(14,'05')
                1550 (12732)               end {case}
                1551 (12740)             end;
                1552 (12740)             scan
                1553 (12740)           end;
                1554 (12744)     'od': begin
                1555 (12755)             argument('i'); code1(7);
                1556 (12771)             restype:='b'
                1557 (12771)           end;
                1558 (12777)     'me': begin
                1559 (12788)             parse(' ['); index(false);

----------------------------------------------------------------------

R65 Pascal program COMPILE1        11/11/23     page 27

                1560 (12805)             code1(23); restype:='i';
                1561 (12815)           end;
                1562 (12819)     ' (': begin
                1563 (12830)             scan; mainexp(reqtype,arsize3);
                1564 (12852)             testto(' )'); scan
                1565 (12861)           end; {no type change}
                1566 (12868)     'no': begin
                1567 (12876)             scan; factor(arsize3);
                1568 (12892)             if (arsize3<>0) then error(15);
                1569 (12910)             code1($11);
                1570 (12918)             if restype<>'i' then
                1571 (12924)               testtype('b')
                1572 (12930)           end;
                1573 (12936)     'cr': begin
                1574 (12947)             argument('i'); code1(52);
                1575 (12963)             restype:='c'
                1576 (12963)           end;
                1577 (12969)     'hi': begin
                1578 (12980)             argument('p'); code1(51);
                1579 (12996)             restype:='c'
                1580 (12996)           end;
                1581 (13002)     'lo': begin
                1582 (13013)             argument('p'); code1(52);
                1583 (13029)             restype:='c'
                1584 (13029)           end;
                1585 (13035)     'su': begin
                1586 (13046)             argument('u'); code1($14);
                1587 (13062)           end;
                1588 (13062)     'pc': begin
                1589 (13073)             argument('u'); code1($15)
                1590 (13083)           end;
                1591 (13089)     'cp': begin
                1592 (13100)             argument('i'); restype:='q';
                1593 (13110)           end;
                1594 (13114)     'ni': begin
                1595 (13125)             code3(34,0); scan; restype:='q';
                1596 (13141)           end;
                1597 (13145)     'ox': begin
                1598 (13156)             argument('u');
                1599 (13164)             restype:='i'
                1600 (13164)           end;
                1601 (13170)     ' @': begin
                1602 (13181)             scan; factor(arsize3);
                1603 (13197)             if arsize3<>0 then error(15);
                1604 (13215)             testtype('i');
                1605 (13223)             restype:='f'
                1606 (13223)           end;
                1607 (13229)     'tr': begin
                1608 (13240)             code3(34,1); scan;
                1609 (13254)             restype:='b';
                1610 (13256)           end;
                1611 (13260)     'fa': begin
                1612 (13271)             code3(34,0); scan;
                1613 (13285)             restype:='b'
                1614 (13285)           end;
                1615 (13291)     'tc': begin
                1616 (13302)             parse(' ('); scan;
                1617 (13315)             arrayexp(1,'r');
                1618 (13325)             testto(' )'); scan;
                1619 (13338)             code1($47); restype:='i';

----------------------------------------------------------------------

R65 Pascal program COMPILE1        11/11/23     page 28

                1620 (13348)           end;
                1621 (13352)     'cv': begin
                1622 (13363)             argument('i');
                1623 (13371)             code1($46); arsize3:=1;
                1624 (13381)             restype:='r'
                1625 (13385)           end;
                1626 (13391)     'pa': begin
                1627 (13402)             parse(' ('); scan; express;
                1628 (13419)             testtype('c');
                1629 (13427)             if token=' ,' then begin
                1630 (13435)               scan; express; testtype('c');
                1631 (13454)               code1(53)
                1632 (13456)             end;
                1633 (13462)             testto(' )'); scan; restype:='p'
                1634 (13475)           end
                1635 (13477)     else error(1)
                1636 (13486)   end {case of token}
                1637 (13494) end {factor};
                1638 (13494) 
                1639 (13495) begin  { *** body of term *** }
                1640 (13495)   factor(arsize2);
                1641 (13509)   repeat
                1642 (13509)     case token of
                1643 (13509)       ' *': opcode:=5;
                1644 (13523)       'di': opcode:=6;
                1645 (13540)       'an': opcode:=15;
                1646 (13557)       'sh': opcode:=18;
                1647 (13574)       'sr': opcode:=19;
                1648 (13591)       ' /': opcode:=$45
                1649 (13606)       else opcode:=0
                1650 (13615)     end {case};
                1651 (13623)     if opcode>0 then begin
                1652 (13630)       if (restype='r') and
                1653 (13640)             (arsize2=1) then begin
                1654 (13648)         scan; factor(arsize2);
                1655 (13667)         if (restype<>'r') or (arsize2<>1) then
                1656 (13681)           merror(14,'06');
                1657 (13696)         case opcode of
                1658 (13696)           5: code1($44);
                1659 (13715)           $45: code1($45)
                1660 (13727)           else error(17)
                1661 (13738)         end{case}
                1662 (13746)       end else begin
                1663 (13749)         if opcode=$45 then error(9);
                1664 (13767)         if arsize2<>0 then error(15);
                1665 (13785)         if (restype='b') and (opcode=15)
                1666 (13798)           then begin
                1667 (13800)           scan; factor(arsize2);
                1668 (13819)           if arsize2<>0 then error(15);
                1669 (13837)           testtype('b');
                1670 (13845)           code1(opcode)
                1671 (13845)         end else begin
                1672 (13858)           testtype('i'); scan;
                1673 (13870)           factor(arsize2);
                1674 (13882)           if arsize2<>0 then error(15);
                1675 (13900)           testtype('i'); code1(opcode);
                1676 (13918)         end
                1677 (13918)       end
                1678 (13918)     end;
                1679 (13918)   until opcode=0;

----------------------------------------------------------------------

R65 Pascal program COMPILE1        11/11/23     page 29

                1680 (13924) end {term};
                1681 (13928) 
                1682 (13929) 
                1683 (13929) begin { *** body of simexp *** }
                1684 (13929)   sign:=' ';
                1685 (13933)   if token=' +' then begin
                1686 (13945)     sign:='+'; scan
                1687 (13954)   end else if token=' -' then begin
                1688 (13969)     sign:='-'; scan
                1689 (13978)   end;
                1690 (13982)   term(arsize1);
                1691 (13994)   if sign<>' ' then begin
                1692 (14001)     if (restype='r')and (arsize1=1) then begin
                1693 (14019)       if sign='-' then code1($4e)
                1694 (14034)     end else begin
                1695 (14043)       testtype('i');
                1696 (14051)       if arsize1<>0 then error(15);
                1697 (14069)       if sign='-' then code1(2);
                1698 (14087)     end
                1699 (14087)   end;
                1700 (14087)   repeat
                1701 (14087)     case token of
                1702 (14087)       ' &': opcode:=1;
                1703 (14101)       ' +': opcode:=3;
                1704 (14118)       ' -': opcode:=4;
                1705 (14135)       'or': opcode:=14;
                1706 (14152)       'xo': opcode:=16
                1707 (14167)       else opcode:=0
                1708 (14176)     end {case};
                1709 (14184)     if opcode>1 then begin {if 1}
                1710 (14194)       if (restype='r') and (arsize1=1)
                1711 (14207)         then begin {real}
                1712 (14212)         scan; term(arsize1);
                1713 (14228)         if (restype<>'r') or (arsize1<>1) then
                1714 (14242)           error(17);
                1715 (14254)         case opcode of
                1716 (14254)           3:  code1($42);
                1717 (14273)           4:  code1($43)
                1718 (14285)           else error(17)
                1719 (14296)         end {case}
                1720 (14304)       end {real}
                1721 (14304)       else begin {not real}
                1722 (14307)         if (arsize1<>0) then error(15);
                1723 (14325)         if (restype='b') and (opcode>=14)
                1724 (14338)           then begin {boolean}
                1725 (14343)           scan; term(arsize1);
                1726 (14359)           if arsize1<>0 then error(15);
                1727 (14377)           testtype('b'); code1(opcode)
                1728 (14385)         end {boolean}
                1729 (14395)         else begin {not boolean}
                1730 (14398)           testtype('i'); scan;
                1731 (14410)           term(arsize1);
                1732 (14422)           if arsize1<>0 then error(15);
                1733 (14440)           testtype('i'); code1(opcode);
                1734 (14458)         end {not boolean}
                1735 (14458)       end {not real}
                1736 (14458)     end {if 1}
                1737 (14458)     else if opcode=1 then begin {else 1}
                1738 (14471)       sign:=restype;
                1739 (14471)       scan; term(opcode);

----------------------------------------------------------------------

R65 Pascal program COMPILE1        11/11/23     page 30

                1740 (14495)       arsize1:=arsize1+opcode+1;
                1741 (14506)       testtype(sign)
                1742 (14511)     end {else 1}
                1743 (14521)   until opcode=0
                1744 (14525) end {simexp};
                1745 (14531) 
                1746 (14532) 
                1747 (14532) begin { *** body of mainexp *** }
                1748 (14532)   roff:=0;
                1749 (14536)   simexp(arsize);
                1750 (14552)   if (restype='r') and (arsize=1) then
                1751 (14566)     roff:=$40;
                1752 (14572)   case token of
                1753 (14576)     ' =': opcode:=8;
                1754 (14590)     ' <': opcode:=10;
                1755 (14607)     ' >': opcode:=12;
                1756 (14624)     '<>': opcode:=9;
                1757 (14641)     '<=': opcode:=13;
                1758 (14658)     '>=': opcode:=11
                1759 (14673)     else opcode:=0
                1760 (14682)   end {case};
                1761 (14690)   if opcode>0 then begin
                1762 (14697)     if (arsize<>0) and (roff=0) then
                1763 (14714)       error(15);
                1764 (14726)     scan; savtype:=restype; simexp(arsize);
                1765 (14750)     if ((roff=0) and (arsize<>0))
                1766 (14764)       or((roff<>0) and (arsize>1)) then
                1767 (14780)       error(15);
                1768 (14792)     testtype(savtype); code1(opcode+roff);
                1769 (14817)     arsize:=0; restype:='b'
                1770 (14823)   end
                1771 (14825) end {mainexp};
                1772 (14829) 
                1773 (14830) 
                1774 (14830) {#########################################}
                1775 (14830) { * assign *             ( of statement ) }
                1776 (14830) {#########################################}
                1777 (14830) 
                1778 (14830) proc assign;
                1779 (14830) 
                1780 (14830) var savetype: char;
                1781 (14833) 
                1782 (14833)   proc assign1;
                1783 (14833)   begin
                1784 (14833)     testto(':='); scan; express;
                1785 (14855)     if (vartype='q') and (restype='s') then begin
                1786 (14870)       code1($58); restype:='q';
                1787 (14883)     end;
                1788 (14887)     gpval(idpnt,true,vartyp2);
                1789 (14903)   end {assign1};
                1790 (14903) 
                1791 (14904) begin {assign}
                1792 (14904)   idpnt:=findid;
                1793 (14912)   if idpnt=0 then error(5);
                1794 (14934)   if t0[idpnt]='pr' then begin
                1795 (14946)     prcall(idpnt);scan end
                1796 (14963)   else begin
                1797 (14966)     getvar; savetype:=vartype;
                1798 (14970)     if relad<2 then begin
                1799 (14985)       assign1; testtype(vartype)

----------------------------------------------------------------------

R65 Pascal program COMPILE1        11/11/23     page 31

                1800 (14992)     end else begin
                1801 (15005)       if vartyp2='i' then error(16); {8-bit mem}
                1802 (15023)       testto(':='); scan;
                1803 (15036)       if relad=3 then begin
                1804 (15043)         arrayexp(1,vartype); relad:=1;
                1805 (15060)         code1($53);
                1806 (15072)         if vartyp2='n' then begin
                1807 (15079)           code1($3f);
                1808 (15090)           code3($22,1);code1($12);
                1809 (15108)           code3($22,t2[idpnt]+2);
                1810 (15127)           code1($3);code1($3e)
                1811 (15137)         end else
                1812 (15143)           code4($2a,level-t1[idpnt],
                1813 (15156)             2*t2[idpnt]+2);
                1814 (15181)         code2($3c,1)
                1815 (15185)       end else begin
                1816 (15194)         arrayexp(t3[idpnt],vartype);
                1817 (15212)         if vartyp2='n' then begin
                1818 (15219)           code3($22,t2[idpnt]+2*t3[idpnt]);
                1819 (15250)           code1($3e);
                1820 (15258)         end else
                1821 (15258)           code4($29,level-t1[idpnt],
                1822 (15271)             2*(t2[idpnt]+t3[idpnt]));
                1823 (15302)         code2($3c,t3[idpnt]);
                1824 (15318)       end
                1825 (15318)     end
                1826 (15318)   end
                1827 (15318) end {assign};
                1828 (15318) 
                1829 (15319) { * case1 *             ( of statement ) }
                1830 (15319) 
                1831 (15319) proc case1;
                1832 (15319) 
                1833 (15319) var i1,i2,casave: integer;
                1834 (15322)     savetype: char;
                1835 (15322) 
                1836 (15322)   proc case2;
                1837 (15322) 
                1838 (15322)     proc case3;
                1839 (15325)     begin
                1840 (15325)       scan; code1(22); code3(34,getcon);
                1841 (15356)       testtype(savetype);
                1842 (15366)       code1(8); scan
                1843 (15374)     end;
                1844 (15378) 
                1845 (15379)   begin {case2}
                1846 (15379)     i1:=0; case3;
                1847 (15391)     while token=' ,' do begin
                1848 (15402)       push(pc); code3(38,0); i1:=succ(i1);
                1849 (15426)       case3
                1850 (15431)     end;
                1851 (15435)     testto(' :'); savpc:=pc; code3(37,0);
                1852 (15465)     for k2:=1 to i1 do fixup(pop);
                1853 (15496)     push(savpc);
                1854 (15520)     scan; statmnt
                1855 (15524)   end {case2};
                1856 (15528) 
                1857 (15529) begin {case1}
                1858 (15529)   scan; express; testto('of');
                1859 (15548)   savetype:=restype; i2:=1; case2;

----------------------------------------------------------------------

R65 Pascal program COMPILE1        11/11/23     page 32

                1860 (15566)   while token=' ;' do begin
                1861 (15577)     casave:=pc; code3(36,0); fixup(pop);
                1862 (15607)     push(casave); i2:=succ(i2); case2
                1863 (15626)   end;
                1864 (15630)   if token='el' then begin
                1865 (15641)     casave:=pc; code3(36,0); fixup(pop);
                1866 (15674)     push(casave); scan; statmnt
                1867 (15688)   end;
                1868 (15692)   testto('en'); for k2:=1 to i2 do fixup(pop);
                1869 (15732)   code3(35,-2); scan
                1870 (15757) end {case1};
                1871 (15761) 
                1872 (15762) { * openrw *              ( of statement ) }
                1873 (15762) 
                1874 (15762) proc openrw(x: integer);
                1875 (15762) begin
                1876 (15762)   parse(' ('); parse('id');
                1877 (15785)   idpnt:=findid;
                1878 (15791)   if idpnt=0 then error(5);
                1879 (15813)   getvar; code1(x);
                1880 (15827)   testferror;
                1881 (15831)   if relad=2 then error(15);
                1882 (15849)   if vartype<>'f' then merror(14,'07');
                1883 (15870)   gpval(idpnt,true,vartyp2);
                1884 (15886)   testto(' )'); scan
                1885 (15895) end {openrw};
                1886 (15899) 
                1887 (15900) { * gpsec *               ( of statement )  }
                1888 (15900) 
                1889 (15900) proc gpsec(code);   { get/put sector }
                1890 (15900) 
                1891 (15900)   proc gpsec1;
                1892 (15903)   begin
                1893 (15903)     scan; express; testtype('i');
                1894 (15924)     testto(' ,');
                1895 (15933)   end;
                1896 (15933) 
                1897 (15934) begin {gpsec}
                1898 (15934)   parse(' ('); gpsec1; gpsec1; gpsec1;
                1899 (15957)   code1(code);
                1900 (15967)   parse('id'); idpnt:=findid;
                1901 (15982)   if idpnt=0 then error(5);
                1902 (16004)   getvar; code3(34,$db); { get file error code }
                1903 (16018)   if relad=2 then error(15);
                1904 (16036)   code1(23); if vartype<>'i' then merror(14,'08');
                1905 (16065)   gpval(idpnt,true,vartyp2);
                1906 (16081)   testto(' )');
                1907 (16090) end {gpsec};
                1908 (16090) 
                1909 (16091) 
                1910 (16091) begin {body of statement }
                1911 (16091)   if token=' ;' then scan;
                1912 (16108)   case token of
                1913 (16108)     'id': assign;
                1914 (16124) 
                1915 (16127)     'if': begin {if}
                1916 (16135)             scan; express; testtype('b');
                1917 (16151)             testto('th'); scan;  savpc:=pc;
                1918 (16164)             code3(37,0); statmnt;
                1919 (16186)             if token='el' then begin {else}

----------------------------------------------------------------------

R65 Pascal program COMPILE1        11/11/23     page 33

                1920 (16197)               k2:=pc; code3(36,0);
                1921 (16215)               fixup(savpc); scan; statmnt;
                1922 (16233)               fixup(k2)
                1923 (16233)             end else fixup(savpc)
                1924 (16246)           end; {if}
                1925 (16259) 
                1926 (16259)     'be':  begin {begin}
                1927 (16267)             repeat
                1928 (16267)               scan; statmnt
                1929 (16271)             until token<>(' ;');
                1930 (16282)             testto('en'); scan
                1931 (16295)           end; {begin}
                1932 (16302) 
                1933 (16302)     'rp': begin {repeat}
                1934 (16310)             savpc:=pc;
                1935 (16310)             repeat
                1936 (16318)               scan; statmnt
                1937 (16322)             until token='un';
                1938 (16333)             scan; express; testtype('b');
                1939 (16353)             code3(37,savpc)
                1940 (16355)           end {repeat};
                1941 (16365) 
                1942 (16368)     're': begin {read}
                1943 (16376)             parse(' ('); scan;
                1944 (16389)             if token=' @' then begin
                1945 (16397)               scan; express; testtype('f');
                1946 (16416)               device:=true;
                1947 (16418)               code1(44); testto(' ,')
                1948 (16433)             end
                1949 (16439)             else begin
                1950 (16442)               device:=false; code1(26)
                1951 (16450)             end;
                1952 (16456)             repeat
                1953 (16456)               begin {main loop of read}
                1954 (16456)                 if token=' ,' then scan;
                1955 (16471)                 testto('id'); idpnt:=findid;
                1956 (16486)                 if idpnt=0 then error(5);
                1957 (16508)                 getvar;
                1958 (16512)                 if relad=2 then error(15);
                1959 (16530)                 case vartype of
                1960 (16530)                   'i':  code1(28);
                1961 (16549)                   'c':  code1(27);
                1962 (16567)                   'p':  begin
                1963 (16577)                         code1(27); code1(27);
                1964 (16593)                         code1(53)
                1965 (16595)                         end
                1966 (16601)                   else error(114)
                1967 (16606)                 end {case};
                1968 (16614)                 gpval(idpnt,true,vartyp2)
                1969 (16620)               end {mainloop of read}
                1970 (16630)             until token<>' ,';
                1971 (16637)             testto(' )'); scan;
                1972 (16654)             if device then code1(45);
                1973 (16669)           end {read};
                1974 (16669) 
                1975 (16672)     'wr','wl':
                1976 (16685)           begin {write,writeln}
                1977 (16688)             if token='wl' then wln:=true
                1978 (16699)             else wln:=false;
                1979 (16710)             scan;

----------------------------------------------------------------------

R65 Pascal program COMPILE1        11/11/23     page 34

                1980 (16718)             if token=' (' then begin
                1981 (16726)               scan;
                1982 (16733)               if token=' @' then begin
                1983 (16741)                 scan; express; testtype('f');
                1984 (16760)                 device:=true; code1(44);
                1985 (16774)                 testto(' ,');
                1986 (16783)               end else device:=false;
                1987 (16788)               repeat
                1988 (16792)                 if token=' ,' then scan;
                1989 (16807)                 if (token=' )') and device
                1990 (16815)                        and wln then
                1991 (16820)                    {empty writeln except device}
                1992 (16825)                    k2:=k2 {do nothing}
                1993 (16828)                 else if token='st' then begin
                1994 (16847)                   {string}
                1995 (16850)                   code1(50);
                1996 (16858)                   for k2:=1 to value[0]-1 do
                1997 (16872)                     code1(ord(ident[k2])
                1998 (16886)                         and 127);
                1999 (16899)                   code1(ord(ident[value[0]])
                2000 (16919)                       or 128);
                2001 (16932)                   scan
                2002 (16932)                 end else begin
                2003 (16939)                   {expression}
                2004 (16939)                   express;
                2005 (16943)                   case restype of
                2006 (16943)                     'i':  code1(30);
                2007 (16962)                     'c':  code1(29);
                2008 (16980)                     'q':  code1($57);
                2009 (16998)                     's':  begin
                2010 (17008)                             code1($58);
                2011 (17016)                             code1($57);
                2012 (17024)                           end;
                2013 (17024)                     'p':  begin
                2014 (17034)                             code1(22);
                2015 (17042)                             code1(51);
                2016 (17050)                             code1(29);
                2017 (17058)                             code1(52);
                2018 (17066)                             code1(29);
                2019 (17074)                           end
                2020 (17074)                     else merror(14,'09')
                2021 (17082)                   end {case}
                2022 (17090)                 end {expression}
                2023 (17090)               until token<>' ,';
                2024 (17097)               if wln then begin {writeln(..)}
                2025 (17108)                 code2(32,13); code1(29);
                2026 (17126)                 code2(32,10); code1(29);
                2027 (17144)               end;
                2028 (17144)               if device then code1(45);
                2029 (17159)               testto(' )'); scan
                2030 (17168)             end {if}
                2031 (17172)             else if wln then begin {writeln}
                2032 (17182)               code2(32,13); code1(29);
                2033 (17200)               code2(32,10); code1(29);
                2034 (17218)             end
                2035 (17218)           end {write, writeln};
                2036 (17218) 
                2037 (17221)     'cs': case1; {case statement}
                2038 (17236) 
                2039 (17236)     'wh': begin {while}

----------------------------------------------------------------------

R65 Pascal program COMPILE1        11/11/23     page 35

                2040 (17244)             scan; savpc:=pc; express;
                2041 (17260)             testtype('b');
                2042 (17268)             k2:=pc; code3(37,0);
                2043 (17286)             testto('do'); scan; statmnt;
                2044 (17303)             code3(36,savpc); fixup(k2)
                2045 (17315)           end {while};
                2046 (17325) 
                2047 (17328)     'fo': begin {for}
                2048 (17336)             parse('id'); assign;
                2049 (17349)             if t0[idpnt]='pr' then error(1);
                2050 (17372)             savtp1:=low(t0[idpnt]);
                2051 (17380)             case token of
                2052 (17385)               'to': k2:=1;
                2053 (17399)               'dw': k2:=0
                2054 (17414)               else merror(2,'to')
                2055 (17428)             end {case of token};
                2056 (17436)             scan; express; testtype(savtp1);
                2057 (17454)             bottom1:=pc; code1(22);
                2058 (17470)             gpval(idpnt,false,vartyp2);
                2059 (17486)             code1(13-k2-k2);
                2060 (17504)             savpc:=pc; code3(37,0);
                2061 (17522)             testto('do'); scan; statmnt;
                2062 (17539)             gpval(idpnt,false,vartyp2);
                2063 (17555)             code1(21-k2);
                2064 (17568)             gpval(idpnt,true,vartyp2);
                2065 (17584)             code3(36,bottom1); fixup(savpc);
                2066 (17606)             code3(35,-2);
                2067 (17617)           end {for};
                2068 (17617) 
                2069 (17620)     'me': begin {mem}
                2070 (17628)             parse(' ['); scan; express;
                2071 (17645)             testtype('i');
                2072 (17653)             testto(' ]'); parse(':=');
                2073 (17671)             scan; express; code1(24);
                2074 (17687)             testtype('i');
                2075 (17695)           end {mem};
                2076 (17695) 
                2077 (17698)     'ca': begin {call}
                2078 (17706)             parse(' ('); scan; express;
                2079 (17723)             testtype('i');
                2080 (17731)             testto(' )'); code1(25); scan
                2081 (17748)           end {call};
                2082 (17752) 
                2083 (17755)     'op': openrw(47);
                2084 (17771) 
                2085 (17774)     'ow': openrw(48);
                2086 (17790) 
                2087 (17793)     'ob': openrw(80);
                2088 (17809) 
                2089 (17812)     'gb': begin
                2090 (17820)             parse(' ('); scan; express;
                2091 (17837)             testtype('f'); testto(' ,');
                2092 (17854)             scan; express; testtype('i');
                2093 (17870)             testto(' ,'); scan; testto('id');
                2094 (17892)             idpnt:=findid;
                2095 (17898)             if idpnt=0 then error(5);
                2096 (17920)             getvar;
                2097 (17924)             if relad<>0 then error(15);
                2098 (17942)             code1($51); testferror;
                2099 (17954)             gpval(idpnt,true,vartyp2);

----------------------------------------------------------------------

R65 Pascal program COMPILE1        11/11/23     page 36

                2100 (17970)             testto(' )'); scan
                2101 (17979)           end;
                2102 (17983) 
                2103 (17986)     'pb': begin
                2104 (17994)             parse(' ('); scan; express;
                2105 (18011)             testtype('f'); testto(' ,');
                2106 (18028)             scan; express; testtype('i');
                2107 (18044)             testto(' ,'); scan; express;
                2108 (18061)             code1($52);testferror;
                2109 (18073)             testto(' )');
                2110 (18082)             scan
                2111 (18082)           end;
                2112 (18086) 
                2113 (18089)     'ru': begin
                2114 (18097)             code1($41); scan;
                2115 (18109)           end;
                2116 (18109) 
                2117 (18112)     'fi': begin
                2118 (18120)             code1(46); scan
                2119 (18128)           end;
                2120 (18132) 
                2121 (18135)     'ge': gpsec(55);
                2122 (18151) 
                2123 (18154)     'pu': gpsec(56);
                2124 (18170) 
                2125 (18173)     'cl': begin {close}
                2126 (18181)             parse(' (');
                2127 (18190)             repeat
                2128 (18190)               scan; express; code1(49);
                2129 (18206)               testtype('f');
                2130 (18214)               testferror
                2131 (18214)             until token<>' ,';
                2132 (18225)             testto(' )'); scan;
                2133 (18242)           end {close}
                2134 (18242) 
                2135 (18242)     else if (token<>'en') and (token<>' ;')
                2136 (18260)       and (token<>'un') then begin
                2137 (18271)       error(10); scan
                2138 (18282)     end
                2139 (18286)   end {case of statements}
                2140 (18288) end;
                2141 (18288) 
                2142 (18289) { * findforw *          ( of block ) }
                2143 (18289) 
                2144 (18289) func findforw;
                2145 (18289) 
                2146 (18289) var i,j,sav1: integer;
                2147 (18292) 
                2148 (18292)   func found(start: integer):boolean;
                2149 (18292)   var ii,i9: integer;
                2150 (18295)   begin {compare}
                2151 (18295)     ii:= 0;
                2152 (18299)     repeat
                2153 (18303)       ii:=succ(ii);
                2154 (18307)     until (ii >= 8) or
                2155 (18319)       (ident[ii] <> idtab[start+ii]);
                2156 (18342)     found:=(ii >= 8);
                2157 (18353)   end {compare};
                2158 (18357) 
                2159 (18358) 

----------------------------------------------------------------------

R65 Pascal program COMPILE1        11/11/23     page 37

                2160 (18358) begin {findforw}
                2161 (18358)   i:=succ(forwpn);
                2162 (18364)   repeat
                2163 (18369)     i:=prec(i)
                2164 (18369)   until (i=0) or found(8*fortab[i]);
                2165 (18404)   findforw:=i;
                2166 (18408)   if i>0 then
                2167 (18422)     if i=forwpn then forwpn:=forwpn-1
                2168 (18442)     else begin
                2169 (18452)       sav1:=fortab[i];
                2170 (18456)       for j:=1 to forwpn-1 do
                2171 (18476)       fortab[j]:=fortab[succ(j)];
                2172 (18495)       fortab[forwpn]:=sav1;
                2173 (18521)       findforw:=forwpn;
                2174 (18529)       forwpn:=forwpn-1
                2175 (18541)     end
                2176 (18543) end {findforw};
                2177 (18548) 
                2178 (18549) 
                2179 (18549) begin { *** body of block *** }
                2180 (18549)   dpnt:=3; t2[bottom]:=pc;
                2181 (18561)   code3(36,0);
                2182 (18579)   stackpn1:=stackpnt; forwpn:=0;
                2183 (18589) 
                2184 (18593)   if token='co' then begin    { * const * }
                2185 (18604)     scan;
                2186 (18608)     repeat
                2187 (18608)       deccon; testto(' ;'); scan
                2188 (18621)     until token <> 'id';
                2189 (18632)   end {const};
                2190 (18636) 
                2191 (18636)   if token='me' then memory;  { * mem * }
                2192 (18651) 
                2193 (18651)   if token='va' then variable;{ * var * }
                2194 (18666) 
                2195 (18666)   while (token='pr')or (token='fu') do begin
                2196 (18686)     parlevel:=0;
                2197 (18688)     case token of
                2198 (18692)     'pr': begin               { * proc * }
                2199 (18704)             parse('id'); npara:=0;
                2200 (18715)             putsym('p','r'); cproc:=spnt;
                2201 (18729)             level:=succ(level);
                2202 (18741)           end;
                2203 (18746)     'fu': begin               { * func * }
                2204 (18757)             parse('id'); npara:=1;
                2205 (18768)             putsym('f','i');
                2206 (18782)             cproc:=spnt; level:=succ(level);
                2207 (18794)             putsym('f','i');
                2208 (18809)             t2[spnt]:=parlevel;
                2209 (18813)             parlevel:=succ(parlevel);
                2210 (18825)           end
                2211 (18830)     end; {case of token}
                2212 (18832)     if forwpn=0 then find:=0
                2213 (18842)     else find:=findforw;
                2214 (18857)     if find<>0 then begin
                2215 (18868)       spnt:=spnt-npara-1;
                2216 (18882)       cproc:=fortab[find];
                2217 (18891)       fixup(t2[cproc]);
                2218 (18913)     end;
                2219 (18913)     scan; spnt1:=spnt;

----------------------------------------------------------------------

R65 Pascal program COMPILE1        11/11/23     page 38

                2220 (18917)     dpnt1:=dpnt;
                2221 (18925)     if token=' (' then parameter;
                2222 (18948)     if t0[cproc]='fi' then function;
                2223 (18967)     testto(' ;');
                2224 (18976)     for i:=1 to npara do
                2225 (18982)     t2[succ(spnt-i)]:=t2[succ(spnt-i)]
                2226 (19014)           -parlevel;
                2227 (19019)     scan;
                2228 (19046)     if token='fw' then begin
                2229 (19054)       if forwpn=8 then merror(13,'ov');
                2230 (19078)       forwpn:=succ(forwpn);
                2231 (19082)       fortab[forwpn]:=cproc;
                2232 (19091)       t2[cproc]:=pc;
                2233 (19103)       code3(36,0);
                2234 (19121)       scan
                2235 (19121)     end else block(cproc);
                2236 (19138)     level:=prec(level);
                2237 (19142)     dpnt:=dpnt1; spnt:=spnt1;
                2238 (19155)     case high(t0[spnt]) of
                2239 (19171)       'r':  t0[spnt]:=packed('t',low(t0[spnt]));
                2240 (19195)       's':  t0[spnt]:=packed('u',low(t0[spnt]))
                2241 (19223)     end {case};
                2242 (19231)     testto(' ;'); scan
                2243 (19240)   end {procedure of function};
                2244 (19244) 
                2245 (19247)   testto('be');     { * begin * }
                2246 (19256)   if forwpn<>0 then merror(13,'ur');
                2247 (19277)   scan; fixup(t2[bottom]);
                2248 (19295)   t2[bottom]:=pc;
                2249 (19299)   code3(35,2*dpnt);
                2250 (19322)   repeat
                2251 (19322)     statmnt
                2252 (19322)   until token='en';
                2253 (19333)   scan;
                2254 (19341)   if level>0 then code1(1) else code1(0);
                2255 (19370)   stackpnt:=stackpn1;
                2256 (19370) end {block};
                2257 (19378) 
                2258 (19379) { * savtable *    ( global) }
                2259 (19379) 
                2260 (19379) proc savtable; { save lib table in @ofno }
                2261 (19379) 
                2262 (19379) var i,j,num: integer;
                2263 (19382)     vtype1: char;
                2264 (19382) 
                2265 (19382) begin
                2266 (19382)   writeln(@ofno,spnt,',',pc+2);
                2267 (19411)   for i:=1 to spnt do begin {for every entry }
                2268 (19430)     for j:=1 to 8 do begin
                2269 (19447)       write(@ofno,idtab[8*i+j])
                2270 (19467)     end;
                2271 (19471)     writeln(@ofno,',',t0[i],',',t1[i],',',
                2272 (19518)       t2[i],',',t3[i]);
                2273 (19545)     vtype1:=high(t0[i]);
                2274 (19553)     if ((vtype1='p') or (vtype1='f') or
                2275 (19572)       (vtype1='g')) and (t3[i]<>0) then begin
                2276 (19593)       num:=stack[t3[i]];
                2277 (19604)       write(@ofno,num);
                2278 (19623)       for j:=1 to num do
                2279 (19629)         write(@ofno,',',stack[t3[i]+j]);

----------------------------------------------------------------------

R65 Pascal program COMPILE1        11/11/23     page 39

                2280 (19668)       write(@ofno,cr,lf);
                2281 (19694)     end {then};
                2282 (19694)   end {for}
                2283 (19694) end {savtable};
                2284 (19708) 
                2285 (19709) { * main program * }
                2286 (19709) 
                2287 (19709) begin {main}
                2288 (19709)   init;scan;
                2289 (19720)   case token of
                2290 (19720)     'pg': begin
                2291 (19732)             libflg:=false;
                2292 (19734)             asetfile(pname,scyclus,sdrive,'Q');
                2293 (19760)           end;
                2294 (19760)     'li': begin
                2295 (19771)             libflg:=true;
                2296 (19773)             asetfile(pname,scyclus,sdrive,'T');
                2297 (19799)           end
                2298 (19799)     else
                2299 (19799)       merror(2,'pg')
                2300 (19807)   end {case}
                2301 (19815)   parse('id');
                2302 (19824)   i:=0;
                2303 (19826)   repeat
                2304 (19830)     i:=succ(i);
                2305 (19834)   until (i>7) or (pname[i] = ':') or
                2306 (19857)       (pname[i]<>uppercase(ident[i+1]));
                2307 (19886)   if i<8 then
                2308 (19896)     merror(2,packed(pname[0],pname[1]));
                2309 (19921)     { name differs from filename }
                2310 (19921)   parse(' ;');
                2311 (19930)   if ofno<>nooutput then openw(ofno);
                2312 (19946)   scan;
                2313 (19950)   if (token='us') and (libflg=false) then begin
                2314 (19966)     repeat
                2315 (19969)       getlib; scan
                2316 (19973)     until token<>' ,';
                2317 (19984)     testto(' ;'); scan
                2318 (19997)   end;
                2319 (20001)   block(0); testto(' .');
                2320 (20018)   if ofno<>nooutput then begin
                2321 (20025)     write(@ofno,'E');
                2322 (20036)     savebyte(pc and 255);
                2323 (20049)     savebyte(pc shr 8);
                2324 (20062)     close(ofno);
                2325 (20068)     if libflg then begin
                2326 (20072)       asetfile(pname,scyclus,sdrive,'L');
                2327 (20097)       openw(ofno);
                2328 (20103)       savtable;
                2329 (20107)       close(ofno)
                2330 (20107)     end
                2331 (20113)   end else
                2332 (20113)     runerr:=$87; {no loader file}
                2333 (20122)   writeln;
                2334 (20122)   writeln;
                2335 (20128)   writeln('End compile');
                2336 (20152)   writeln;
                2337 (20152)   writeln('Code lenght:          ',pc);
                2338 (20192)   writeln('Compiler stack size:  ',stackmax);
                2339 (20226)   writeln('Ident stack size:     ',spntmax);

----------------------------------------------------------------------

R65 Pascal program COMPILE1        11/11/23     page 40

                2340 (20260)   write('Pascal errors:        ');
                2341 (20283)   if numerr>0 then write(invvid);
                2342 (20296)   writeln(numerr,norvid);
                2343 (20310)   if prt then begin
                2344 (20314)     write(prtoff);
                2345 (20320)     setemucom(9);
                2346 (20328)   end;
                2347 (20328)   close(fno);
                2348 (20334)   { check whether second pass is not required }
                2349 (20334)   if (runerr=0) and libflg then runerr:=-1;
                2350 (20350) end {main}.
                2351 (20355) 

End compile

Code lenght:          20354
Compiler stack size:  134
Ident stack size:     209
Pascal errors:        0
