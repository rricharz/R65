
R65 COMPILE 4.2: program COMPILE1         10/2/24 page 1


   1 (    4) {   ********************************
   2 (    4)     *                              *
   3 (    4)     *  R65 "Tiny" Pascal Compiler  *
   4 (    4)     *            Pass 1            *
   5 (    4)     *                              *
   6 (    4)     ********************************
   7 (    4) 
   8 (    4) First version 1978 by rricharz
   9 (    4) Version 3.7 (20K)  01/08/82 rricharz
  10 (    4) 
  11 (    4) Recovered 2018 by rricharz (r77@bluewin.ch)
  12 (    4) Improved 2018-2023 by rricharz
  13 (    4) Version 4 with cpnt strings and exit statement
  14 (    4) 
  15 (    4) Original derived from the publication by
  16 (    4) Kin-Man Chung and Herbert Yen in
  17 (    4) Byte, Volume 3, Number 9 and Number 10, 1978
  18 (    4) 
  19 (    4) Adapted for the R65 computer system and
  20 (    4) substantially enhanced by rricharz 1978-2023
  21 (    4) 
  22 (    4) This is a Pascal derivative optimized for 8-bit
  23 (    4) microprocessors (integer type is 16 bit) with
  24 (    4) additional features (mem) to interact directly
  25 (    4) with the microprocessor hardware. Only one
  26 (    4) dimensional arrays and no records or user
  27 (    4) defined types. Floating point numbers (real)
  28 (    4) and file io to floppy disks are supported.
  29 (    4) 
  30 (    4) Precompiled libraries are merged in the loader.
  31 (    4) The table of reserved words and the library
  32 (    4) tables are loaded from the same drive as
  33 (    4) the compiler.
  34 (    4) 
  35 (    4) The output of the program is a loader file for
  36 (    4) the Pascal loader (compile2).
  37 (    4) 
  38 (    4) usage:
  39 (    4)  compile1 name[.cy[,drv]] [xxx]
  40 (    4)   where x:       l,p: no hard copy print
  41 (    4)                  i,r: index bound checking
  42 (    4)                  n: no loader file
  43 (    4)   [] means not required
  44 (    4) 
  45 (    4) The compiler uses 2 fixed memory areas to store
  46 (    4) the table of reserved words and the table of
  47 (    4) idents. The top of the Pascal stack (endstk) is
  48 (    4) adjusted accordingly. The reason for this hack
  49 (    4) is speed and convenience. A normal Pascal array
  50 (    4) of chars would store the chars as 16 bit
  51 (    4) numers and would therefore require twice the
  52 (    4) space. An array of packed chars would require
  53 (    4) more coding and slow the scanner module of the
  54 (    4) compiler down.                                }
  55 (    4) 
  56 (    4) program compile1;
  57 (    4) 
  58 (    4) uses syslib, arglib;
  59 ( 1093) 

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 2

  60 ( 1093) const version='4.2';
  61 ( 1100) 
  62 ( 1100)     table     =$97ff; {user ident table -1}
  63 ( 1100)     idtab     =$95ff; {resword table -1}
  64 ( 1100)     idlength  =64;    {max. length of ident}
  65 ( 1100)     stacksize =256;   {stack size}
  66 ( 1100)     pagelenght=60;    {no of lines per page}
  67 ( 1100)     nooutput  =@0;
  68 ( 1100)     maxfi     =3;     {max number of ins fls}
  69 ( 1100) 
  70 ( 1100)     nresw=63;   {number of res. words, max 64}
  71 ( 1100)     symbsize=256;     {id table entries}
  72 ( 1100)     reswtabpos=$c600; { up to $c7ff }
  73 ( 1100)     idtabpos=$be00;   { up to $c5ff }
  74 ( 1100) 
  75 ( 1100)     yesoutput=@255;
  76 ( 1100) 
  77 ( 1100) mem endstk  =$000e: integer;
  78 ( 1100)     reswtab =reswtabpos: array[$200] of char&;
  79 ( 1100)     idtab   =idtabpos: array[$800] of char&;
  80 ( 1100) 
  81 ( 1100) var tpos,pc,level,line,offset,dpnt,spnt,fipnt,
  82 ( 1100)     npara,i,stackpnt,stackmax,spntmax,numerr
  83 ( 1100)                               :integer;
  84 ( 1100) 
  85 ( 1100)     scyclus,sdrive,cdrive: integer;
  86 ( 1100) 
  87 ( 1100)     pname: array[15] of char;
  88 ( 1100) 
  89 ( 1100)     value: array[1] of integer;
  90 ( 1100) 
  91 ( 1100)     ch,restype,vartype:char;
  92 ( 1100) 
  93 ( 1100)     token: packed char;
  94 ( 1100) 
  95 ( 1100)     prt,libflg,icheck,ateof,lineflg,nlflg: boolean;
  96 ( 1100) 
  97 ( 1100)     fno,ofno,savefno: file;
  98 ( 1100) 
  99 ( 1100)     filstk: array[maxfi] of file;
 100 ( 1100) 
 101 ( 1100)     ident: array[idlength] of char;
 102 ( 1100)     { Only the first 8 characters are
 103 ( 1100)       used to find and differentiate ids }
 104 ( 1100) 
 105 ( 1100)     t0: array[symbsize] of packed char;
 106 ( 1100)            {type of symbol}
 107 ( 1100) 
 108 ( 1100)         {High letter:
 109 ( 1100)          a:array, c:constant, d;const parameter
 110 ( 1100)          e:constant array parameter, f:function
 111 ( 1100)          g:array function, h;8-bit memory var
 112 ( 1100)          i:8-bit array memory variable
 113 ( 1100)          m:16-bit memory variable
 114 ( 1100)          n:16-bit array memory variable
 115 ( 1100)          p:procedure
 116 ( 1100)          q:indexed cpnt
 117 ( 1100)          r,t:function result
 118 ( 1100)          s,u:array function result
 119 ( 1100)          v:variable, w:variable parameter

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 3

 120 ( 1100)          x:variable array parameter
 121 ( 1100) 
 122 ( 1100)          Low letter:
 123 ( 1100)          i:integer, c:char, p:packed char
 124 ( 1100)          q:cpnt (pointer to chars)
 125 ( 1100)          r:real(array multiple of two)
 126 ( 1100)          s:const cpnt
 127 ( 1100)          f:file, b:boolean, u:undefined  }
 128 ( 1100) 
 129 ( 1100)     t1: array[symbsize] of integer;
 130 ( 1100)          {level}
 131 ( 1100)     t2: array[symbsize] of integer;
 132 ( 1100)          {val,dis,addr}
 133 ( 1100)     t3: array[symbsize] of integer;
 134 ( 1100)          {stack pointer,size of array}
 135 ( 1100) 
 136 ( 1100)     reswcod:array[nresw] of packed char;
 137 ( 1100) 
 138 ( 1100)     stack: array[stacksize] of integer;
 139 ( 1100) 
 140 ( 1100) 
 141 ( 1100) {       * savebyte *    (global)        }
 142 ( 1100) 
 143 ( 1100) proc savebyte(x: integer);
 144 ( 1100) 
 145 ( 1100) begin
 146 ( 1100)     if ofno<>nooutput then begin
 147 ( 1112)       write(@ofno,
 148 ( 1115)         chr(((x and 255) shr 4)+ord('0')));
 149 ( 1136)       write(@ofno,chr((x and 15)+ord('0')))
 150 ( 1151)     end
 151 ( 1154) end {savebyte};
 152 ( 1154) 
 153 ( 1155) {       * crlf *        (global)        }
 154 ( 1155) 
 155 ( 1155) proc newpage; forward;
 156 ( 1158) 
 157 ( 1158) proc crlf;
 158 ( 1158)   var i: integer;
 159 ( 1161) begin
 160 ( 1161)   writeln;
 161 ( 1163)   line:=succ(line);
 162 ( 1173)   if (line div pagelenght)*pagelength=line
 163 ( 1188)     then newpage;
 164 ( 1200) end {crlf};
 165 ( 1200) 
 166 ( 1201) {       error message   (global)        }
 167 ( 1201) 
 168 ( 1201) proc merror(x: integer; code: packed char);
 169 ( 1201) 
 170 ( 1201) var i: integer;
 171 ( 1204)     answer: char;
 172 ( 1204) 
 173 ( 1204) begin
 174 ( 1204)   crlf; numerr:=succ(numerr);
 175 ( 1214)   for i:=2 to tpos do write(' ');
 176 ( 1240)   write('^'); crlf;
 177 ( 1260)   write('*** (',numerr,',',pc,')   ');
 178 ( 1283)   case x of
 179 ( 1283)     01: write('Ident');

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 4

 180 ( 1300)     02: write('Ident ',code,' expected');
 181 ( 1336)     03: write('Var declaration');
 182 ( 1362)     04: write('Const expected');
 183 ( 1387)     05: write('Ident unknown');
 184 ( 1411)     06: write('Cannot be assigned');
 185 ( 1440)     07: write('Symbol table overflow');
 186 ( 1472)     08: write('Stack overflow');
 187 ( 1497)     09: write('Expression');
 188 ( 1518)     10: write('Statement');
 189 ( 1538)     11: write('Declaration');
 190 ( 1560)     12: write('Constant');
 191 ( 1579)     13: write('Forward reference: ',code);
 192 ( 1618)     14: write('Type mismatch: ',code);
 193 ( 1653)     15: write('Array size');
 194 ( 1674)     16: write('Array (8-bit)');
 195 ( 1698)     17: write('Real');
 196 ( 1713)     18: write('File table overflow');
 197 ( 1743)     19: write('Parameter');
 198 ( 1763)     20: write('Compiler directive syntax');
 199 ( 1799)     21: write('Nested include files')
 200 ( 1830)   end {case};
 201 ( 1832)   writeln;
 202 ( 1832)   write('Continue?');
 203 ( 1848)   read(@key,answer);
 204 ( 1856)   if answer<>'Y' then begin
 205 ( 1864)     crlf; write(prtoff); setemucom(9); close(fno);
 206 ( 1888)     if (ofno<>nooutput) and (ofno<>yesoutput)
 207 ( 1901)       then close(ofno);
 208 ( 1912)     writeln('Aborting compile1 on request');
 209 ( 1947)     abort
 210 ( 1947)   end
 211 ( 1951)   else crlf;
 212 ( 1958)   if (ofno<>nooutput) and (ofno<>yesoutput)
 213 ( 1971)     then close(ofno);
 214 ( 1982)   ofno:=nooutput;
 215 ( 1984) end {merror};
 216 ( 1988) 
 217 ( 1989) proc error(x: integer);
 218 ( 1989) 
 219 ( 1989) begin
 220 ( 1989)   merror(x,'##')
 221 ( 2001) end;
 222 ( 2007) 
 223 ( 2008) {       * push & pop *  (global) }
 224 ( 2008) 
 225 ( 2008) proc push(x: %integer);
 226 ( 2008) 
 227 ( 2008) begin
 228 ( 2008)   if stackpnt>=stacksize then error(8)
 229 ( 2026)   else stackpnt:=succ(stackpnt);
 230 ( 2039)   if stackpnt>stackmax then stackmax:=stackpnt;
 231 ( 2056)   stack[stackpnt]:=x;
 232 ( 2068) end {push};
 233 ( 2076) 
 234 ( 2077) func pop: integer;
 235 ( 2077) 
 236 ( 2077) begin
 237 ( 2077)   pop:=stack[stackpnt];
 238 ( 2086)   stackpnt:=prec(stackpnt)
 239 ( 2094) end {pop};

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 5

 240 ( 2103) 
 241 ( 2104) {       * newpage *     (global) }
 242 ( 2104) 
 243 ( 2104) proc newpage;
 244 ( 2104) 
 245 ( 2104) var i: integer;
 246 ( 2107) 
 247 ( 2107) begin
 248 ( 2107)   if (line<>0) and prt then
 249 ( 2116)     write(@printer,formfeed);
 250 ( 2131)   writeln; { Do not count this line}
 251 ( 2137)   if pname[0]<>'x' then begin
 252 ( 2146)     write('R65 COMPILE ');
 253 ( 2162)     write(version);
 254 ( 2167)     if libflg then write(': library ')
 255 ( 2185)     else write(': program ');
 256 ( 2199)     prtext16(output,pname);
 257 ( 2213)   end;
 258 ( 2213)   write(' ');
 259 ( 2215)   prtdate(output);
 260 ( 2223)   writeln(' page ',(line div pagelenght)+1);
 261 ( 2247)   writeln;
 262 ( 2247) end {newpage};
 263 ( 2253) 
 264 ( 2254) {        * code1 *      (global) }
 265 ( 2254) 
 266 ( 2254) proc code1(x: %integer);  {set one byte p-code}
 267 ( 2254) begin
 268 ( 2254)   savebyte(x); pc:=succ(pc)
 269 ( 2269) end;
 270 ( 2278) 
 271 ( 2279) {       * getchr *      (global) }
 272 ( 2279) 
 273 ( 2279) proc writenum(i: integer);
 274 ( 2279) begin
 275 ( 2279)   if i<=999 then write(' ');
 276 ( 2297)   if i<=99 then write(' ');
 277 ( 2309)   if i<=9 then write(' ');
 278 ( 2321)   write(i);
 279 ( 2326) end;
 280 ( 2326) 
 281 ( 2327) proc nextline;
 282 ( 2327) begin
 283 ( 2327)   nlflg:=true;
 284 ( 2334)   if savefno=@0 then writenum(line)
 285 ( 2348)   else begin
 286 ( 2361)     write('****');
 287 ( 2366)     line:=line-1; { do not count line }
 288 ( 2377)   end;
 289 ( 2377)   write(' (');
 290 ( 2380)   if (pc+2)<9999 then write(' ');
 291 ( 2396)   writenum(pc+2); write(') ');
 292 ( 2412) end;
 293 ( 2412) 
 294 ( 2413) proc getchr;
 295 ( 2413) 
 296 ( 2413) begin
 297 ( 2413)   if ateof then begin
 298 ( 2422)     if savefno<>@0 then begin
 299 ( 2432)       { end of include file }

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 6

 300 ( 2435)       close(fno);
 301 ( 2441)       fno:=savefno;
 302 ( 2441)       savefno:=@0;
 303 ( 2451)       ateof:=false;
 304 ( 2457)     end else begin
 305 ( 2464)       writeln('Unexpected eof');
 306 ( 2485)       abort
 307 ( 2485)     end
 308 ( 2489)   end else begin
 309 ( 2492)     read(@fno,ch);
 310 ( 2502)     if ch=cr then begin
 311 ( 2510)       crlf;
 312 ( 2517)       nextline;
 313 ( 2521)       ch:=' ';
 314 ( 2523)     end {if}
 315 ( 2527)     else if ch=eof then begin
 316 ( 2537)       ateof:=true;
 317 ( 2542)       { we need to suppy one more char }
 318 ( 2546)       { for end. at end of file to work properly }
 319 ( 2546)       ch:=' ';
 320 ( 2548)     end {else if}
 321 ( 2552)     else write(ch);
 322 ( 2560)   end;
 323 ( 2560) end {getchr};
 324 ( 2560) 
 325 ( 2561) {       * splitconv *   (global) }
 326 ( 2561) 
 327 ( 2561) proc splitconv(a: array[1] of %integer;
 328 ( 2561)   var b:array[1] of %integer);
 329 ( 2561) 
 330 ( 2561) begin
 331 ( 2561)   b:=a;
 332 ( 2566) end;
 333 ( 2578) 
 334 ( 2579) {       * init *        (global) }
 335 ( 2579) 
 336 ( 2579) proc init;
 337 ( 2579) 
 338 ( 2579) const char96=chr(20);
 339 ( 2582) 
 340 ( 2582) var i,j,dummy: integer;
 341 ( 2582)     dch: char;
 342 ( 2582)     pch: packed char;
 343 ( 2582)     request: array[15] of char;
 344 ( 2582)     default: boolean;
 345 ( 2582) 
 346 ( 2582) begin {init}
 347 ( 2582)   writeln('R65 PASCAL COMPILER version ', version,
 348 ( 2616)     ', Pass  1');
 349 ( 2634)   ateof:=false; savefno:=@0;
 350 ( 2642)   cdrive:=fildrv; { drive of compile program }
 351 ( 2653)   fipnt:=-1;
 352 ( 2655)   endstk:=idtabpos-144;
 353 ( 2665)   pc:=2; dpnt:=0; spnt:=0; offset:=2;
 354 ( 2689)   npara:=0; level:=0;
 355 ( 2701)   stackpnt:=0; libflg:=false;
 356 ( 2713)   stackmax:=0;spntmax:=0; numerr:=0;
 357 ( 2731)   t0[0]:='vi'; t1[0]:=0; t2[0]:=0; t3[0]:=0;
 358 ( 2764)   { prepare resword table }
 359 ( 2768)   writeln('Reading list of reserved words');

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 7

 360 ( 2805)   asetfile('RESWORDS:W      ',0,cdrive,'W');
 361 ( 2837)   openr(fno);
 362 ( 2843)   for i:=0 to nresw do begin
 363 ( 2860)     read(@fno,pch,dch);
 364 ( 2877)     reswcod[i]:=pch;
 365 ( 2882)     for j:=0 to 7 do reswtab[8*i+j]:=' ';
 366 ( 2921)     j:=0;
 367 ( 2944)     while (j<8) and (dch<>cr) do begin
 368 ( 2966)       read(@fno,dch);
 369 ( 2976)       if (dch<>cr) then
 370 ( 2984)         reswtab[8*i+j]:=dch;
 371 ( 2999)       j:=succ(j)
 372 ( 3010)     end;
 373 ( 3019)     while (dch<>cr) and (dch<>eof) do
 374 ( 3036)       read(@fno,dch)
 375 ( 3045)   end;
 376 ( 3054)   close(fno);
 377 ( 3074) 
 378 ( 3074)   writeln;
 379 ( 3074) 
 380 ( 3080)   sdrive:=1; {default drive for source }
 381 ( 3086)   scyclus:=0;
 382 ( 3088)   agetstring(pname,default,scyclus,sdrive);
 383 ( 3132) 
 384 ( 3132)   agetstring(request,default,dummy,dummy);
 385 ( 3172)   icheck:=false;
 386 ( 3174)   prt:=true; ofno:=yesoutput; lineflg:=false;
 387 ( 3192)   if not default then begin
 388 ( 3201)     if request[0]<>'/' then argerror(103);
 389 ( 3224)     for i:=1 to 8 do
 390 ( 3232)       case request[i] of
 391 ( 3245)         'P': prt:=false;
 392 ( 3258)         'L': lineflg:=true;
 393 ( 3274)         'I','R': icheck:=true;
 394 ( 3297)         'N': ofno:=nooutput;
 395 ( 3313)         ' ': begin end
 396 ( 3327)         else argerror(104)
 397 ( 3332)       end; {case}
 398 ( 3354)   end;
 399 ( 3354) 
 400 ( 3354)   asetfile(pname,scyclus,sdrive,'P');
 401 ( 3376)   openr(fno);
 402 ( 3382)   scyclus:=filcyc; { may have changed }
 403 ( 3390) 
 404 ( 3390)   {save cyclus and drive for compile2}
 405 ( 3390)   arglist[8]:=scyclus;
 406 ( 3392)   arglist[9]:=sdrive;
 407 ( 3406)   numarg:=1;
 408 ( 3420) 
 409 ( 3424)   if prt then begin
 410 ( 3428)     write(prton);
 411 ( 3434)     setemucom(8);
 412 ( 3442)   end
 413 ( 3442) 
 414 ( 3442)   line:=0; newpage; crlf; line:=1;
 415 ( 3458)   write('   1 (    4) '); getchr
 416 ( 3476) end {init};
 417 ( 3480) 
 418 ( 3481) 
 419 ( 3481) { ############################# }

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 8

 420 ( 3481) {       *scan*              (global)    }
 421 ( 3481) { ############################# }
 422 ( 3481) { scan input and make tokens }
 423 ( 3481) 
 424 ( 3481) proc scan;
 425 ( 3481) 
 426 ( 3481) var count,ll,hh,i,i1,co: integer;
 427 ( 3484)     name: array[7] of char;
 428 ( 3484) 
 429 ( 3484) {       * compresw*     (of scan)       }
 430 ( 3484) 
 431 ( 3484) func compresw(index: integer);
 432 ( 3484) 
 433 ( 3484) var addr,ci,i: integer;
 434 ( 3487) 
 435 ( 3487) begin
 436 ( 3487)   addr:=8*index; i:=0;
 437 ( 3502)   repeat
 438 ( 3506)     ci:=ord(ident[i+1])-ord(reswtab[addr+i]);
 439 ( 3531)     i:=succ(i)
 440 ( 3536)   until (ci<>0) or (i>=8);
 441 ( 3559)   compresw:=ci
 442 ( 3563) end {compresw};
 443 ( 3571) 
 444 ( 3572) {       * clear *       (of scan)              }
 445 ( 3572) 
 446 ( 3572) proc clear; {clears 8 chars of identifier}
 447 ( 3572) 
 448 ( 3572) var i: integer;
 449 ( 3575) 
 450 ( 3575) begin
 451 ( 3575)   for i:=1 to 8 do ident[i]:=' '
 452 ( 3598) end;
 453 ( 3618) 
 454 ( 3619) {       * pack *        (of scan)              }
 455 ( 3619) 
 456 ( 3619) proc pack;  {packs token and ch to token }
 457 ( 3619) 
 458 ( 3619) begin
 459 ( 3619)   token:=packed(low(token),ch); getchr
 460 ( 3638) end;
 461 ( 3642) 
 462 ( 3643) {       * setval *      (of scan)              }
 463 ( 3643) 
 464 ( 3643) proc setval;
 465 ( 3643) 
 466 ( 3643) var r: real;
 467 ( 3646)     n,n1: integer;
 468 ( 3646)     ems: boolean;
 469 ( 3646) 
 470 ( 3646)   func times10(r:real):real;
 471 ( 3646)   { slightly more accurate than 10.0*r }
 472 ( 3646)   var r2,r4:real;
 473 ( 3649)   begin
 474 ( 3649)     r2:=r+r;
 475 ( 3657)     r4:=r2+r2;
 476 ( 3676)     times10:=r2+r4+r4;
 477 ( 3702)   end;
 478 ( 3715) 
 479 ( 3716) begin

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 9

 480 ( 3716)   r:=0.0;
 481 ( 3724)   repeat
 482 ( 3730)     r:=times10(r)+conv(ord(ch)-ord('0'));
 483 ( 3751)     getchr;
 484 ( 3763)   until (ch<'0') or (ch>'9');
 485 ( 3777)   if ch<>'.' then begin {numeric integer}
 486 ( 3791)     token:='nu';
 487 ( 3794)     value[0]:=trunc(r+0.5);
 488 ( 3813)   end
 489 ( 3818)   else begin {numeric real}
 490 ( 3821)     n:=0; getchr;
 491 ( 3831)     while (ch<='9') and (ch>='0') do begin
 492 ( 3849)       r:=times10(r)+conv(ord(ch)-ord('0'));
 493 ( 3870)       n:=prec(n); getchr
 494 ( 3887)     end;
 495 ( 3891)     if ch='e' then begin
 496 ( 3901)       ems:=false; getchr;
 497 ( 3914)       case ch of
 498 ( 3914)         '+': getchr;
 499 ( 3929)         '-': begin ems:=true; getchr end
 500 ( 3949)       end;
 501 ( 3951)       if (ch>'9') or (ch<'0') then error(17)
 502 ( 3971)       else begin
 503 ( 3980)         n1:=ord(ch)-ord('0');
 504 ( 3986)         getchr;
 505 ( 3995)         if (ch<='9') and (ch>='0') then begin
 506 ( 4010)           n1:=10*n1+ord(ch)-ord('0');
 507 ( 4027)           getchr
 508 ( 4032)         end;
 509 ( 4036)         if ems then n:=n-n1 else n:=n+n1
 510 ( 4063)       end
 511 ( 4063)     end;
 512 ( 4072)     while n>0 do begin
 513 ( 4082)       n:=prec(n);
 514 ( 4086)       r:=times10(r);
 515 ( 4105)     end;
 516 ( 4111)     while n<0 do begin
 517 ( 4124)       n:=succ(n); r:=0.1*r;
 518 ( 4139)     end;
 519 ( 4152)     splitconv(r,value);
 520 ( 4179)     token:='ru'
 521 ( 4179)   end
 522 ( 4182) end {setval};
 523 ( 4186) 
 524 ( 4187) {       * directive *   (of scan               }
 525 ( 4187) 
 526 ( 4187) proc directive;
 527 ( 4187) var i,icyclus:integer;
 528 ( 4190)     name: array[15] of char;
 529 ( 4190) begin
 530 ( 4190)   getchr;
 531 ( 4196)   case ch of
 532 ( 4196)     'I': begin
 533 ( 4207)            if savefno<>@0 then error(21);
 534 ( 4225)            getchr; if ch<>' ' then error(20);
 535 ( 4247)            i:=0; getchr;
 536 ( 4257)            while (ch<>'}') and (i<16) do begin
 537 ( 4275)              name[i]:=ch; i:=i+1; getchr;
 538 ( 4302)            end;
 539 ( 4302)            while (i<16) do begin

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 10

 540 ( 4315)              name[i]:=' '; i:=i+1;
 541 ( 4331)            end;
 542 ( 4336)            icyclus:=0;
 543 ( 4341)            asetfile(name,icyclus,sdrive,'P');
 544 ( 4367)            savefno:=fno;
 545 ( 4367)            openr(fno);
 546 ( 4381)            crlf;
 547 ( 4385)            nextline;
 548 ( 4389)            getchr; scan;
 549 ( 4397)          end
 550 ( 4397)     else error(20)
 551 ( 4402)   end {case}
 552 ( 4410) end;
 553 ( 4410) 
 554 ( 4411) {       * setid *       (of scan)              }
 555 ( 4411) 
 556 ( 4411) proc setid; {sets one char to ident}
 557 ( 4411) 
 558 ( 4411) begin
 559 ( 4411)   if count<=idlength then begin
 560 ( 4423)     ident[count]:=ch; count:=succ(count)
 561 ( 4438)   end;
 562 ( 4447)   getchr;
 563 ( 4451) end {setid};
 564 ( 4451) 
 565 ( 4452) begin { ***** body of scan ***** }
 566 ( 4452)   count:=1; while ch=' ' do getchr;
 567 ( 4474)   tpos:=curpos;
 568 ( 4480) 
 569 ( 4484)   { delayed because of token lookahead }
 570 ( 4484)   if nlflg then begin
 571 ( 4488)     if lineflg and (pc>2) then begin
 572 ( 4503)       code1($59);
 573 ( 4514)       code1((line) and 255);
 574 ( 4527)       code1((line) shr 8);
 575 ( 4540)     end;
 576 ( 4540)     nlflg:=false;
 577 ( 4542)   end;
 578 ( 4546) 
 579 ( 4546)   if (ch<'a') or (ch>'z') then begin {main if}
 580 ( 4564)     if (ch<'0') or (ch>'9') then begin {symb}
 581 ( 4582)       token:=packed(' ',ch); getchr;
 582 ( 4597)       case low(token) of
 583 ( 4601)         '<': if (ch='=') or (ch='>') then pack;
 584 ( 4631)         '>',':': if (ch='=') then pack;
 585 ( 4662)         '{': begin
 586 ( 4672)                if ch='$' then directive
 587 ( 4679)                else begin
 588 ( 4689)                  if ch<>'}' then
 589 ( 4695)                  repeat getchr until ch='}';
 590 ( 4709)                  getchr; scan
 591 ( 4717)                end
 592 ( 4721)              end;
 593 ( 4721)         '$': begin {hex constant}
 594 ( 4731)                token:='nu'; value[0]:=0;
 595 ( 4742)                while ((ch>='0')and(ch<='9'))
 596 ( 4760)                      or((ch>='a')and(ch<='f'))
 597 ( 4775)                      do begin
 598 ( 4780)                  if ch>'9' then
 599 ( 4786)                    value[0]:=(value[0] shl 4)

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 11

 600 ( 4800)                      +ord(ch)-ord('a')+10
 601 ( 4809)                  else
 602 ( 4811)                    value[0]:=(value[0] shl 4)
 603 ( 4829)                      +ord(ch)-ord('0');
 604 ( 4837)                  getchr
 605 ( 4842)                end {do}
 606 ( 4846)              end; {hex constant}
 607 ( 4852)         chr(39): begin {string}
 608 ( 4859)                token:='st';
 609 ( 4862)                repeat setid until ch=chr(39);
 610 ( 4876)                value[0]:=prec(count); getchr
 611 ( 4892)               end
 612 ( 4896)       end {case of token}
 613 ( 4898)     end {special symbols}
 614 ( 4898)     else setval {numeric value}
 615 ( 4905)   end {main if}
 616 ( 4905)   else begin {ident}
 617 ( 4908)     clear;
 618 ( 4912)     repeat
 619 ( 4912)       setid
 620 ( 4912)       until (ch<'0') or (ch>'z') or
 621 ( 4930)         ((ch>'9') and (ch<'A')) or
 622 ( 4946)         ((ch>'Z') and (ch<'a'));
 623 ( 4962)     ll:=0; hh:=nresw; {look up in resword table}
 624 ( 4978)     repeat
 625 ( 4978)       i:=(ll+hh) shr 1; co:=compresw(i);
 626 ( 5006)       if (co<0) then hh:=prec(i)
 627 ( 5020)       else ll:=succ(i);
 628 ( 5036)       until (co=0) or (ll>hh);
 629 ( 5057)     if (co=0) then
 630 ( 5068)       token:=reswcod[i] {reserved word found}
 631 ( 5075)     else token:='id' {ident}
 632 ( 5089)   end {odent}
 633 ( 5093) end {scan};
 634 ( 5093) 
 635 ( 5094) { * testto/parse * }
 636 ( 5094) 
 637 ( 5094) { parce source for specific token; else error }
 638 ( 5094) 
 639 ( 5094) proc testto(x: packed char); { current token }
 640 ( 5094) begin
 641 ( 5094)   if token<>x then merror(2,x)
 642 ( 5113) end;
 643 ( 5123) 
 644 ( 5124) proc parse(x: packed char); { next token }
 645 ( 5124) begin
 646 ( 5124)   scan; testto(x);
 647 ( 5143) end;
 648 ( 5143) 
 649 ( 5144) { * getlib * }
 650 ( 5144) 
 651 ( 5144) proc getlib;  { read library data }
 652 ( 5144) 
 653 ( 5144) var i,j,nent,addr,size,num,x,base: integer;
 654 ( 5147)     libfil: file;
 655 ( 5147)     ch,ltyp2,dummy: char;
 656 ( 5147)     name: array[7] of char;
 657 ( 5147) 
 658 ( 5147) begin
 659 ( 5147)   scan; if token=' ,' then scan;

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 12

 660 ( 5168)   testto('id');
 661 ( 5177)   base:=pc-2;
 662 ( 5183)   if (ofno<>nooutput) then write(@ofno,'L');
 663 ( 5206)   for i:=0 to 7 do begin
 664 ( 5223)     name[i]:=ident[succ(i)];
 665 ( 5232)     if ofno<>nooutput then
 666 ( 5246)       write(@ofno,ident[succ(i)])
 667 ( 5260)   end;
 668 ( 5266)   write(prtoff);
 669 ( 5283)   asetfile(name&'        ',0,cdrive,'L');
 670 ( 5313)   openr(libfil);  { get table file }
 671 ( 5319)   read(@libfil,nent,size);
 672 ( 5334)   {including cr,lf}
 673 ( 5335)   for i:=succ(spnt) to spnt+nent do begin
 674 ( 5362)     if spnt>symbsize then error(7);
 675 ( 5381)     spnt:=succ(spnt); addr:=8*i+1;
 676 ( 5399)     for j:=0 to 7 do begin
 677 ( 5421)       read(@libfil,ch);
 678 ( 5431)       idtab[addr+j]:=ch
 679 ( 5441)     end;
 680 ( 5452)     read(@libfil,ch);
 681 ( 5476)     read(@libfil,t0[i],dummy,t1[i],t2[i],t3[i]);
 682 ( 5525)     t1[i]:=t1[i]+level;
 683 ( 5538)     ltyp2:=high(t0[i]);
 684 ( 5555)     if (ltyp2='p')or(ltyp2='f')
 685 ( 5573)       or(ltyp2='g') then begin
 686 ( 5583)       t2[i]:=t2[i]+base;
 687 ( 5598)       if t3[i]<>0 then begin {stack data}
 688 ( 5621)         read(@libfil,num);
 689 ( 5631)         push(num); t3[i]:=stackpnt;
 690 ( 5646)         for j:=1 to num do begin
 691 ( 5673)           read(@libfil,x);
 692 ( 5683)           push(x);
 693 ( 5694)         end {for j};
 694 ( 5694)       end {stack data}
 695 ( 5708)     end {if ltyp2}
 696 ( 5708)   end {for i}
 697 ( 5708)   level:=succ(level); pc:=pc+size; offset:=pc;
 698 ( 5744)   close(libfil);
 699 ( 5758)   if spnt>spntmax then spntmax:=spnt;
 700 ( 5770)   if stackpnt>stackmax then stackmax:=stackpnt;
 701 ( 5790)   if prt then write(prton);
 702 ( 5808) end {getlib};
 703 ( 5808) 
 704 ( 5809) 
 705 ( 5809) { #################################### }
 706 ( 5809) {       * block * (global): handle one block }
 707 ( 5809) { #################################### }
 708 ( 5809) 
 709 ( 5809) 
 710 ( 5809) proc block(bottom: integer);
 711 ( 5809) 
 712 ( 5809) var l,f9,i,n,stackpn1,forwpn,find,cproc,
 713 ( 5812)     spnt1,dpnt1,parlevel: integer;
 714 ( 5812)     fortab: array[8] of integer;
 715 ( 5812) 
 716 ( 5812) { * find ident *    (of block) }
 717 ( 5812) { this is a fast version for compiler speed }
 718 ( 5812) 
 719 ( 5812) func findid; {search in table for id }

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 13

 720 ( 5812) 
 721 ( 5812) var k,i: integer;
 722 ( 5815)     id1: char;
 723 ( 5815) 
 724 ( 5815) begin
 725 ( 5815) 
 726 ( 5815)   i:=1; k:=8*spnt+9; id1:=ident[1];
 727 ( 5839) 
 728 ( 5847)   repeat
 729 ( 5847)     k:=k-8;
 730 ( 5853)     while (idtab[k]<>id1) and (k>0) do k:=k-8;
 731 ( 5889)     if k>0 then begin
 732 ( 5904)        i:=1;
 733 ( 5909)        repeat i:=succ(i)
 734 ( 5913)          until (i>8) or
 735 ( 5929)              (idtab[k+i-1]<>ident[i]);
 736 ( 5955)     end;
 737 ( 5959)     until (i>8) or (k<=0);
 738 ( 5973)   if k<=0 then begin
 739 ( 5984)     findid:=0;
 740 ( 5989)   end
 741 ( 5993)   else
 742 ( 5993)     findid:=(k-1) shr 3;
 743 ( 6005) end;
 744 ( 6010) 
 745 ( 6011) { * code2 *    (of block) }
 746 ( 6011) 
 747 ( 6011) proc code2(x,y: integer);
 748 ( 6011) begin
 749 ( 6011)   code1(x); code1(y);
 750 ( 6036) end;
 751 ( 6036) 
 752 ( 6037) { * code3 *    (of block) }
 753 ( 6037) 
 754 ( 6037) proc code3(x: integer; y1: %integer);
 755 ( 6037) 
 756 ( 6037) var y: integer;
 757 ( 6040) 
 758 ( 6040) begin {code3}
 759 ( 6040)   y:=y1;
 760 ( 6042)   if (x=34) and (y>=0) and (y<256) then
 761 ( 6073)     code2(32,y)
 762 ( 6079)   else begin
 763 ( 6092)     if (x=35) and (y>-128) and (y<=127) then
 764 ( 6115)       begin
 765 ( 6116)         if (y<0) then y:=y+256;
 766 ( 6136)         code2(33,y);
 767 ( 6153)       end
 768 ( 6153)     else begin
 769 ( 6156)       if (x>=36) and (x<=38) then y:=y-pc-1;
 770 ( 6185)       code1(x); code1(y and 255);
 771 ( 6213)       code1(y shr 8);
 772 ( 6226)     end
 773 ( 6226)   end
 774 ( 6226) end {code3};
 775 ( 6226) 
 776 ( 6227) { * testtype *      (of block) }
 777 ( 6227) 
 778 ( 6227) proc testtype(ttype: char);
 779 ( 6227) 

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 14

 780 ( 6227) begin
 781 ( 6227)   if restype<>ttype then
 782 ( 6236)     if (restype<>'u') and (ttype<>'u') then
 783 ( 6258)       merror(14,packed(ttype,restype));
 784 ( 6279) end;
 785 ( 6279) 
 786 ( 6280) { * putsym *   (of block) }
 787 ( 6280) 
 788 ( 6280) proc putsym(ltyp1,ltyp2: char);
 789 ( 6280) 
 790 ( 6280) var i,addr: integer;
 791 ( 6283) begin
 792 ( 6283)   if spnt>symbsize then error(7)
 793 ( 6298)   else spnt:=succ(spnt);
 794 ( 6311)   if spnt>spntmax then spntmax:=spnt;
 795 ( 6328)   t0[spnt]:=packed(ltyp1,ltyp2);
 796 ( 6349)   t3[spnt]:=0;
 797 ( 6359)   addr:=8*spnt;
 798 ( 6365)   for i:=1 to 8 do idtab[addr+i]:=ident[i];
 799 ( 6404)   if ltyp1='v' then begin
 800 ( 6436)     t2[spnt]:=dpnt; dpnt:=succ(dpnt);
 801 ( 6455)   end;
 802 ( 6460)   t1[spnt]:=level
 803 ( 6464) end {putsym};
 804 ( 6472) 
 805 ( 6473) { * checkindex *  (of block) }
 806 ( 6473) 
 807 ( 6473) proc checkindex(lowlim,highlim: integer);
 808 ( 6473) begin
 809 ( 6473)   if icheck then begin
 810 ( 6482)     code3($40,lowlim-1);
 811 ( 6500)     code2(highlim and 255, highlim shr 8)
 812 ( 6513)   end
 813 ( 6520) end;
 814 ( 6520) 
 815 ( 6521) { * getcon *      (of block) }
 816 ( 6521) 
 817 ( 6521) func getcon;
 818 ( 6521) 
 819 ( 6521) var idpnt,val,ii: integer;
 820 ( 6524)     rval: real;
 821 ( 6524)     sign: char;
 822 ( 6524) begin
 823 ( 6524)   restype:='i';
 824 ( 6528)   if token=' -' then begin
 825 ( 6540)     sign:='-'; scan
 826 ( 6549)   end else begin
 827 ( 6556)     sign:='+'; if token=' +' then scan
 828 ( 6570)   end;
 829 ( 6577)   case token of
 830 ( 6577)     'nu': val:=value[0];
 831 ( 6591)     'ru': begin val:=value[0];
 832 ( 6612)             restype:='r' end;
 833 ( 6626)     'st': if value[0]=1 then begin
 834 ( 6646)             restype:='c';
 835 ( 6651)             val:=ord(ident[1])
 836 ( 6657)           end else if value[0]=2 then begin
 837 ( 6677)             val:=(ord(ident[1]) shl 8) +
 838 ( 6689)               ord(ident[2]);
 839 ( 6695)             restype:='p';

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 15

 840 ( 6702)           end else if value[0]>2 then begin
 841 ( 6718)             val:=pc;
 842 ( 6721)             for ii:=1 to value[0] do
 843 ( 6737)                         code1(ord(ident[ii]));
 844 ( 6764)             code1(0); value[0]:=0; restype:='s';
 845 ( 6796)           end else error(15);
 846 ( 6811)     'cr': begin parse(' ('); scan; val:=getcon;
 847 ( 6841)             if (val>127) or (val<0) then
 848 ( 6859)               error(12);
 849 ( 6871)             testtype('i');
 850 ( 6879)             restype:='c'; parse(' )');
 851 ( 6894)           end;
 852 ( 6894)     'tr': begin val:=1; restype:='b' end;
 853 ( 6917)     'fa': begin val:=0; restype:='b' end;
 854 ( 6940)     'cp': begin
 855 ( 6951)             scan; val:=getcon;
 856 ( 6961)             testtype('i'); restype:='q';
 857 ( 6975)           end;
 858 ( 6979)     ' @': begin scan; val:=getcon;
 859 ( 7000)             if restype<>'q' then testtype('i');
 860 ( 7022)             restype:='f'
 861 ( 7022)           end
 862 ( 7024)     else begin
 863 ( 7031)       testto('id'); idpnt:=findid;
 864 ( 7046)       if (idpnt>0) and (high(t0[idpnt])='c')
 865 ( 7068)       then begin
 866 ( 7070)         val:=t2[idpnt];
 867 ( 7077)         restype:=low(t0[idpnt]);
 868 ( 7093)         if restype='r' then
 869 ( 7104)           value[1]:=t3[idpnt];
 870 ( 7114)       end
 871 ( 7122)       else begin error(4); val:=0;
 872 ( 7135)         restype:='i'
 873 ( 7139)       end
 874 ( 7141)     end
 875 ( 7145)   end {case};
 876 ( 7147)   if sign='-' then
 877 ( 7153)     case restype of
 878 ( 7157)       'i': getcon:=-val;
 879 ( 7168)       'r': begin value[0]:=val;
 880 ( 7189)              splitconv(value,rval);
 881 ( 7221)              splitconv(-rval,value);
 882 ( 7246)              getcon:=value[0]
 883 ( 7248)            end
 884 ( 7248)       else error(12)
 885 ( 7261)     end {case}
 886 ( 7269)   else getcon:=val;
 887 ( 7272) end {getcon};
 888 ( 7280) 
 889 ( 7281) { * deccon *         ( of block ) }
 890 ( 7281) 
 891 ( 7281) proc deccon;    { declare constant }
 892 ( 7281) begin
 893 ( 7281)   if token=' ;' then scan;
 894 ( 7301)   testto('id');
 895 ( 7310)   putsym('c','i');
 896 ( 7320)   parse(' ='); scan;
 897 ( 7333)   t2[spnt]:=getcon;
 898 ( 7343)   if (restype='r') then t3[spnt]:=value[1];
 899 ( 7363)   if restype<>'i' then

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 16

 900 ( 7377)     t0[spnt]:=packed('c',restype);
 901 ( 7392)   scan
 902 ( 7396) end {deccon};
 903 ( 7400) 
 904 ( 7401) { * decvar *          ( of block ) }
 905 ( 7401) 
 906 ( 7401) proc decvar(typ1,typ2: char);
 907 ( 7401) begin
 908 ( 7401)   if token=' ,' then scan;
 909 ( 7421)   testto('id');
 910 ( 7430)   putsym(typ1,typ2);
 911 ( 7444)   scan;
 912 ( 7448) end {decvar};
 913 ( 7448) 
 914 ( 7449) { * gettype *         ( of block ) }
 915 ( 7449) 
 916 ( 7449) proc gettype(var typ2: char;
 917 ( 7449)   var aflag,uflag: boolean; var n: integer);
 918 ( 7449) 
 919 ( 7449) begin
 920 ( 7449)   aflag:=false; n:=0; uflag:=false;
 921 ( 7468)   scan;
 922 ( 7476)   if token='ar' then begin
 923 ( 7484)     parse(' ['); scan;
 924 ( 7500)     n:=getcon; testtype('i');
 925 ( 7518)     if (n<1) then begin error(15); n:=1 end;
 926 ( 7542)     parse(' ]'); parse('of'); scan;
 927 ( 7564)     aflag:=true
 928 ( 7564)   end;
 929 ( 7570)   if token=' %' then begin
 930 ( 7578)     scan; uflag:=true
 931 ( 7585)   end;
 932 ( 7591)   case token of
 933 ( 7591)     'in': typ2:='i';
 934 ( 7605)     'ch': typ2:='c';
 935 ( 7622)     'pa': begin parse ('ch'); typ2:='p' end;
 936 ( 7652)     'bo': typ2:='b';
 937 ( 7665)     'rl': begin typ2:='r'; aflag:=true;
 938 ( 7688)             n:=prec(2*succ(n)) end;
 939 ( 7705)     'cp': typ2:='q';
 940 ( 7718)     'fl': typ2:='f'
 941 ( 7733)     else begin error(11); typ2:='i';end
 942 ( 7756)   end {case}
 943 ( 7758) end {gettype};
 944 ( 7758) 
 945 ( 7759) { * variable *        ( of block) }
 946 ( 7759) 
 947 ( 7759) proc variable;  { variable declarations }
 948 ( 7759) 
 949 ( 7759) var typ1,typ2: char;
 950 ( 7762)     i,l: integer;
 951 ( 7762)     aflag,uflag: boolean;
 952 ( 7762) 
 953 ( 7762) begin
 954 ( 7762)   scan;
 955 ( 7768)   repeat {main loop}
 956 ( 7768)     l:=0;
 957 ( 7770)     repeat decvar('v','i'); l:=succ(l);
 958 ( 7788)     until token<> ' ,';
 959 ( 7800)     testto(' :');

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 17

 960 ( 7813)     gettype(typ2,aflag,uflag,n);
 961 ( 7849)     if uflag then error(11);
 962 ( 7864)     if aflag then typ1:='a' else typ1:='v';
 963 ( 7882)     if typ1='a' then begin {array}
 964 ( 7896)        dpnt:=dpnt-l; {variable has been assumed}
 965 ( 7909)        for i:=succ(spnt-l) to spnt do begin
 966 ( 7936)          t2[i]:=dpnt; t3[i]:=n;
 967 ( 7952)          dpnt:=succ(dpnt+n);
 968 ( 7969)       end
 969 ( 7974)     end {array};
 970 ( 7988)     for i:=succ(spnt-l) to spnt do
 971 ( 8002)       t0[i]:=packed(typ1,typ2);
 972 ( 8028)     parse(' ;');scan
 973 ( 8055)   until token<>'id' {end main loop}
 974 ( 8066) end {variable};
 975 ( 8070) 
 976 ( 8071) { * fixup *           ( of block ) }
 977 ( 8071) 
 978 ( 8071) proc fixup(x: integer);
 979 ( 8071) begin
 980 ( 8071)   if ofno<>nooutput then begin
 981 ( 8083)     write(@ofno,'F');
 982 ( 8094)     savebyte(succ(x-offset) and 255);
 983 ( 8113)     savebyte(succ(x-offset) shr 8);
 984 ( 8132)     savebyte((pc-x-1) and 255);
 985 ( 8153)     savebyte((pc-x-1) shr 8);
 986 ( 8174)   end;
 987 ( 8174) end;
 988 ( 8174) 
 989 ( 8175) { * function *        ( of block ) }
 990 ( 8175) 
 991 ( 8175) proc function;
 992 ( 8175) 
 993 ( 8175) var n: integer;
 994 ( 8178)     typ1,typ2: char;
 995 ( 8178)     aflag,uflag: boolean;
 996 ( 8178) begin
 997 ( 8178)   if token<>' :' then begin
 998 ( 8188)     aflag:=false; uflag:=false; typ2:='i' end
 999 ( 8205)   else begin
1000 ( 8212)     gettype(typ2,aflag,uflag,n);
1001 ( 8248)     scan
1002 ( 8248)   end;
1003 ( 8252)   if aflag then begin
1004 ( 8256)     typ1:='s'; t3[succ(cproc)]:=n;
1005 ( 8270)     t2[succ(cproc)]:=t2[succ(cproc)]-n
1006 ( 8292)   end
1007 ( 8292)   else typ1:='r';
1008 ( 8306)   t0[succ(cproc)]:=packed(typ1,typ2);
1009 ( 8324)   if uflag then typ2:='u';
1010 ( 8337)   if aflag then typ1:='g'
1011 ( 8348)   else typ1:='f';
1012 ( 8359)   t0[cproc]:=packed(typ1,typ2);
1013 ( 8376) end {function};
1014 ( 8380) 
1015 ( 8381) { * parameter *       ( of block ) }
1016 ( 8381) 
1017 ( 8381) proc parameter;
1018 ( 8381) 
1019 ( 8381) var counter1,counter2,i,n,bs: integer;

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 18

1020 ( 8384)     aflag,uflag: boolean;
1021 ( 8384)     vtype1,vtype2: char;
1022 ( 8384)     vtype: packed char;
1023 ( 8384) 
1024 ( 8384) begin
1025 ( 8384)   push(0); { dummy size, fixed later }
1026 ( 8394)   if find=0 then t3[spnt-npara]:=stackpnt
1027 ( 8413)   else bs:=stackpnt;
1028 ( 8424)   counter1:=0
1029 ( 8432)   repeat {main loop}
1030 ( 8438)     counter2:=0;
1031 ( 8440)     vtype1:='d'; vtype2:='i';
1032 ( 8452)     scan;
1033 ( 8460)     if token='co' then scan
1034 ( 8468)     else if token='va' then begin
1035 ( 8486)       scan; vtype1:='w' end; {variable param}
1036 ( 8499)     end;
1037 ( 8499)     repeat {inner loop}
1038 ( 8499)       decvar(vtype1,vtype2);
1039 ( 8513)       t2[spnt]:=parlevel;
1040 ( 8517)       parlevel:=succ(parlevel);
1041 ( 8529)       npara:=succ(npara);
1042 ( 8538)       counter2:=succ(counter2);
1043 ( 8547)       until token<>' ,';
1044 ( 8559)     uflag:=false;aflag:=false; n:=0;
1045 ( 8577)     if token<>' :' then
1046 ( 8588)       vtype2:='i' {assume integer }
1047 ( 8594)     else begin
1048 ( 8601)       gettype(vtype2,aflag,uflag,n);
1049 ( 8637)       if n>63 then error(15);
1050 ( 8655)       scan
1051 ( 8655)     end;
1052 ( 8659)     if aflag then begin
1053 ( 8663)       vtype1:=succ(vtype1);
1054 ( 8670)       parlevel:=parlevel-counter2;
1055 ( 8679)     end;
1056 ( 8688)     vtype:=packed(vtype1,vtype2);
1057 ( 8697)     for i:=1 to counter2 do begin
1058 ( 8720)       if uflag then push(packed(vtype1,'u'))
1059 ( 8734)       else push(vtype);
1060 ( 8753)       if aflag then begin
1061 ( 8757)         push(n); t3[spnt-counter2+i]:=n;
1062 ( 8784)         t2[spnt-counter2+i]:=parlevel;
1063 ( 8806)         parlevel:=succ(parlevel)+n;
1064 ( 8819)       end {then};
1065 ( 8828)       t0[spnt-counter2+i]:=vtype;
1066 ( 8842)     end {for};
1067 ( 8850)     if aflag then counter2:=2*counter2;
1068 ( 8873)     counter1:=counter1+counter2;
1069 ( 8886)     until token<>' ;'; {outer loop}
1070 ( 8906)   testto(' )'); scan;
1071 ( 8919)   if find=0 then
1072 ( 8925)     stack[t3[spnt-npara]]:=counter1
1073 ( 8942)   else begin {information is allready there}
1074 ( 8953)     stack[bs]:=counter1;
1075 ( 8957)     n:=t3[fortab[find]]; {existing stack data}
1076 ( 8981)     for i:=0 to stackpnt-bs do
1077 ( 8991)       if stack[bs+1]<>stack[n+1]
1078 ( 9022)         then merror(13,'pa'); {parameter wrong}
1079 ( 9056)     stackpnt:=prec(bs) {clear the new info}

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 19

1080 ( 9060)   end  {else}
1081 ( 9065) end {parameter};
1082 ( 9065) 
1083 ( 9066) { * memory *              ( of block) }
1084 ( 9066) 
1085 ( 9066) proc memory;
1086 ( 9066) 
1087 ( 9066) var typ1,typ2:char;
1088 ( 9069)     i,l,n: integer;
1089 ( 9069)     aflag,uflag: boolean;
1090 ( 9069) 
1091 ( 9069) begin
1092 ( 9069)   scan;
1093 ( 9075)   repeat {main loop}
1094 ( 9075)     l:=0;
1095 ( 9077)     repeat
1096 ( 9081)       decvar('m','i');
1097 ( 9091)       l:=succ(l); testto(' ='); scan;
1098 ( 9113)       n:=getcon; testtype('i');
1099 ( 9131)       scan; t2[spnt]:=n;
1100 ( 9139)     until token<>' ,';
1101 ( 9154)     testto(' :');
1102 ( 9167)     gettype(typ2,aflag,uflag,n);
1103 ( 9203)     if uflag then error(11);
1104 ( 9218)     scan;
1105 ( 9222)     if token=' &' then begin {8-bit}
1106 ( 9233)       typ1:='h'; scan
1107 ( 9239)     end
1108 ( 9243)     else typ1:='m';
1109 ( 9248)     if aflag then typ1:=succ(typ1);
1110 ( 9263)     for i:=succ(spnt-l) to spnt do begin
1111 ( 9295)       t0[i]:=packed(typ1,typ2);
1112 ( 9308)       t3[i]:=n;
1113 ( 9316)     end;
1114 ( 9324)     testto(' ;'); scan;
1115 ( 9351)   until token<>'id';
1116 ( 9358) end {memory};
1117 ( 9362) 
1118 ( 9363) 
1119 ( 9363) {######################################}
1120 ( 9363) { * statement *           ( of block ) }
1121 ( 9363) {######################################}
1122 ( 9363) 
1123 ( 9363) proc statmnt;
1124 ( 9363) 
1125 ( 9363) var idpnt,relad,k2,savpc,bottom1: integer;
1126 ( 9366)     device,wln: boolean;
1127 ( 9366)     savtp1,vartyp2: char;
1128 ( 9366)     wl: boolean;
1129 ( 9366) 
1130 ( 9366) { * code4 *               ( of statement ) }
1131 ( 9366) 
1132 ( 9366) proc code4(x,y1,z1: integer); {set 4-byte code}
1133 ( 9366) 
1134 ( 9366) var y,z: integer;
1135 ( 9369) 
1136 ( 9369) begin
1137 ( 9369)   y:=y1; z:=z1;
1138 ( 9379)   if y<0 then y:=y+256;
1139 ( 9404)   if x=43 then z:=z-pc-2;

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 20

1140 ( 9430)   code1(x);code1(y);code1(z and 255);
1141 ( 9468)   code1(z shr 8)
1142 ( 9474) end {code4};
1143 ( 9481) 
1144 ( 9482) { * testferror *         ( of statement) ) }
1145 ( 9482) 
1146 ( 9482) proc testferror;
1147 ( 9482) begin
1148 ( 9482)   code1($4f);
1149 ( 9495) end;
1150 ( 9495) 
1151 ( 9496) { * gpval *              ( of statement ) }
1152 ( 9496) 
1153 ( 9496) proc gpval(idpnt: integer;
1154 ( 9496)   dir: boolean; typ: char);
1155 ( 9496) 
1156 ( 9496) var d: integer;
1157 ( 9499) 
1158 ( 9499) begin {gpval}
1159 ( 9499)   if dir then d:=1 else d:=0;
1160 ( 9519)   case typ of
1161 ( 9523)   'h':  begin code3($22,t2[idpnt]);
1162 ( 9550)           if dir then code1($3f);
1163 ( 9565)           code1($17+d) end;
1164 ( 9578)   'm':  begin code3($22,t2[idpnt]);
1165 ( 9604)           code1($3d+d) end;
1166 ( 9617)   'i':  begin
1167 ( 9627)           if dir then code1($3f);
1168 ( 9642)           code3($22,t2[idpnt]);
1169 ( 9658)           code1(3);
1170 ( 9666)           if dir then code1($3f);
1171 ( 9681)           code1($17+d) end;
1172 ( 9694)   'n':  begin if dir then code1($3f);
1173 ( 9719)           code3($22,1); code1($12);
1174 ( 9737)           code3($22,t2[idpnt]);
1175 ( 9753)           code1(3); code1($3d+d) end
1176 ( 9774)   else begin
1177 ( 9777)     if typ='q' then begin
1178 ( 9784)       code4($55,level-t1[idpnt],2*t2[idpnt]);
1179 ( 9819)     end else
1180 ( 9819)       code4($27+2*d+relad,level-t1[idpnt],
1181 ( 9845)         2*t2[idpnt]);
1182 ( 9867)     end
1183 ( 9867)   end {case}
1184 ( 9869) end;
1185 ( 9869) 
1186 ( 9870) { FORWARD decl. of mainexp (of statement) }
1187 ( 9870) 
1188 ( 9870) proc mainexp(reqtype: char;
1189 ( 9870)   var arsize: integer); forward;
1190 ( 9873) 
1191 ( 9873) { * express *           ( of statement ) }
1192 ( 9873) 
1193 ( 9873) proc express; {requests a normal 16-bit result }
1194 ( 9873) 
1195 ( 9873) var resultsize: integer;
1196 ( 9876) 
1197 ( 9876) begin {express}
1198 ( 9876)   mainexp('n',resultsize);
1199 ( 9894)   if resultsize<>0 then error(15)

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 21

1200 ( 9906) end {express};
1201 ( 9912) 
1202 ( 9913) { * arrayexp *          ( of mainexp) }
1203 ( 9913) 
1204 ( 9913) proc arrayexp(size: integer; eltype: char);
1205 ( 9913) 
1206 ( 9913) var resultsize: integer;
1207 ( 9916) 
1208 ( 9916) begin
1209 ( 9916)   mainexp(eltype,resultsize);
1210 ( 9936)   if resultsize<>size then error(15);
1211 ( 9956)   testtype(eltype);
1212 ( 9966) end;
1213 ( 9966) 
1214 ( 9967) { * getvar *            ( of statement ) }
1215 ( 9967) 
1216 ( 9967) proc getvar;
1217 ( 9967) begin
1218 ( 9967)   vartyp2:=high(t0[idpnt]);
1219 ( 9980)   vartype:=low(t0[idpnt]);
1220 ( 9993)   scan;
1221 (10002)   if (vartype='q') and (token=' [') and
1222 (10017)     ((vartyp2='v') or (vartyp2='d')) then begin
1223 (10034)     vartyp2:='q'; vartype:='c';
1224 (10045)   end;
1225 (10049)   case vartyp2 of
1226 (10049)   'a','x','s','i','n','q':
1227 (10092)       begin
1228 (10095)         if token=' [' then begin
1229 (10103)           scan; express; relad:=1;
1230 (10116)           if vartyp2='r' then begin
1231 (10127)             relad:=3;
1232 (10132)             code3($22,1); code1($12)
1233 (10148)           end;
1234 (10154)           if (vartyp2='q') and (t3[idpnt]=0) then
1235 (10172)             checkindex(0,63)
1236 (10180)           else
1237 (10186)             checkindex(0,t3[idpnt]);
1238 (10205)           testtype('i'); testto(' ]'); scan;
1239 (10226)         end else relad:=2;
1240 (10231)       end;
1241 (10235)   'v','w','r','h','m': relad:=0;
1242 (10275)   'c','d','e','t','u': error(6)
1243 (10319)   else error(1)
1244 (10330)   end {case}
1245 (10338) end {getvar};
1246 (10338) 
1247 (10339) { * prcall *            ( of statement ) }
1248 (10339) 
1249 (10339) proc prcall (idpn1: integer);
1250 (10339) 
1251 (10339) var bstack,numpar,i,n,n2: integer;
1252 (10342) 
1253 (10342) { body of prcall follows later }
1254 (10342) 
1255 (10342) { * prcall1 *           ( of prcall ) }
1256 (10342) 
1257 (10342) proc prcall1;
1258 (10342) var ressize:integer;
1259 (10345) 

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 22

1260 (10345)   proc prcall3;
1261 (10345)   begin {prcall3}
1262 (10348)     testto('id');
1263 (10359)     idpnt:=findid;
1264 (10365)     if idpnt=0 then error(5);
1265 (10387)     getvar;
1266 (10391)     if chr(stack[i] and 255)<>vartype then
1267 (10403)       if chr(stack[i] and 255)<>'u' then
1268 (10425)         merror(14,'01');
1269 (10440)       push(idpnt);
1270 (10450)   end {prcall3};
1271 (10450) 
1272 (10451) begin {prcall1}
1273 (10451)   case chr(stack[i] shr 8) of
1274 (10464)     'd':  begin
1275 (10472)             if chr(stack[i] and 255) = 'q' then
1276 (10486)               mainexp('q',ressize)
1277 (10492)             else
1278 (10506)               express;
1279 (10513)             if chr(stack[i] and 255)<>'u' then
1280 (10527)               testtype(chr(stack[i] and 255));
1281 (10549)           end;
1282 (10549)     'e':  begin
1283 (10559)             arrayexp(stack[succ(i)],
1284 (10564)               chr(stack[i]));
1285 (10583)             i:=succ(i);
1286 (10587)           end;
1287 (10592)     'w':  begin
1288 (10602)             prcall3;
1289 (10606)             if relad<>0 then merror(14,'02');
1290 (10627)             gpval(idpnt,false,vartyp2);
1291 (10643)           end;
1292 (10643)     'x':  begin
1293 (10653)             prcall3;
1294 (10657)             if relad<>2 then merror(14,'03');
1295 (10678)             if vartyp2='i' then error(16);
1296 (10696)             i:=succ(i);
1297 (10700)             if stack[i]<>t3[idpnt] then
1298 (10717)               error(15);
1299 (10733)             if vartyp2='n' then begin
1300 (10740)               code3($22,t2[idpnt]);
1301 (10759)               code1($3d);
1302 (10767)             end else code4($27,level-t1[idpnt],
1303 (10780)               2*t2[idpnt]);
1304 (10802)             code2($3b,stack[i]);
1305 (10818)           end
1306 (10818)     else merror(14,'04')
1307 (10826)   end {case}
1308 (10834) end {prcall1};
1309 (10834) 
1310 (10835) proc prcall2;
1311 (10835) begin
1312 (10835)   if n>0 then code3(35,-2*n);
1313 (10866)   n:=0
1314 (10866) end {prcall2};
1315 (10872) 
1316 (10873) begin {body of prcall}
1317 (10873)   if t3[idpn1]<>0 then begin
1318 (10886)     bstack:=t3[idpn1];
1319 (10893)     numpar:=stack[bstack];

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 23

1320 (10905)     parse(' ('); scan;
1321 (10926)     for i:=succ(bstack) to bstack+numpar do
1322 (10939)     begin
1323 (10953)       prcall1;
1324 (10957)       if i<bstack+numpar then begin
1325 (10971)         testto(' ,'); scan
1326 (10983)       end
1327 (10987)     end;
1328 (10987)     testto(' )');
1329 (11010)   end {then};
1330 (11010)   code4(43,level-t1[idpn1],t2[idpn1]);
1331 (11039)   if t3[idpn1]<>0 then begin
1332 (11050)     n:=0; i:=bstack+numpar;
1333 (11063)     repeat
1334 (11072)       case chr(stack[i] shr 8) of
1335 (11083)       'd':  n:=succ(n);
1336 (11095)       'w':  begin
1337 (11110)               prcall2; idpnt:=pop;
1338 (11120)               gpval(idpnt,true,
1339 (11130)                   high(t0[idpnt]));
1340 (11145)             end;
1341 (11145)       chr(0): begin
1342 (11155)             n2:=stack[i];
1343 (11159)             i:=i-1;
1344 (11173)             case chr(stack[i] shr 8) of
1345 (11189)               'e':  n:=succ(n+n2);
1346 (11206)               'x':  begin
1347 (11221)                       prcall2;
1348 (11225)                       idpnt:=pop;
1349 (11231)                       if high(t0[idpnt])='n'
1350 (11244)                       then begin
1351 (11247)                         code3($22,t2[idpnt]+
1352 (11256)                           2*t3[idpnt]);
1353 (11278)                         code1($3e)
1354 (11280)                       end else
1355 (11286)                         code4(41,
1356 (11291)                           level-t1[idpnt],
1357 (11299)                           2*(t2[idpnt]+
1358 (11310)                           t3[idpnt]));
1359 (11330)                       code2($3c,t3[idpnt])
1360 (11336)                     end
1361 (11346)               end {case}
1362 (11348)             end
1363 (11348)       end; {case}
1364 (11350)       i:=prec(i);
1365 (11354)     until i=bstack;
1366 (11363)     prcall2
1367 (11371)   end
1368 (11375) end {prcall};
1369 (11375) 
1370 (11376) 
1371 (11376) {###################################}
1372 (11376) { * mainexp *       ( of statement) }
1373 (11376) {###################################}
1374 (11376) {  see forward declaration above    }
1375 (11376) 
1376 (11376) proc mainexp(reqtype: char;
1377 (11376)   var arsize: integer);
1378 (11376) 
1379 (11376) { variables of mainexp}

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 24

1380 (11376) var opcode,roff: integer;
1381 (11379)     savtype: char;
1382 (11379) 
1383 (11379) { * argument *         ( of mainexp ) }
1384 (11379) 
1385 (11379) proc argument(rtype: char);
1386 (11379) begin
1387 (11379)   parse(' ('); scan; express;
1388 (11401)   testtype(rtype);
1389 (11411)   testto(' )'); scan
1390 (11420) end; {argument}
1391 (11425) 
1392 (11425) {#######################################}
1393 (11425) { * simexp *             ( of mainexp ) }
1394 (11425) {#######################################}
1395 (11425) 
1396 (11425) proc simexp(var arsize1: integer);
1397 (11425) 
1398 (11425) var opcode: integer;
1399 (11428)     sign: char;
1400 (11428) 
1401 (11428) {body of simexp  follows later }
1402 (11428) 
1403 (11428) {#######################################}
1404 (11428) { * term *               ( of simexp )  }
1405 (11428) {#######################################}
1406 (11428) 
1407 (11428) proc term(var arsize2: integer);
1408 (11428) 
1409 (11428) var opcode: integer;
1410 (11431) 
1411 (11431) { body of term follows later }
1412 (11431) 
1413 (11431) {#######################################}
1414 (11431) { * factor *             ( of term )    }
1415 (11431) {#######################################}
1416 (11431) 
1417 (11431) proc factor(var arsize3: integer);
1418 (11431) 
1419 (11431) var i, idpnt: integer;
1420 (11434)     h: char;
1421 (11434) 
1422 (11434) { * index *              ( of factor )  }
1423 (11434) 
1424 (11434) proc index(chk: boolean);
1425 (11434) 
1426 (11434) var savtype: char;
1427 (11437) 
1428 (11437) begin {index}
1429 (11437)   scan; savtype:=restype;
1430 (11443)   express; testtype('i'); testto(' ]');
1431 (11472)   if savtype='r' then begin
1432 (11479)     code3($22,1); code1($12);
1433 (11500)   end;
1434 (11500)   if chk then begin
1435 (11504)     if (savtype='q') and (t3[idpnt]=0) then
1436 (11525)       { is an arrayed cpnt }
1437 (11526)       checkindex(0,63)
1438 (11533)     else
1439 (11539)       checkindex(0,t3[idpnt]);

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 25

1440 (11558)   end;
1441 (11558)   restype:=savtype; scan
1442 (11566) end;
1443 (11570) 
1444 (11571) 
1445 (11571) begin { *** body of factor *** }
1446 (11571)   arsize3:=0;
1447 (11575)   case token of
1448 (11579)     'id': begin {identifier }
1449 (11591)             idpnt:=findid;
1450 (11597)             if idpnt=0 then error(5);
1451 (11619)             restype:=low(t0[idpnt]);
1452 (11627)             h:=high(t0[idpnt]);
1453 (11640)             case h of
1454 (11645)               'v','w','d':
1455 (11667)                     begin
1456 (11670)                       scan;
1457 (11674)                       if (restype='q') and (token=' [')
1458 (11688)                       then begin
1459 (11690)                         code4(39,level-t1[idpnt],
1460 (11703)                           2*t2[idpnt]);
1461 (11725)                         index(true);
1462 (11733)                         code1($03);
1463 (11741)                         code1($54);
1464 (11749)                         restype:='c';
1465 (11751)                       end else
1466 (11755)                         code4(39,level-t1[idpnt],
1467 (11768)                           2*t2[idpnt]);
1468 (11790)                     end;
1469 (11790)               'h':  begin code3($22,t2[idpnt]);
1470 (11816)                       code1($17); scan end;
1471 (11828)               'i':  begin code3($22,t2[idpnt]);
1472 (11854)                       scan;
1473 (11858)                       if token=' [' then begin
1474 (11866)                         index(true); code1($03);
1475 (11885)                         code1($17)
1476 (11887)                       end else begin
1477 (11896)                         error(16)
1478 (11898)                       end
1479 (11904)                     end;
1480 (11904)               'm':  begin code3($22,t2[idpnt]);
1481 (11930)                       code1($3d); scan
1482 (11938)                     end;
1483 (11942)               'n':  begin code3($22,t2[idpnt]);
1484 (11968)                       scan;
1485 (11972)                       if token=' [' then begin
1486 (11980)                         index(true);
1487 (11991)                         code3($22,1);code1($12);
1488 (12009)                         code1($03); code1($3d);
1489 (12025)                         if restype='r' then
1490 (12031)                         begin
1491 (12032)                           code2($3b,1);
1492 (12045)                           arsize3:=1
1493 (12045)                         end
1494 (12047)                       end else begin
1495 (12054)                         code1($3d);
1496 (12062)                         code2($3b,t3[idpnt]);
1497 (12078)                         arsize3:=t3[idpnt];
1498 (12082)                       end
1499 (12090)                     end;

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 26

1500 (12090)               'r','t': begin
1501 (12107)                       code3(35,2);
1502 (12117)                       idpnt:=prec(idpnt);
1503 (12121)                       prcall(idpnt); scan;
1504 (12140)                       restype:=low(t0[idpnt]);
1505 (12148)                     end;
1506 (12153)               'c':  if low(t0[idpnt])<>'r' then begin
1507 (12175)                       code3(34,t2[idpnt]);
1508 (12194)                       scan;
1509 (12198)                       if restype='s' then begin
1510 (12205)                         if token=' [' then begin
1511 (12216)                           index(true);
1512 (12227)                           code1($03);
1513 (12235)                           code1($58);
1514 (12243)                           code1($54);
1515 (12251)                           restype:='c';
1516 (12253)                         end else begin
1517 (12260)                           code1($58);
1518 (12268)                           restype:='q';
1519 (12270)                         end;
1520 (12274)                       end;
1521 (12274)                       {scan;}
1522 (12274)                     end else begin
1523 (12277)                       code2($3a,2);
1524 (12287)                       code2(t2[idpnt] and 255,
1525 (12297)                         t2[idpnt] shr 8);
1526 (12315)                       code2(t3[idpnt] and 255,
1527 (12325)                         t3[idpnt] shr 8);
1528 (12343)                       arsize3:=1; scan
1529 (12349)                     end;
1530 (12353)               'a','e','x':
1531 (12374)                     begin scan;
1532 (12381)                       if token=' [' then begin
1533 (12389)                         index(true);
1534 (12400)                         code4($28,
1535 (12402)                             level-t1[idpnt],
1536 (12410)                             2*t2[idpnt]);
1537 (12432)                         if restype='r' then
1538 (12438)                         begin
1539 (12439)                           code2($3b,1);
1540 (12452)                           arsize3:=1
1541 (12452)                         end
1542 (12454)                       end else begin
1543 (12461)                         code4($27,
1544 (12463)                             level-t1[idpnt],
1545 (12471)                             2*t2[idpnt]);
1546 (12493)                         code2($3b,t3[idpnt]);
1547 (12509)                         arsize3:=t3[idpnt];
1548 (12513)                       end
1549 (12521)                     end;
1550 (12521)               's','u':
1551 (12535)                     begin
1552 (12538)                       code3(35,2*t3[idpnt]+2);
1553 (12560)                       idpnt:=prec(idpnt);
1554 (12564)                       prcall(idpnt); scan;
1555 (12583)                       restype:=low(t0[idpnt]);
1556 (12591)                       idpnt:=succ(idpnt);
1557 (12600)                       arsize3:=t3[idpnt]
1558 (12605)                     end
1559 (12609)               else error(1)

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 27

1560 (12622)             end {case}
1561 (12630)           end; {identifier}
1562 (12633)     'nu': begin code3(34,value[0]); scan;
1563 (12659)             restype:='i'
1564 (12659)           end;
1565 (12665)     'ru': begin code2($3a,2);
1566 (12686)             code2(value[0] and 255,
1567 (12694)               value[0] shr 8);
1568 (12710)             code2(value[1] and 255,
1569 (12718)               value[1] shr 8);
1570 (12734)             scan; restype:='r';
1571 (12740)             arsize3:=1
1572 (12744)           end;
1573 (12750)     'st': begin
1574 (12761)           if (reqtype='n') and (value[0]<3)
1575 (12776)             then begin
1576 (12778)               if value[0]<2 then begin
1577 (12790)                 code3(34,ord(ident[1]));
1578 (12807)                 restype:='c'
1579 (12807)               end else begin
1580 (12816)                 code3(34,packed(ident[1],
1581 (12820)                   ident[2]));
1582 (12837)                 restype:='p'
1583 (12837)               end
1584 (12839)             end else begin
1585 (12846)               case reqtype of
1586 (12846)                 'c','u','n','q':
1587 (12875)                     begin
1588 (12878)                       if (vartype='q') or
1589 (12885)                          (reqtype='q') then begin
1590 (12893)                         arsize3:=0;
1591 (12898)                         restype:='q';
1592 (12904)                         code2($56,value[0]);
1593 (12922)                       end else begin
1594 (12925)                         arsize3:=prec(value[0]);
1595 (12931)                         restype:='c';
1596 (12938)                         code2($39,value[0]);
1597 (12956)                       end;
1598 (12956)                       for i:=1 to value[0] do
1599 (12964)                         code1(ord(ident[i]));
1600 (12991)                       if (vartype='q') or
1601 (13012)                          (reqtype='q') then code1(0);
1602 (13031)                     end;
1603 (13031)                 'p': begin
1604 (13041)                       if odd(value[0]) then
1605 (13047)                         error(15);
1606 (13059)                       value[0]:=value[0] shr 1;
1607 (13069)                       arsize3:=prec(value[0]);
1608 (13080)                       restype:='p';
1609 (13087)                       code2($3a,value[0]);
1610 (13105)                       for i:=1 to value[0] do
1611 (13113)                         begin
1612 (13126)                         code1(ident[2*i]);
1613 (13143)                         code1(ident[2*i-1]);
1614 (13163)                       end
1615 (13163)                     end
1616 (13163)                 else merror(14,'05')
1617 (13185)               end {case}
1618 (13193)             end;
1619 (13193)             scan

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 28

1620 (13193)           end;
1621 (13197)     'od': begin
1622 (13208)             argument('i'); code1(7);
1623 (13224)             restype:='b'
1624 (13224)           end;
1625 (13230)     'me': begin
1626 (13241)             parse(' ['); index(false);
1627 (13258)             code1(23); restype:='i';
1628 (13268)           end;
1629 (13272)     ' (': begin
1630 (13283)             scan; mainexp(reqtype,arsize3);
1631 (13305)             testto(' )'); scan
1632 (13314)           end; {no type change}
1633 (13321)     'no': begin
1634 (13329)             scan; factor(arsize3);
1635 (13345)             if (arsize3<>0) then error(15);
1636 (13363)             code1($11);
1637 (13371)             if restype<>'i' then
1638 (13377)               testtype('b')
1639 (13383)           end;
1640 (13389)     'cr': begin
1641 (13400)             argument('i'); code1(52);
1642 (13416)             restype:='c'
1643 (13416)           end;
1644 (13422)     'hi': begin
1645 (13433)             argument('p'); code1(51);
1646 (13449)             restype:='c'
1647 (13449)           end;
1648 (13455)     'lo': begin
1649 (13466)             argument('p'); code1(52);
1650 (13482)             restype:='c'
1651 (13482)           end;
1652 (13488)     'su': begin
1653 (13499)             argument('u'); code1($14);
1654 (13515)           end;
1655 (13515)     'pc': begin
1656 (13526)             argument('u'); code1($15)
1657 (13536)           end;
1658 (13542)     'cp': begin
1659 (13553)             argument('i'); restype:='q';
1660 (13563)           end;
1661 (13567)     'ni': begin
1662 (13578)             code3(34,0); scan; restype:='q';
1663 (13594)           end;
1664 (13598)     'ox': begin
1665 (13609)             argument('u');
1666 (13617)             restype:='i'
1667 (13617)           end;
1668 (13623)     ' @': begin
1669 (13634)             scan; factor(arsize3);
1670 (13650)             if arsize3<>0 then error(15);
1671 (13668)             if restype<>'q' then testtype('i');
1672 (13686)             restype:='f'
1673 (13686)           end;
1674 (13692)     'tr': begin
1675 (13703)             code3(34,1); scan;
1676 (13717)             restype:='b';
1677 (13719)           end;
1678 (13723)     'fa': begin
1679 (13734)             code3(34,0); scan;

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 29

1680 (13748)             restype:='b'
1681 (13748)           end;
1682 (13754)     'tc': begin
1683 (13765)             parse(' ('); scan;
1684 (13778)             arrayexp(1,'r');
1685 (13788)             testto(' )'); scan;
1686 (13801)             code1($47); restype:='i';
1687 (13811)           end;
1688 (13815)     'cv': begin
1689 (13826)             argument('i');
1690 (13834)             code1($46); arsize3:=1;
1691 (13844)             restype:='r'
1692 (13848)           end;
1693 (13854)     'pa': begin
1694 (13865)             parse(' ('); scan; express;
1695 (13882)             testtype('c');
1696 (13890)             if token=' ,' then begin
1697 (13898)               scan; express; testtype('c');
1698 (13917)               code1(53)
1699 (13919)             end;
1700 (13925)             testto(' )'); scan; restype:='p'
1701 (13938)           end
1702 (13940)     else error(1)
1703 (13949)   end {case of token}
1704 (13957) end {factor};
1705 (13957) 
1706 (13958) begin  { *** body of term *** }
1707 (13958)   factor(arsize2);
1708 (13972)   repeat
1709 (13972)     case token of
1710 (13972)       ' *': opcode:=5;
1711 (13986)       'di': opcode:=6;
1712 (14003)       'an': opcode:=15;
1713 (14020)       'sh': opcode:=18;
1714 (14037)       'sr': opcode:=19;
1715 (14054)       ' /': opcode:=$45
1716 (14069)       else opcode:=0
1717 (14078)     end {case};
1718 (14086)     if opcode>0 then begin
1719 (14093)       if (restype='r') and
1720 (14103)             (arsize2=1) then begin
1721 (14111)         scan; factor(arsize2);
1722 (14130)         if (restype<>'r') or (arsize2<>1) then
1723 (14144)           merror(14,'06');
1724 (14159)         case opcode of
1725 (14159)           5: code1($44);
1726 (14178)           $45: code1($45)
1727 (14190)           else error(17)
1728 (14201)         end{case}
1729 (14209)       end else begin
1730 (14212)         if opcode=$45 then error(9);
1731 (14230)         if arsize2<>0 then error(15);
1732 (14248)         if (restype='b') and (opcode=15)
1733 (14261)           then begin
1734 (14263)           scan; factor(arsize2);
1735 (14282)           if arsize2<>0 then error(15);
1736 (14300)           testtype('b');
1737 (14308)           code1(opcode)
1738 (14308)         end else begin
1739 (14321)           testtype('i'); scan;

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 30

1740 (14333)           factor(arsize2);
1741 (14345)           if arsize2<>0 then error(15);
1742 (14363)           testtype('i'); code1(opcode);
1743 (14381)         end
1744 (14381)       end
1745 (14381)     end;
1746 (14381)   until opcode=0;
1747 (14387) end {term};
1748 (14391) 
1749 (14392) 
1750 (14392) begin { *** body of simexp *** }
1751 (14392)   sign:=' ';
1752 (14396)   if token=' +' then begin
1753 (14408)     sign:='+'; scan
1754 (14417)   end else if token=' -' then begin
1755 (14432)     sign:='-'; scan
1756 (14441)   end;
1757 (14445)   term(arsize1);
1758 (14457)   if sign<>' ' then begin
1759 (14464)     if (restype='r')and (arsize1=1) then begin
1760 (14482)       if sign='-' then code1($4e)
1761 (14497)     end else begin
1762 (14506)       testtype('i');
1763 (14514)       if arsize1<>0 then error(15);
1764 (14532)       if sign='-' then code1(2);
1765 (14550)     end
1766 (14550)   end;
1767 (14550)   repeat
1768 (14550)     case token of
1769 (14550)       ' &': opcode:=1;
1770 (14564)       ' +': opcode:=3;
1771 (14581)       ' -': opcode:=4;
1772 (14598)       'or': opcode:=14;
1773 (14615)       'xo': opcode:=16
1774 (14630)       else opcode:=0
1775 (14639)     end {case};
1776 (14647)     if opcode>1 then begin {if 1}
1777 (14657)       if (restype='r') and (arsize1=1)
1778 (14670)         then begin {real}
1779 (14675)         scan; term(arsize1);
1780 (14691)         if (restype<>'r') or (arsize1<>1) then
1781 (14705)           error(17);
1782 (14717)         case opcode of
1783 (14717)           3:  code1($42);
1784 (14736)           4:  code1($43)
1785 (14748)           else error(17)
1786 (14759)         end {case}
1787 (14767)       end {real}
1788 (14767)       else begin {not real}
1789 (14770)         if (arsize1<>0) then error(15);
1790 (14788)         if (restype='b') and (opcode>=14)
1791 (14801)           then begin {boolean}
1792 (14806)           scan; term(arsize1);
1793 (14822)           if arsize1<>0 then error(15);
1794 (14840)           testtype('b'); code1(opcode)
1795 (14848)         end {boolean}
1796 (14858)         else begin {not boolean}
1797 (14861)           testtype('i'); scan;
1798 (14873)           term(arsize1);
1799 (14885)           if arsize1<>0 then error(15);

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 31

1800 (14903)           testtype('i'); code1(opcode);
1801 (14921)         end {not boolean}
1802 (14921)       end {not real}
1803 (14921)     end {if 1}
1804 (14921)     else if opcode=1 then begin {else 1}
1805 (14934)       sign:=restype;
1806 (14934)       scan; term(opcode);
1807 (14958)       arsize1:=arsize1+opcode+1;
1808 (14969)       testtype(sign)
1809 (14974)     end {else 1}
1810 (14984)   until opcode=0
1811 (14988) end {simexp};
1812 (14994) 
1813 (14995) 
1814 (14995) begin { *** body of mainexp *** }
1815 (14995)   roff:=0;
1816 (14999)   simexp(arsize);
1817 (15015)   if (restype='r') and (arsize=1) then
1818 (15029)     roff:=$40;
1819 (15035)   case token of
1820 (15039)     ' =': opcode:=8;
1821 (15053)     ' <': opcode:=10;
1822 (15070)     ' >': opcode:=12;
1823 (15087)     '<>': opcode:=9;
1824 (15104)     '<=': opcode:=13;
1825 (15121)     '>=': opcode:=11
1826 (15136)     else opcode:=0
1827 (15145)   end {case};
1828 (15153)   if opcode>0 then begin
1829 (15160)     if (arsize<>0) and (roff=0) then
1830 (15177)       error(15);
1831 (15189)     scan; savtype:=restype; simexp(arsize);
1832 (15213)     if ((roff=0) and (arsize<>0))
1833 (15227)       or((roff<>0) and (arsize>1)) then
1834 (15243)       error(15);
1835 (15255)     testtype(savtype); code1(opcode+roff);
1836 (15280)     arsize:=0; restype:='b'
1837 (15286)   end
1838 (15288) end {mainexp};
1839 (15292) 
1840 (15293) 
1841 (15293) {#########################################}
1842 (15293) { * assign *             ( of statement ) }
1843 (15293) {#########################################}
1844 (15293) 
1845 (15293) proc assign;
1846 (15293) 
1847 (15293) var savetype: char;
1848 (15296) 
1849 (15296)   proc assign1;
1850 (15296)   begin
1851 (15296)     testto(':='); scan; express;
1852 (15318)     if (vartype='q') and (restype='s') then begin
1853 (15333)       code1($58); restype:='q';
1854 (15346)     end;
1855 (15350)     gpval(idpnt,true,vartyp2);
1856 (15366)   end {assign1};
1857 (15366) 
1858 (15367) begin {assign}
1859 (15367)   idpnt:=findid;

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 32

1860 (15375)   if idpnt=0 then error(5);
1861 (15397)   if t0[idpnt]='pr' then begin
1862 (15409)     prcall(idpnt);scan end
1863 (15426)   else begin
1864 (15429)     getvar; savetype:=vartype;
1865 (15433)     if relad<2 then begin
1866 (15448)       assign1; testtype(vartype)
1867 (15455)     end else begin
1868 (15468)       if vartyp2='i' then error(16); {8-bit mem}
1869 (15486)       testto(':='); scan;
1870 (15499)       if relad=3 then begin
1871 (15506)         arrayexp(1,vartype); relad:=1;
1872 (15523)         code1($53);
1873 (15535)         if vartyp2='n' then begin
1874 (15542)           code1($3f);
1875 (15553)           code3($22,1);code1($12);
1876 (15571)           code3($22,t2[idpnt]+2);
1877 (15590)           code1($3);code1($3e)
1878 (15600)         end else
1879 (15606)           code4($2a,level-t1[idpnt],
1880 (15619)             2*t2[idpnt]+2);
1881 (15644)         code2($3c,1)
1882 (15648)       end else begin
1883 (15657)         arrayexp(t3[idpnt],vartype);
1884 (15675)         if vartyp2='n' then begin
1885 (15682)           code3($22,t2[idpnt]+2*t3[idpnt]);
1886 (15713)           code1($3e);
1887 (15721)         end else
1888 (15721)           code4($29,level-t1[idpnt],
1889 (15734)             2*(t2[idpnt]+t3[idpnt]));
1890 (15765)         code2($3c,t3[idpnt]);
1891 (15781)       end
1892 (15781)     end
1893 (15781)   end
1894 (15781) end {assign};
1895 (15781) 
1896 (15782) { * case1 *             ( of statement ) }
1897 (15782) 
1898 (15782) proc case1;
1899 (15782) 
1900 (15782) var i1,i2,casave: integer;
1901 (15785)     savetype: char;
1902 (15785) 
1903 (15785)   proc case2;
1904 (15785) 
1905 (15785)     proc case3;
1906 (15788)     begin
1907 (15788)       scan; code1(22); code3(34,getcon);
1908 (15819)       testtype(savetype);
1909 (15829)       code1(8); scan
1910 (15837)     end;
1911 (15841) 
1912 (15842)   begin {case2}
1913 (15842)     i1:=0; case3;
1914 (15854)     while token=' ,' do begin
1915 (15865)       push(pc); code3(38,0); i1:=succ(i1);
1916 (15889)       case3
1917 (15894)     end;
1918 (15898)     testto(' :'); savpc:=pc; code3(37,0);
1919 (15928)     for k2:=1 to i1 do fixup(pop);

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 33

1920 (15959)     push(savpc);
1921 (15983)     scan; statmnt
1922 (15987)   end {case2};
1923 (15991) 
1924 (15992) begin {case1}
1925 (15992)   scan; express; testto('of');
1926 (16011)   savetype:=restype; i2:=1; case2;
1927 (16029)   while token=' ;' do begin
1928 (16040)     casave:=pc; code3(36,0); fixup(pop);
1929 (16070)     push(casave); i2:=succ(i2); case2
1930 (16089)   end;
1931 (16093)   if token='el' then begin
1932 (16104)     casave:=pc; code3(36,0); fixup(pop);
1933 (16137)     push(casave); scan; statmnt
1934 (16151)   end;
1935 (16155)   testto('en'); for k2:=1 to i2 do fixup(pop);
1936 (16195)   code3(35,-2); scan
1937 (16220) end {case1};
1938 (16224) 
1939 (16225) { * openrw *              ( of statement ) }
1940 (16225) 
1941 (16225) proc openrw(x: integer);
1942 (16225) begin
1943 (16225)   parse(' ('); parse('id');
1944 (16248)   idpnt:=findid;
1945 (16254)   if idpnt=0 then error(5);
1946 (16276)   getvar; code1(x);
1947 (16290)   testferror;
1948 (16294)   if relad=2 then error(15);
1949 (16312)   if vartype<>'f' then merror(14,'07');
1950 (16333)   gpval(idpnt,true,vartyp2);
1951 (16349)   testto(' )'); scan
1952 (16358) end {openrw};
1953 (16362) 
1954 (16363) { * gpsec *               ( of statement )  }
1955 (16363) 
1956 (16363) proc gpsec(code);   { get/put sector }
1957 (16363) 
1958 (16363)   proc gpsec1;
1959 (16366)   begin
1960 (16366)     scan; express; testtype('i');
1961 (16387)     testto(' ,');
1962 (16396)   end;
1963 (16396) 
1964 (16397) begin {gpsec}
1965 (16397)   parse(' ('); gpsec1; gpsec1; gpsec1;
1966 (16420)   code1(code);
1967 (16430)   parse('id'); idpnt:=findid;
1968 (16445)   if idpnt=0 then error(5);
1969 (16467)   getvar; code3(34,$db); { get file error code }
1970 (16481)   if relad=2 then error(15);
1971 (16499)   code1(23); if vartype<>'i' then merror(14,'08');
1972 (16528)   gpval(idpnt,true,vartyp2);
1973 (16544)   testto(' )');
1974 (16553) end {gpsec};
1975 (16553) 
1976 (16554) 
1977 (16554) begin {body of statement }
1978 (16554)   if token=' ;' then scan;
1979 (16571)   case token of

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 34

1980 (16571)     'id': assign;
1981 (16587) 
1982 (16590)     'if': begin {if}
1983 (16598)             scan; express; testtype('b');
1984 (16614)             testto('th'); scan;  savpc:=pc;
1985 (16627)             code3(37,0); statmnt;
1986 (16649)             if token='el' then begin {else}
1987 (16660)               k2:=pc; code3(36,0);
1988 (16678)               fixup(savpc); scan; statmnt;
1989 (16696)               fixup(k2)
1990 (16696)             end else fixup(savpc)
1991 (16709)           end; {if}
1992 (16722) 
1993 (16722)     'be':  begin {begin}
1994 (16730)             repeat
1995 (16730)               scan; statmnt
1996 (16734)             until token<>(' ;');
1997 (16745)             testto('en'); scan
1998 (16758)           end; {begin}
1999 (16765) 
2000 (16765)     'rp': begin {repeat}
2001 (16773)             savpc:=pc;
2002 (16773)             repeat
2003 (16781)               scan; statmnt
2004 (16785)             until token='un';
2005 (16796)             scan; express; testtype('b');
2006 (16816)             code3(37,savpc)
2007 (16818)           end {repeat};
2008 (16828) 
2009 (16831)     're': begin {read}
2010 (16839)             parse(' ('); scan;
2011 (16852)             if token=' @' then begin
2012 (16860)               scan; express; testtype('f');
2013 (16879)               device:=true;
2014 (16881)               code1(44); testto(' ,')
2015 (16896)             end
2016 (16902)             else begin
2017 (16905)               device:=false; code1(26)
2018 (16913)             end;
2019 (16919)             repeat
2020 (16919)               begin {main loop of read}
2021 (16919)                 if token=' ,' then scan;
2022 (16934)                 testto('id'); idpnt:=findid;
2023 (16949)                 if idpnt=0 then error(5);
2024 (16971)                 getvar;
2025 (16975)                 if relad=2 then error(15);
2026 (16993)                 case vartype of
2027 (16993)                   'i':  code1(28);
2028 (17012)                   'c':  code1(27);
2029 (17030)                   'p':  begin
2030 (17040)                         code1(27); code1(27);
2031 (17056)                         code1(53)
2032 (17058)                         end
2033 (17064)                   else error(114)
2034 (17069)                 end {case};
2035 (17077)                 gpval(idpnt,true,vartyp2)
2036 (17083)               end {mainloop of read}
2037 (17093)             until token<>' ,';
2038 (17100)             testto(' )'); scan;
2039 (17117)             if device then code1(45);

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 35

2040 (17132)           end {read};
2041 (17132) 
2042 (17135)     'wr','wl':
2043 (17148)           begin {write,writeln}
2044 (17151)             if token='wl' then wln:=true
2045 (17162)             else wln:=false;
2046 (17173)             scan;
2047 (17181)             if token=' (' then begin
2048 (17189)               scan;
2049 (17196)               if token=' @' then begin
2050 (17204)                 scan; express;
2051 (17215)                 if restype='q' then restype:='f';
2052 (17227)                 testtype('f');
2053 (17239)                 device:=true; code1(44);
2054 (17253)                 testto(' ,');
2055 (17262)               end else device:=false;
2056 (17267)               repeat
2057 (17271)                 if token=' ,' then scan;
2058 (17286)                 if (token=' )') and device
2059 (17294)                        and wln then
2060 (17299)                    {empty writeln except device}
2061 (17304)                    k2:=k2 {do nothing}
2062 (17307)                 else if token='st' then begin
2063 (17326)                   {string}
2064 (17329)                   code1(50);
2065 (17337)                   for k2:=1 to value[0]-1 do
2066 (17351)                     code1(ord(ident[k2])
2067 (17365)                         and 127);
2068 (17378)                   code1(ord(ident[value[0]])
2069 (17398)                       or 128);
2070 (17411)                   scan
2071 (17411)                 end else begin
2072 (17418)                   {expression}
2073 (17418)                   express;
2074 (17422)                   case restype of
2075 (17422)                     'i':  code1(30);
2076 (17441)                     'c':  code1(29);
2077 (17459)                     'q':  code1($57);
2078 (17477)                     's':  begin
2079 (17487)                             code1($58);
2080 (17495)                             code1($57);
2081 (17503)                           end;
2082 (17503)                     'p':  begin
2083 (17513)                             code1(22);
2084 (17521)                             code1(51);
2085 (17529)                             code1(29);
2086 (17537)                             code1(52);
2087 (17545)                             code1(29);
2088 (17553)                           end
2089 (17553)                     else merror(14,'09')
2090 (17561)                   end {case}
2091 (17569)                 end {expression}
2092 (17569)               until token<>' ,';
2093 (17576)               if wln then begin {writeln(..)}
2094 (17587)                 code2(32,13); code1(29);
2095 (17605)                 code2(32,10); code1(29);
2096 (17623)               end;
2097 (17623)               if device then code1(45);
2098 (17638)               testto(' )'); scan
2099 (17647)             end {if}

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 36

2100 (17651)             else if wln then begin {writeln}
2101 (17661)               code2(32,13); code1(29);
2102 (17679)               code2(32,10); code1(29);
2103 (17697)             end
2104 (17697)           end {write, writeln};
2105 (17697) 
2106 (17700)     'cs': case1; {case statement}
2107 (17715) 
2108 (17715)     'wh': begin {while}
2109 (17723)             scan; savpc:=pc; express;
2110 (17739)             testtype('b');
2111 (17747)             k2:=pc; code3(37,0);
2112 (17765)             testto('do'); scan; statmnt;
2113 (17782)             code3(36,savpc); fixup(k2)
2114 (17794)           end {while};
2115 (17804) 
2116 (17807)     'fo': begin {for}
2117 (17815)             parse('id'); assign;
2118 (17828)             if t0[idpnt]='pr' then error(1);
2119 (17851)             savtp1:=low(t0[idpnt]);
2120 (17859)             case token of
2121 (17864)               'to': k2:=1;
2122 (17878)               'dw': k2:=0
2123 (17893)               else merror(2,'to')
2124 (17907)             end {case of token};
2125 (17915)             scan; express; testtype(savtp1);
2126 (17933)             bottom1:=pc; code1(22);
2127 (17949)             gpval(idpnt,false,vartyp2);
2128 (17965)             code1(13-k2-k2);
2129 (17983)             savpc:=pc; code3(37,0);
2130 (18001)             testto('do'); scan; statmnt;
2131 (18018)             gpval(idpnt,false,vartyp2);
2132 (18034)             code1(21-k2);
2133 (18047)             gpval(idpnt,true,vartyp2);
2134 (18063)             code3(36,bottom1); fixup(savpc);
2135 (18085)             code3(35,-2);
2136 (18096)           end {for};
2137 (18096) 
2138 (18099)     'me': begin {mem}
2139 (18107)             parse(' ['); scan; express;
2140 (18124)             testtype('i');
2141 (18132)             testto(' ]'); parse(':=');
2142 (18150)             scan; express; code1(24);
2143 (18166)             testtype('i');
2144 (18174)           end {mem};
2145 (18174) 
2146 (18177)     'ca': begin {call}
2147 (18185)             parse(' ('); scan; express;
2148 (18202)             testtype('i');
2149 (18210)             testto(' )'); code1(25); scan
2150 (18227)           end {call};
2151 (18231) 
2152 (18234)     'op': openrw(47);
2153 (18250) 
2154 (18253)     'ow': openrw(48);
2155 (18269) 
2156 (18272)     'ob': openrw(80);
2157 (18288) 
2158 (18291)     'gb': begin
2159 (18299)             parse(' ('); scan; express;

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 37

2160 (18316)             testtype('f'); testto(' ,');
2161 (18333)             scan; express; testtype('i');
2162 (18349)             testto(' ,'); scan; testto('id');
2163 (18371)             idpnt:=findid;
2164 (18377)             if idpnt=0 then error(5);
2165 (18399)             getvar;
2166 (18403)             if relad<>0 then error(15);
2167 (18421)             code1($51); testferror;
2168 (18433)             gpval(idpnt,true,vartyp2);
2169 (18449)             testto(' )'); scan
2170 (18458)           end;
2171 (18462) 
2172 (18465)     'pb': begin
2173 (18473)             parse(' ('); scan; express;
2174 (18490)             testtype('f'); testto(' ,');
2175 (18507)             scan; express; testtype('i');
2176 (18523)             testto(' ,'); scan; express;
2177 (18540)             code1($52);testferror;
2178 (18552)             testto(' )');
2179 (18561)             scan
2180 (18561)           end;
2181 (18565) 
2182 (18568)     'ru': begin
2183 (18576)             code1($41); scan;
2184 (18588)           end;
2185 (18588) 
2186 (18591)     'fi': begin
2187 (18599)             code1(46); scan
2188 (18607)           end;
2189 (18611) 
2190 (18614)     'ge': gpsec(55);
2191 (18630) 
2192 (18633)     'pu': gpsec(56);
2193 (18649) 
2194 (18652)     'ex': begin {exit}
2195 (18660)             if level>0 then code1(1) else code1(0);
2196 (18689)             scan;
2197 (18693)           end;
2198 (18693) 
2199 (18696)     'cl': begin {close}
2200 (18704)             parse(' (');
2201 (18713)             repeat
2202 (18713)               scan; express; code1(49);
2203 (18729)               testtype('f');
2204 (18737)               testferror
2205 (18737)             until token<>' ,';
2206 (18748)             testto(' )'); scan;
2207 (18765)           end {close}
2208 (18765) 
2209 (18765)     else if (token<>'en') and (token<>' ;')
2210 (18783)       and (token<>'un') then begin
2211 (18794)       error(10); scan
2212 (18805)     end
2213 (18809)   end {case of statements}
2214 (18811) end;
2215 (18811) 
2216 (18812) { * findforw *          ( of block ) }
2217 (18812) 
2218 (18812) func findforw;
2219 (18812) 

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 38

2220 (18812) var i,j,sav1: integer;
2221 (18815) 
2222 (18815)   func found(start: integer):boolean;
2223 (18815)   var ii,i9: integer;
2224 (18818)   begin {compare}
2225 (18818)     ii:= 0;
2226 (18822)     repeat
2227 (18826)       ii:=succ(ii);
2228 (18830)     until (ii >= 8) or
2229 (18842)       (ident[ii] <> idtab[start+ii]);
2230 (18865)     found:=(ii >= 8);
2231 (18876)   end {compare};
2232 (18880) 
2233 (18881) 
2234 (18881) begin {findforw}
2235 (18881)   i:=succ(forwpn);
2236 (18887)   repeat
2237 (18892)     i:=prec(i)
2238 (18892)   until (i=0) or found(8*fortab[i]);
2239 (18927)   findforw:=i;
2240 (18931)   if i>0 then
2241 (18945)     if i=forwpn then forwpn:=forwpn-1
2242 (18965)     else begin
2243 (18975)       sav1:=fortab[i];
2244 (18979)       for j:=1 to forwpn-1 do
2245 (18999)       fortab[j]:=fortab[succ(j)];
2246 (19018)       fortab[forwpn]:=sav1;
2247 (19044)       findforw:=forwpn;
2248 (19052)       forwpn:=forwpn-1
2249 (19064)     end
2250 (19066) end {findforw};
2251 (19071) 
2252 (19072) 
2253 (19072) begin { *** body of block *** }
2254 (19072)   dpnt:=3; t2[bottom]:=pc;
2255 (19084)   code3(36,0);
2256 (19102)   stackpn1:=stackpnt; forwpn:=0;
2257 (19112) 
2258 (19116)   if token='co' then begin    { * const * }
2259 (19127)     scan;
2260 (19131)     repeat
2261 (19131)       deccon; testto(' ;'); scan
2262 (19144)     until token <> 'id';
2263 (19155)   end {const};
2264 (19159) 
2265 (19159)   if token='me' then memory;  { * mem * }
2266 (19174) 
2267 (19174)   if token='va' then variable;{ * var * }
2268 (19189) 
2269 (19189)   while (token='pr')or (token='fu') do begin
2270 (19209)     parlevel:=0;
2271 (19211)     case token of
2272 (19215)     'pr': begin               { * proc * }
2273 (19227)             parse('id'); npara:=0;
2274 (19238)             putsym('p','r'); cproc:=spnt;
2275 (19252)             level:=succ(level);
2276 (19264)           end;
2277 (19269)     'fu': begin               { * func * }
2278 (19280)             parse('id'); npara:=1;
2279 (19291)             putsym('f','i');

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 39

2280 (19305)             cproc:=spnt; level:=succ(level);
2281 (19317)             putsym('f','i');
2282 (19332)             t2[spnt]:=parlevel;
2283 (19336)             parlevel:=succ(parlevel);
2284 (19348)           end
2285 (19353)     end; {case of token}
2286 (19355)     if forwpn=0 then find:=0
2287 (19365)     else find:=findforw;
2288 (19380)     if find<>0 then begin
2289 (19391)       spnt:=spnt-npara-1;
2290 (19405)       cproc:=fortab[find];
2291 (19414)       fixup(t2[cproc]);
2292 (19436)     end;
2293 (19436)     scan; spnt1:=spnt;
2294 (19440)     dpnt1:=dpnt;
2295 (19448)     if token=' (' then parameter;
2296 (19471)     if t0[cproc]='fi' then function;
2297 (19490)     testto(' ;');
2298 (19499)     for i:=1 to npara do
2299 (19505)     t2[succ(spnt-i)]:=t2[succ(spnt-i)]
2300 (19537)           -parlevel;
2301 (19542)     scan;
2302 (19569)     if token='fw' then begin
2303 (19577)       if forwpn=8 then merror(13,'ov');
2304 (19601)       forwpn:=succ(forwpn);
2305 (19605)       fortab[forwpn]:=cproc;
2306 (19614)       t2[cproc]:=pc;
2307 (19626)       code3(36,0);
2308 (19644)       scan
2309 (19644)     end else block(cproc);
2310 (19661)     level:=prec(level);
2311 (19665)     dpnt:=dpnt1; spnt:=spnt1;
2312 (19678)     case high(t0[spnt]) of
2313 (19694)       'r':  t0[spnt]:=packed('t',low(t0[spnt]));
2314 (19718)       's':  t0[spnt]:=packed('u',low(t0[spnt]))
2315 (19746)     end {case};
2316 (19754)     testto(' ;'); scan
2317 (19763)   end {procedure of function};
2318 (19767) 
2319 (19770)   testto('be');     { * begin * }
2320 (19779)   if forwpn<>0 then merror(13,'ur');
2321 (19800)   fixup(t2[bottom]);
2322 (19814)   t2[bottom]:=pc;
2323 (19818)   scan;
2324 (19830)   code3(35,2*dpnt);
2325 (19845)   repeat
2326 (19845)     statmnt
2327 (19845)   until token='en';
2328 (19856)   scan;
2329 (19864)   if level>0 then code1(1) else code1(0);
2330 (19893)   stackpnt:=stackpn1;
2331 (19893) end {block};
2332 (19901) 
2333 (19902) { * savtable *    ( global) }
2334 (19902) 
2335 (19902) proc savtable; { save lib table in @ofno }
2336 (19902) 
2337 (19902) var i,j,num: integer;
2338 (19905)     vtype1: char;
2339 (19905) 

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 40

2340 (19905) begin
2341 (19905)   writeln(@ofno,spnt,',',pc+2);
2342 (19934)   for i:=1 to spnt do begin {for every entry }
2343 (19953)     for j:=1 to 8 do begin
2344 (19970)       write(@ofno,idtab[8*i+j])
2345 (19990)     end;
2346 (19994)     writeln(@ofno,',',t0[i],',',t1[i],',',
2347 (20041)       t2[i],',',t3[i]);
2348 (20068)     vtype1:=high(t0[i]);
2349 (20076)     if ((vtype1='p') or (vtype1='f') or
2350 (20095)       (vtype1='g')) and (t3[i]<>0) then begin
2351 (20116)       num:=stack[t3[i]];
2352 (20127)       write(@ofno,num);
2353 (20146)       for j:=1 to num do
2354 (20152)         write(@ofno,',',stack[t3[i]+j]);
2355 (20191)       write(@ofno,cr,lf);
2356 (20217)     end {then};
2357 (20217)   end {for}
2358 (20217) end {savtable};
2359 (20231) 
2360 (20232) { * main program * }
2361 (20232) 
2362 (20232) begin {main}
2363 (20232)   nlflg:=false;
2364 (20237)   init;scan;
2365 (20249)   case token of
2366 (20249)     'pg': begin
2367 (20261)             libflg:=false;
2368 (20263)             asetfile(pname,scyclus,sdrive,'Q');
2369 (20289)           end;
2370 (20289)     'li': begin
2371 (20300)             libflg:=true;
2372 (20302)             asetfile(pname,scyclus,sdrive,'T');
2373 (20328)           end
2374 (20328)     else
2375 (20328)       merror(2,'pg')
2376 (20336)   end {case}
2377 (20344)   parse('id');
2378 (20353)   i:=0;
2379 (20355)   repeat
2380 (20359)     i:=succ(i);
2381 (20363)   until (i>7) or (pname[i] = ':') or
2382 (20386)       (pname[i]<>uppercase(ident[i+1]));
2383 (20415)   if i<8 then
2384 (20425)     merror(2,packed(pname[0],pname[1]));
2385 (20450)     { name differs from filename }
2386 (20450)   parse(' ;');
2387 (20459)   if ofno<>nooutput then openw(ofno);
2388 (20475)   scan;
2389 (20479)   if (token='us') and (libflg=false) then begin
2390 (20495)     repeat
2391 (20498)       getlib; scan
2392 (20502)     until token<>' ,';
2393 (20513)     testto(' ;'); scan
2394 (20526)   end;
2395 (20530)   block(0); testto(' .');
2396 (20547)   if ofno<>nooutput then begin
2397 (20554)     write(@ofno,'E');
2398 (20565)     savebyte(pc and 255);
2399 (20578)     savebyte(pc shr 8);

----------------------------------------------------------------------

R65 COMPILE 4.2: program COMPILE1         10/2/24 page 41

2400 (20591)     close(ofno);
2401 (20597)     if libflg then begin
2402 (20601)       asetfile(pname,scyclus,sdrive,'L');
2403 (20626)       openw(ofno);
2404 (20632)       savtable;
2405 (20636)       close(ofno)
2406 (20636)     end
2407 (20642)   end else
2408 (20642)     runerr:=$87; {no loader file}
2409 (20651)   writeln;
2410 (20651)   writeln;
2411 (20657)   writeln('End compile');
2412 (20681)   writeln;
2413 (20681)   writeln('Code lenght:          ',pc);
2414 (20721)   writeln('Compiler stack size:  ',stackmax);
2415 (20755)   writeln('Ident stack size:     ',spntmax);
2416 (20789)   write('Pascal errors:        ');
2417 (20812)   if numerr>0 then write(invvid);
2418 (20825)   writeln(numerr,norvid);
2419 (20839)   if prt then begin
2420 (20843)     write(prtoff);
2421 (20849)     setemucom(9);
2422 (20857)   end;
2423 (20857)   close(fno);
2424 (20863)   { check whether second pass is not required }
2425 (20863)   if (runerr=0) and libflg then runerr:=-1;
2426 (20879) end {main}.
2427 (20884) 

End compile

Code lenght:          20883
Compiler stack size:  136
Ident stack size:     214
Pascal errors:        0
