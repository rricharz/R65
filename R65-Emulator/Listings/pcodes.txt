
R65 COMPILE 4.2: program PCODES           7/12/23 page 1


   1 (    4) program pcodes;
   2 (    4) uses syslib,arglib,strlib,ralib,mathlib;
   3 ( 6351) 
   4 ( 6351) const npcodes=$59;
   5 ( 6354) 
   6 ( 6354) var codename: array[npcodes] of cpnt;
   7 ( 6354)     codebytes: array[npcodes] of integer;
   8 ( 6354)     fcode,scode: file;
   9 ( 6354)     cdsize,i,code,line,first,last: integer;
  10 ( 6354)     name: array[15] of char;
  11 ( 6354)     cyclus,drive:integer;
  12 ( 6354)     default,silent: boolean;
  13 ( 6354)     linestr:cpnt;
  14 ( 6354) 
  15 ( 6354) func readline(f: file; pnt: cpnt): boolean;
  16 ( 6354) {#########################################}
  17 ( 6354) const alteof=chr(127);
  18 ( 6357) var ch1: char;
  19 ( 6357)     pos: integer;
  20 ( 6357) begin
  21 ( 6357)   pos := 0; read(@f,ch1);
  22 ( 6375)   while (ch1>=' ') and (ch1<>alteof) and
  23 ( 6390)       (pos<strsize-1) do begin
  24 ( 6405)     pnt[pos]:=ch1; pos:=pos+1; read(@f,ch1);
  25 ( 6438)     end;
  26 ( 6439)   pnt[pos]:=endmark;
  27 ( 6448)   readline:=(ch1=eof) or (ch1=alteof);
  28 ( 6466) end;
  29 ( 6471) 
  30 ( 6472) proc setsubtype(var nm:array[15] of char;subtype:char);
  31 ( 6472) {#####################################################}
  32 ( 6472) var i:integer;
  33 ( 6475) begin
  34 ( 6475)   i:=0;
  35 ( 6479)   repeat
  36 ( 6483)     i:=i+1;
  37 ( 6489)   until (nm[i]=':') or
  38 ( 6505)     (nm[i]=' ') or (i>=14);
  39 ( 6524)   nm[i]:=':';
  40 ( 6534)   nm[i+1]:=subtype;
  41 ( 6545) end;
  42 ( 6553) 
  43 ( 6554) proc writehex(a:integer);
  44 ( 6554) {#######################}
  45 ( 6554) var h:integer;
  46 ( 6557)   func hexdigit(c:char):char;
  47 ( 6557)   var d:integer;
  48 ( 6560)   begin
  49 ( 6560)     d:=ord(c) and 15;
  50 ( 6568)     if d>9 then hexdigit:=chr(d-10+ord('A'))
  51 ( 6592)     else hexdigit:=chr(d+ord('0'));
  52 ( 6608)   end;
  53 ( 6613) begin
  54 ( 6614)   h:=a and 255;
  55 ( 6622)   write(hexdigit(chr(h shr 4)));
  56 ( 6644)   write(hexdigit(chr(h and 15)));
  57 ( 6661) end;
  58 ( 6661) 
  59 ( 6662) proc writeui(n:integer);

----------------------------------------------------------------------

R65 COMPILE 4.2: program PCODES           7/12/23 page 2

  60 ( 6662) {######################}
  61 ( 6662) var limit:integer;
  62 ( 6665) begin
  63 ( 6665)   limit:=10000;
  64 ( 6670)   while (limit>n) and (limit>0) do begin
  65 ( 6694)     limit:=limit div 10; write(' ');
  66 ( 6707)   end;
  67 ( 6707)   write(n);
  68 ( 6715) end;
  69 ( 6715) 
  70 ( 6716) proc showprog;
  71 ( 6716) {############}
  72 ( 6716) var pc,a,b,c,codesize:integer;
  73 ( 6719)     r:real;
  74 ( 6719)     done,normal:boolean;
  75 ( 6719) 
  76 ( 6719)   proc packreal(i1,i2:%integer;
  77 ( 6719)     var r:array[1] of %integer);
  78 ( 6719)   begin
  79 ( 6719)     r[0]:=i1; r[1]:=i2;
  80 ( 6736)   end;
  81 ( 6744) 
  82 ( 6745) begin
  83 ( 6745)   line:=1;
  84 ( 6749)   getbyte(fcode,0,a);
  85 ( 6765)   getbyte(fcode,1,b);
  86 ( 6777)   codesize:=a+(b shl 8);
  87 ( 6788)   writeln('Program size: ', codesize,' bytes, ',
  88 ( 6822)     b+1,' sectors');
  89 ( 6845)   writeln;
  90 ( 6845)   pc:=2;
  91 ( 6853) 
  92 ( 6857)   repeat
  93 ( 6857)     normal:=true;
  94 ( 6859)     silent:=(line<first);
  95 ( 6872)     getbyte(fcode,pc,code);
  96 ( 6890)     if code<0 then begin
  97 ( 6897)       writeln('Negative code');
  98 ( 6920)       exit;
  99 ( 6921)     end;
 100 ( 6921)     if not silent then begin
 101 ( 6926)       write('  '); writeui(pc);
 102 ( 6942)       write(' '); writehex(code);
 103 ( 6954)       write(' ',codebytes[code],' ');
 104 ( 6967)     end;
 105 ( 6967)     if (code<=npcodes) and (code>=0) then begin
 106 ( 6982)       if not silent then write(codename[code])
 107 ( 6997)     end else begin
 108 ( 7005)       writeln('pcode not known');
 109 ( 7027)       exit;
 110 ( 7028)     end;
 111 ( 7028)     c:=0;
 112 ( 7030)     case codebytes[code] of
 113 ( 7038)       2: begin
 114 ( 7049)              getbyte(fcode,pc+1,a);
 115 ( 7066)              if not silent then write(' ',a);
 116 ( 7081)            end;
 117 ( 7081)       3: begin
 118 ( 7091)              getbyte(fcode,pc+1,a);
 119 ( 7108)              getbyte(fcode,pc+2,b);

----------------------------------------------------------------------

R65 COMPILE 4.2: program PCODES           7/12/23 page 3

 120 ( 7125)              c:=a+(b shl 8);
 121 ( 7136)              if not silent then begin
 122 ( 7146)                { exception for JUMP }
 123 ( 7149)                if code=$24 then write(' ',c+pc+1)
 124 ( 7172)                else write(' ',c);
 125 ( 7184)              end;
 126 ( 7184)            end;
 127 ( 7184)       4: begin
 128 ( 7194)              getbyte(fcode,pc+1,a);
 129 ( 7211)              if not silent then write(' ',a,',');
 130 ( 7228)              getbyte(fcode,pc+2,a);
 131 ( 7245)              getbyte(fcode,pc+3,b);
 132 ( 7262)              if not silent then write(' ',a+(b shl 8));
 133 ( 7285)            end;
 134 ( 7285)       5: begin
 135 ( 7295)              getbyte(fcode,pc+1,a);
 136 ( 7312)              getbyte(fcode,pc+2,b);
 137 ( 7329)              if not silent then
 138 ( 7329)                write(' ',a+(b shl 8),' ');
 139 ( 7354)              getbyte(fcode,pc+3,a);
 140 ( 7371)              getbyte(fcode,pc+4,b);
 141 ( 7388)              if not silent then
 142 ( 7388)                write(' ',a+(b shl 8));
 143 ( 7411)          end;
 144 ( 7411)       6: begin
 145 ( 7421)            getbyte(fcode,pc+1,a);
 146 ( 7438)            if not silent then write(' ',a,',');
 147 ( 7455)            getbyte(fcode,pc+2,a);
 148 ( 7472)            getbyte(fcode,pc+3,b);
 149 ( 7489)            c:=a+(b shl 8); ;
 150 ( 7505)            getbyte(fcode,pc+4,a);
 151 ( 7522)            getbyte(fcode,pc+5,b);
 152 ( 7539)            if not silent then begin
 153 ( 7544)              if code=$3a then begin
 154 ( 7554)                packreal(c, a+(b shl 8),r);
 155 ( 7591)                  write(' '); writeflo(output,r);
 156 ( 7607)              end else begin
 157 ( 7610)                write(' ',c,' ');
 158 ( 7619)                write(' ',a+(b shl 8));
 159 ( 7634)              end;
 160 ( 7634)            end;
 161 ( 7634)          end
 162 ( 7634)       end; {case}
 163 ( 7636)     case code of
 164 ( 7636)       $32: begin { PRTI, stops with bit 8 set }
 165 ( 7647)              normal:=false;
 166 ( 7649)              if not silent then write(' ',chr($27));
 167 ( 7667)              repeat
 168 ( 7667)                getbyte(fcode,pc,a);
 169 ( 7681)                if not silent then
 170 ( 7681)                  write(chr(a and $7f));
 171 ( 7698)                pc:=pc+1;
 172 ( 7704)                until (a and $80)<>0;
 173 ( 7718)              if not silent then write(chr($27));
 174 ( 7734)            end;
 175 ( 7734)       $39: begin { NBYT, first argument is n bytes }
 176 ( 7744)              normal:=false;
 177 ( 7746)              getbyte(fcode,pc,a);
 178 ( 7764)              if not silent then
 179 ( 7764)                write(' ',a,',',chr($27));

----------------------------------------------------------------------

R65 COMPILE 4.2: program PCODES           7/12/23 page 4

 180 ( 7785)              for i:=1 to a do begin
 181 ( 7804)                getbyte(fcode,pc,b);
 182 ( 7818)                if not silent then
 183 ( 7818)                  write(chr(b and $7f));
 184 ( 7835)                pc:=pc+1;
 185 ( 7841)              end;
 186 ( 7846)              if not silent then write(chr($27));
 187 ( 7872)            end;
 188 ( 7872)       $56: begin { CPNT, stops with endmark }
 189 ( 7882)              normal:=false;
 190 ( 7884)              if not silent then write(' ',chr($27));
 191 ( 7902)              repeat
 192 ( 7902)                getbyte(fcode,pc,a);
 193 ( 7916)                if (a<>0) and not silent then
 194 ( 7923)                  write(chr(a and $7f));
 195 ( 7941)                pc:=pc+1;
 196 ( 7947)                until a=0;
 197 ( 7958)              if not silent then write(chr($27));
 198 ( 7974)            end;
 199 ( 7974)       $59: begin { LINE }
 200 ( 7984)              done:=false;
 201 ( 7986)              while (line<=c) and not done do begin
 202 ( 8008)                if (line<=last) then begin
 203 ( 8017)                  if not silent then writeln;
 204 ( 8028)                  done:=readline(scode,linestr);
 205 ( 8050)                  if not silent then
 206 ( 8054)                    write(invvid,line,' ',
 207 ( 8072)                      linestr,norvid);
 208 ( 8080)                end;
 209 ( 8080)                line:=line+1;
 210 ( 8086)              end;
 211 ( 8091)            end
 212 ( 8094)       end {case};
 213 ( 8096)     if not silent then writeln;
 214 ( 8104) 
 215 ( 8110)     if codebytes[code]<>0 then
 216 ( 8120)       pc:=pc+codebytes[code]
 217 ( 8128)     else begin
 218 ( 8144)       if normal then writeln('codebytes not known')
 219 ( 8171)     end;
 220 ( 8177)     until (pc>=codesize) or
 221 ( 8186)       ((codebytes[code]=0) and normal) or
 222 ( 8202)       (line>last+1);
 223 ( 8215) end;
 224 ( 8219) 
 225 ( 8220) proc init;
 226 ( 8220) {########}
 227 ( 8220) var i:integer;
 228 ( 8223)   proc set(p:integer;n:cpnt;b:integer);
 229 ( 8223)   begin
 230 ( 8223)     codename[p]:=n; codebytes[p]:=b;
 231 ( 8244)   end;
 232 ( 8252) begin
 233 ( 8253)   for i:=0 to npcodes+1 do begin
 234 ( 8275)     codename[i]:=nil; codebytes[i]:=0;
 235 ( 8291)   end;
 236 ( 8295)   set($00,'STOP',1);
 237 ( 8326)   set($01,'RETN',1);
 238 ( 8343)   set($02,'NEGA',1);
 239 ( 8360)   set($03,'ADDA',1);

----------------------------------------------------------------------

R65 COMPILE 4.2: program PCODES           7/12/23 page 5

 240 ( 8377)   set($04,'SUBA',1);
 241 ( 8394)   set($05,'MULA',1);
 242 ( 8411)   set($06,'DIVA',1);
 243 ( 8428)   set($07,'LOWB',1);
 244 ( 8445)   set($08,'TEQU',1);
 245 ( 8462)   set($09,'TNEQ',1);
 246 ( 8479)   set($0a,'TLES',1);
 247 ( 8496)   set($0b,'TGRE',1);
 248 ( 8513)   set($0c,'TGRT',1);
 249 ( 8530)   set($0d,'TLEE',1);
 250 ( 8547)   set($0e,'ORAC',1);
 251 ( 8564)   set($0f,'ANDA',1);
 252 ( 8581)   set($10,'EORA',1);
 253 ( 8598)   set($11,'NOTA',1);
 254 ( 8615)   set($12,'LEFT',1);
 255 ( 8632)   set($13,'RIGH',1);
 256 ( 8649)   set($14,'INCA',1);
 257 ( 8666)   set($15,'DECA',1);
 258 ( 8683)   set($16,'COPY',1);
 259 ( 8700)   set($17,'PEEK',1);
 260 ( 8717)   set($18,'POKE',1);
 261 ( 8734)   set($19,'CALA',1);
 262 ( 8751)   set($1a,'RLIN',0);
 263 ( 8768)   set($1b,'GETC',1);
 264 ( 8785)   set($1c,'GETN',1);
 265 ( 8802)   set($1d,'PRTC',1);
 266 ( 8819)   set($1e,'PRTN',1);
 267 ( 8836)   set($1f,'PRTS',0);
 268 ( 8853)   set($20,'LITB',2);
 269 ( 8870)   set($21,'INCB',2);
 270 ( 8887)   set($22,'LITW',3);
 271 ( 8904)   set($23,'INCW',3);
 272 ( 8921)   set($24,'JUMP',3);
 273 ( 8938)   set($25,'JMPZ',3);
 274 ( 8955)   set($26,'JMPO',3);
 275 ( 8972)   set($27,'LOAD',4);
 276 ( 8989)   set($28,'LODX',4);
 277 ( 9006)   set($29,'STOR',4);
 278 ( 9023)   set($2a,'STOX',4);
 279 ( 9040)   set($2b,'CALL',4);
 280 ( 9057)   set($2c,'SDEV',1);
 281 ( 9074)   set($2d,'RDEV',1);
 282 ( 9091)   set($2e,'FNAM',1);
 283 ( 9108)   set($2f,'OPNR',1);
 284 ( 9125)   set($30,'OPNW',1);
 285 ( 9142)   set($31,'CLOS',1);
 286 ( 9159)   set($32,'PRTI',0);
 287 ( 9176)   set($33,'GHGH',1);
 288 ( 9193)   set($34,'GLOW',1);
 289 ( 9210)   set($35,'PHGH',1);
 290 ( 9227)   set($36,'PLOW',1);
 291 ( 9244)   set($37,'GSEQ',1);
 292 ( 9261)   set($38,'PSEQ',1);
 293 ( 9278)   set($39,'NBYT',0);
 294 ( 9295)   set($3a,'NWRD',6);
 295 ( 9312)   set($3b,'LODN',2);
 296 ( 9329)   set($3c,'STON',2);
 297 ( 9346)   set($3d,'LODI',1);
 298 ( 9363)   set($3e,'STOI',1);
 299 ( 9380)   set($3f,'EXST',1);

----------------------------------------------------------------------

R65 COMPILE 4.2: program PCODES           7/12/23 page 6

 300 ( 9397)   set($40,'TIND',5);
 301 ( 9414)   set($41,'RUNP',1);
 302 ( 9431)   set($42,'ADDF',1);
 303 ( 9448)   set($43,'SUBF',1);
 304 ( 9465)   set($44,'MULF',1);
 305 ( 9482)   set($45,'DIVF',1);
 306 ( 9499)   set($46,'FLOF',1);
 307 ( 9516)   set($47,'FIXF',1);
 308 ( 9533)   set($48,'FEQU',1);
 309 ( 9550)   set($49,'FNEQ',1);
 310 ( 9567)   set($4a,'FLES',1);
 311 ( 9584)   set($4b,'FGRE',1);
 312 ( 9601)   set($4c,'FGRT',1);
 313 ( 9618)   set($4d,'FLEE',1);
 314 ( 9635)   set($4e,'FCOM',1);
 315 ( 9652)   set($4f,'TFER',1);
 316 ( 9669)   set($50,'OPRA',1);
 317 ( 9686)   set($51,'GTRA',1);
 318 ( 9703)   set($52,'PTRA',1);
 319 ( 9720)   set($53,'SWA2',1);
 320 ( 9737)   set($54,'LDXI',1);
 321 ( 9754)   set($55,'STXI',4);
 322 ( 9771)   set($56,'CPNT',0);
 323 ( 9788)   set($57,'WRCP',1);
 324 ( 9805)   set($58,'ADPS',1);
 325 ( 9822)   set($59,'LINE',3);
 326 ( 9839) end;
 327 ( 9839) 
 328 ( 9840) begin {main}
 329 ( 9840)   init;
 330 ( 9847)   linestr:=new;
 331 ( 9853)   cyclus:=0; drive:=1;
 332 ( 9865)   agetstring(name,default,cyclus,drive);
 333 ( 9909)   setsubtype(name,'R');
 334 ( 9929)   writeln('Opening object file ');
 335 ( 9956)   fcode:=attach(name,0,1,fread,0,0,'R');
 336 ( 9982)   cdsize:=getsize;
 337 ( 9992)   writeln;
 338 ( 9996)   writeln('Object file opened, file size ',
 339 (10033)     cdsize div 256,' sectors');
 340 (10057)   setsubtype(name,'P');
 341 (10077)   asetfile(name,cyclus,drive,'P');
 342 (10099)   writeln('Opening source file ');
 343 (10126)   openr(scode);
 344 (10132)   writeln; writeln('Source file opened');
 345 (10163)   first:=0; last:=32000;
 346 (10172)   agetval(first,default);
 347 (10196)   agetval(last,default);
 348 (10216)   writeln('display from ',first,' to ',last);
 349 (10251)   showprog;
 350 (10255)   close(fcode);
 351 (10261)   close(scode);
 352 (10267) end.

End compile

Code lenght:          10266
Compiler stack size:  169
Ident stack size:     160
Pascal errors:        0
