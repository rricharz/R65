
R65 COMPILE 4.2: program PCODES           6/12/23 page 1


   1 (    4) program pcodes;
   2 (    4) uses syslib,arglib,strlib,ralib,mathlib;
   3 ( 6287) 
   4 ( 6287) const npcodes=$59;
   5 ( 6290) 
   6 ( 6290) var codename: array[npcodes] of cpnt;
   7 ( 6290)     codebytes: array[npcodes] of integer;
   8 ( 6290)     fcode,scode: file;
   9 ( 6290)     cdsize,i,code,line,first,last: integer;
  10 ( 6290)     name: array[15] of char;
  11 ( 6290)     cyclus,drive:integer;
  12 ( 6290)     default,silent: boolean;
  13 ( 6290)     linestr:cpnt;
  14 ( 6290) 
  15 ( 6290) func readline(f: file; pnt: cpnt): boolean;
  16 ( 6290) {#########################################}
  17 ( 6290) const alteof=chr(127);
  18 ( 6293) var ch1: char;
  19 ( 6293)     pos: integer;
  20 ( 6293) begin
  21 ( 6293)   pos := 0; read(@f,ch1);
  22 ( 6311)   while (ch1>=' ') and (ch1<>alteof) and
  23 ( 6326)       (pos<strsize-1) do begin
  24 ( 6341)     pnt[pos]:=ch1; pos:=pos+1; read(@f,ch1);
  25 ( 6374)     end;
  26 ( 6375)   pnt[pos]:=endmark;
  27 ( 6384)   readline:=(ch1=eof) or (ch1=alteof);
  28 ( 6402) end;
  29 ( 6407) 
  30 ( 6408) proc setsubtype(var nm:array[15] of char;subtype:char);
  31 ( 6408) {#####################################################}
  32 ( 6408) var i:integer;
  33 ( 6411) begin
  34 ( 6411)   i:=0;
  35 ( 6415)   repeat
  36 ( 6419)     i:=i+1;
  37 ( 6425)   until (nm[i]=':') or
  38 ( 6441)     (nm[i]=' ') or (i>=14);
  39 ( 6460)   nm[i]:=':';
  40 ( 6470)   nm[i+1]:=subtype;
  41 ( 6481) end;
  42 ( 6489) 
  43 ( 6490) proc writehex(a:integer);
  44 ( 6490) {#######################}
  45 ( 6490) var h:integer;
  46 ( 6493)   func hexdigit(c:char):char;
  47 ( 6493)   var d:integer;
  48 ( 6496)   begin
  49 ( 6496)     d:=ord(c) and 15;
  50 ( 6504)     if d>9 then hexdigit:=chr(d-10+ord('A'))
  51 ( 6528)     else hexdigit:=chr(d+ord('0'));
  52 ( 6544)   end;
  53 ( 6549) begin
  54 ( 6550)   h:=a and 255;
  55 ( 6558)   write(hexdigit(chr(h shr 4)));
  56 ( 6580)   write(hexdigit(chr(h and 15)));
  57 ( 6597) end;
  58 ( 6597) 
  59 ( 6598) proc writeui(n:integer);

----------------------------------------------------------------------

R65 COMPILE 4.2: program PCODES           6/12/23 page 2

  60 ( 6598) {######################}
  61 ( 6598) var limit:integer;
  62 ( 6601) begin
  63 ( 6601)   limit:=10000;
  64 ( 6606)   while (limit>n) and (limit>0) do begin
  65 ( 6630)     limit:=limit div 10; write(' ');
  66 ( 6643)   end;
  67 ( 6643)   write(n);
  68 ( 6651) end;
  69 ( 6651) 
  70 ( 6652) proc showprog;
  71 ( 6652) {############}
  72 ( 6652) var pc,a,b,c,codesize:integer;
  73 ( 6655)     r:real;
  74 ( 6655)     done,normal:boolean;
  75 ( 6655) 
  76 ( 6655)   proc packreal(i1,i2:%integer;
  77 ( 6655)     var r:array[1] of %integer);
  78 ( 6655)   begin
  79 ( 6655)     r[0]:=i1; r[1]:=i2;
  80 ( 6672)   end;
  81 ( 6680) 
  82 ( 6681) begin
  83 ( 6681)   line:=1;
  84 ( 6685)   getbyte(fcode,0,a);
  85 ( 6701)   getbyte(fcode,1,b);
  86 ( 6713)   codesize:=a+(b shl 8);
  87 ( 6724)   writeln('Program size: ', codesize,' bytes, ',
  88 ( 6758)     b+1,' sectors');
  89 ( 6781)   writeln;
  90 ( 6781)   pc:=2;
  91 ( 6789) 
  92 ( 6793)   repeat
  93 ( 6793)     normal:=true;
  94 ( 6795)     silent:=(line<first);
  95 ( 6808)     getbyte(fcode,pc,code);
  96 ( 6826)     if code<0 then begin
  97 ( 6833)       writeln('Negative code');
  98 ( 6856)       exit;
  99 ( 6857)     end;
 100 ( 6857)     if not silent then begin
 101 ( 6862)       write('  '); writeui(pc);
 102 ( 6878)       write(' '); writehex(code);
 103 ( 6890)       write(' ',codebytes[code],' ');
 104 ( 6903)     end;
 105 ( 6903)     if (code<=npcodes) and (code>=0) then begin
 106 ( 6918)       if not silent then write(codename[code])
 107 ( 6933)     end else begin
 108 ( 6941)       writeln('pcode not known');
 109 ( 6963)       exit;
 110 ( 6964)     end;
 111 ( 6964)     c:=0;
 112 ( 6966)     case codebytes[code] of
 113 ( 6974)       2: begin
 114 ( 6985)              getbyte(fcode,pc+1,a);
 115 ( 7002)              if not silent then write(' ',a);
 116 ( 7017)            end;
 117 ( 7017)       3: begin
 118 ( 7027)              getbyte(fcode,pc+1,a);
 119 ( 7044)              getbyte(fcode,pc+2,b);

----------------------------------------------------------------------

R65 COMPILE 4.2: program PCODES           6/12/23 page 3

 120 ( 7061)              c:=a+(b shl 8);
 121 ( 7072)              if not silent then begin
 122 ( 7082)                { exception for JUMP }
 123 ( 7085)                if code=$24 then write(' ',c+pc+1)
 124 ( 7108)                else write(' ',c);
 125 ( 7120)              end;
 126 ( 7120)            end;
 127 ( 7120)       4: begin
 128 ( 7130)              getbyte(fcode,pc+1,a);
 129 ( 7147)              if not silent then write(' ',a,',');
 130 ( 7164)              getbyte(fcode,pc+2,a);
 131 ( 7181)              getbyte(fcode,pc+3,b);
 132 ( 7198)              if not silent then write(' ',a+(b shl 8));
 133 ( 7221)            end;
 134 ( 7221)       5: begin
 135 ( 7231)              getbyte(fcode,pc+1,a);
 136 ( 7248)              getbyte(fcode,pc+2,b);
 137 ( 7265)              if not silent then
 138 ( 7265)                write(' ',a+(b shl 8),' ');
 139 ( 7290)              getbyte(fcode,pc+3,a);
 140 ( 7307)              getbyte(fcode,pc+4,b);
 141 ( 7324)              if not silent then
 142 ( 7324)                write(' ',a+(b shl 8));
 143 ( 7347)          end;
 144 ( 7347)       6: begin
 145 ( 7357)            getbyte(fcode,pc+1,a);
 146 ( 7374)            if not silent then write(' ',a,',');
 147 ( 7391)            getbyte(fcode,pc+2,a);
 148 ( 7408)            getbyte(fcode,pc+3,b);
 149 ( 7425)            c:=a+(b shl 8); ;
 150 ( 7441)            getbyte(fcode,pc+4,a);
 151 ( 7458)            getbyte(fcode,pc+5,b);
 152 ( 7475)            if not silent then begin
 153 ( 7480)              if code=$3a then begin
 154 ( 7490)                packreal(c, a+(b shl 8),r);
 155 ( 7527)                  write(' '); writeflo(output,r);
 156 ( 7543)              end else begin
 157 ( 7546)                write(' ',c,' ');
 158 ( 7555)                write(' ',a+(b shl 8));
 159 ( 7570)              end;
 160 ( 7570)            end;
 161 ( 7570)          end
 162 ( 7570)       end; {case}
 163 ( 7572)     case code of
 164 ( 7572)       $32: begin { PRTI, stops with bit 8 set }
 165 ( 7583)              normal:=false;
 166 ( 7585)              if not silent then write(' ',chr($27));
 167 ( 7603)              repeat
 168 ( 7603)                getbyte(fcode,pc,a);
 169 ( 7617)                if not silent then
 170 ( 7617)                  write(chr(a and $7f));
 171 ( 7634)                pc:=pc+1;
 172 ( 7640)                until (a and $80)<>0;
 173 ( 7654)              if not silent then write(chr($27));
 174 ( 7670)            end;
 175 ( 7670)       $39: begin { NBYT, first argument is n bytes }
 176 ( 7680)              normal:=false;
 177 ( 7682)              getbyte(fcode,pc,a);
 178 ( 7700)              if not silent then
 179 ( 7700)                write(' ',a,',',chr($27));

----------------------------------------------------------------------

R65 COMPILE 4.2: program PCODES           6/12/23 page 4

 180 ( 7721)              for i:=1 to a do begin
 181 ( 7740)                getbyte(fcode,pc,b);
 182 ( 7754)                if not silent then
 183 ( 7754)                  write(chr(b and $7f));
 184 ( 7771)                pc:=pc+1;
 185 ( 7777)              end;
 186 ( 7782)              if not silent then write(chr($27));
 187 ( 7808)            end;
 188 ( 7808)       $56: begin { CPNT, stops with endmark }
 189 ( 7818)              normal:=false;
 190 ( 7820)              if not silent then write(' ',chr($27));
 191 ( 7838)              repeat
 192 ( 7838)                getbyte(fcode,pc,a);
 193 ( 7852)                if (a<>0) and not silent then
 194 ( 7859)                  write(chr(a and $7f));
 195 ( 7877)                pc:=pc+1;
 196 ( 7883)                until a=0;
 197 ( 7894)              if not silent then write(chr($27));
 198 ( 7910)            end;
 199 ( 7910)       $59: begin { LINE }
 200 ( 7920)              done:=false;
 201 ( 7922)              while (line<=c) and not done do begin
 202 ( 7944)                if (line<=last) then begin
 203 ( 7953)                  if not silent then writeln;
 204 ( 7964)                  done:=readline(scode,linestr);
 205 ( 7986)                  if not silent then
 206 ( 7990)                    write(invvid,line,' ',
 207 ( 8008)                      linestr,norvid);
 208 ( 8016)                end;
 209 ( 8016)                line:=line+1;
 210 ( 8022)              end;
 211 ( 8027)            end
 212 ( 8030)       end {case};
 213 ( 8032)     if not silent then writeln;
 214 ( 8040) 
 215 ( 8046)     if codebytes[code]<>0 then
 216 ( 8056)       pc:=pc+codebytes[code]
 217 ( 8064)     else begin
 218 ( 8080)       if normal then writeln('codebytes not known')
 219 ( 8107)     end;
 220 ( 8113)     until (pc>=codesize) or
 221 ( 8122)       ((codebytes[code]=0) and normal) or
 222 ( 8138)       (line>last+1);
 223 ( 8151) end;
 224 ( 8155) 
 225 ( 8156) proc init;
 226 ( 8156) {########}
 227 ( 8156) var i:integer;
 228 ( 8159)   proc set(p:integer;n:cpnt;b:integer);
 229 ( 8159)   begin
 230 ( 8159)     codename[p]:=n; codebytes[p]:=b;
 231 ( 8180)   end;
 232 ( 8188) begin
 233 ( 8189)   for i:=0 to npcodes+1 do begin
 234 ( 8211)     codename[i]:=nil; codebytes[i]:=0;
 235 ( 8227)   end;
 236 ( 8231)   set($00,'STOP',1);
 237 ( 8262)   set($01,'RETN',1);
 238 ( 8279)   set($02,'NEGA',1);
 239 ( 8296)   set($03,'ADDA',1);

----------------------------------------------------------------------

R65 COMPILE 4.2: program PCODES           6/12/23 page 5

 240 ( 8313)   set($04,'SUBA',1);
 241 ( 8330)   set($05,'MULA',1);
 242 ( 8347)   set($06,'DIVA',1);
 243 ( 8364)   set($07,'LOWB',1);
 244 ( 8381)   set($08,'TEQU',1);
 245 ( 8398)   set($09,'TNEQ',1);
 246 ( 8415)   set($0a,'TLES',1);
 247 ( 8432)   set($0b,'TGRE',1);
 248 ( 8449)   set($0c,'TGRT',1);
 249 ( 8466)   set($0d,'TLEE',1);
 250 ( 8483)   set($0e,'ORAC',1);
 251 ( 8500)   set($0f,'ANDA',1);
 252 ( 8517)   set($10,'EORA',1);
 253 ( 8534)   set($11,'NOTA',1);
 254 ( 8551)   set($12,'LEFT',1);
 255 ( 8568)   set($13,'RIGH',1);
 256 ( 8585)   set($14,'INCA',1);
 257 ( 8602)   set($15,'DECA',1);
 258 ( 8619)   set($16,'COPY',1);
 259 ( 8636)   set($17,'PEEK',1);
 260 ( 8653)   set($18,'POKE',1);
 261 ( 8670)   set($19,'CALA',1);
 262 ( 8687)   set($1a,'RLIN',0);
 263 ( 8704)   set($1b,'GETC',1);
 264 ( 8721)   set($1c,'GETN',1);
 265 ( 8738)   set($1d,'PRTC',1);
 266 ( 8755)   set($1e,'PRTN',1);
 267 ( 8772)   set($1f,'PRTS',0);
 268 ( 8789)   set($20,'LITB',2);
 269 ( 8806)   set($21,'INCB',2);
 270 ( 8823)   set($22,'LITW',3);
 271 ( 8840)   set($23,'INCW',3);
 272 ( 8857)   set($24,'JUMP',3);
 273 ( 8874)   set($25,'JMPZ',3);
 274 ( 8891)   set($26,'JMPO',3);
 275 ( 8908)   set($27,'LOAD',4);
 276 ( 8925)   set($28,'LODX',4);
 277 ( 8942)   set($29,'STOR',4);
 278 ( 8959)   set($2a,'STOX',4);
 279 ( 8976)   set($2b,'CALL',4);
 280 ( 8993)   set($2c,'SDEV',1);
 281 ( 9010)   set($2d,'RDEV',1);
 282 ( 9027)   set($2e,'FNAM',1);
 283 ( 9044)   set($2f,'OPNR',1);
 284 ( 9061)   set($30,'OPNW',1);
 285 ( 9078)   set($31,'CLOS',1);
 286 ( 9095)   set($32,'PRTI',0);
 287 ( 9112)   set($33,'GHGH',1);
 288 ( 9129)   set($34,'GLOW',1);
 289 ( 9146)   set($35,'PHGH',1);
 290 ( 9163)   set($36,'PLOW',1);
 291 ( 9180)   set($37,'GSEQ',1);
 292 ( 9197)   set($38,'PSEQ',1);
 293 ( 9214)   set($39,'NBYT',0);
 294 ( 9231)   set($3a,'NWRD',6);
 295 ( 9248)   set($3b,'LODN',2);
 296 ( 9265)   set($3c,'STON',2);
 297 ( 9282)   set($3d,'LODI',1);
 298 ( 9299)   set($3e,'STOI',1);
 299 ( 9316)   set($3f,'EXST',1);

----------------------------------------------------------------------

R65 COMPILE 4.2: program PCODES           6/12/23 page 6

 300 ( 9333)   set($40,'TIND',5);
 301 ( 9350)   set($41,'RUNP',1);
 302 ( 9367)   set($42,'ADDF',1);
 303 ( 9384)   set($43,'SUBF',1);
 304 ( 9401)   set($44,'MULF',1);
 305 ( 9418)   set($45,'DIVF',1);
 306 ( 9435)   set($46,'FLOF',1);
 307 ( 9452)   set($47,'FIXF',1);
 308 ( 9469)   set($48,'FEQU',1);
 309 ( 9486)   set($49,'FNEQ',1);
 310 ( 9503)   set($4a,'FLES',1);
 311 ( 9520)   set($4b,'FGRE',1);
 312 ( 9537)   set($4c,'FGRT',1);
 313 ( 9554)   set($4d,'FLEE',1);
 314 ( 9571)   set($4e,'FCOM',1);
 315 ( 9588)   set($4f,'TFER',1);
 316 ( 9605)   set($50,'OPRA',1);
 317 ( 9622)   set($51,'GTRA',1);
 318 ( 9639)   set($52,'PTRA',1);
 319 ( 9656)   set($53,'SWA2',1);
 320 ( 9673)   set($54,'LDXI',1);
 321 ( 9690)   set($55,'STXI',4);
 322 ( 9707)   set($56,'CPNT',0);
 323 ( 9724)   set($57,'WRCP',1);
 324 ( 9741)   set($58,'ADPS',1);
 325 ( 9758)   set($59,'LINE',3);
 326 ( 9775) end;
 327 ( 9775) 
 328 ( 9776) begin {main}
 329 ( 9776)   init;
 330 ( 9783)   linestr:=strnew;
 331 ( 9789)   cyclus:=0; drive:=1;
 332 ( 9801)   agetstring(name,default,cyclus,drive);
 333 ( 9845)   setsubtype(name,'R');
 334 ( 9865)   writeln('Opening object file ');
 335 ( 9892)   fcode:=attach(name,0,1,fread,0,0,'R');
 336 ( 9918)   cdsize:=getsize;
 337 ( 9928)   writeln;
 338 ( 9932)   writeln('Object file opened, file size ',
 339 ( 9969)     cdsize div 256,' sectors');
 340 ( 9993)   setsubtype(name,'P');
 341 (10013)   asetfile(name,cyclus,drive,'P');
 342 (10035)   writeln('Opening source file ');
 343 (10062)   openr(scode);
 344 (10068)   writeln; writeln('Source file opened');
 345 (10099)   first:=0; last:=32000;
 346 (10108)   agetval(first,default);
 347 (10132)   agetval(last,default);
 348 (10152)   writeln('display from ',first,' to ',last);
 349 (10187)   showprog;
 350 (10191)   close(fcode);
 351 (10197)   close(scode);
 352 (10203) end.

End compile

Code lenght:          10202
Compiler stack size:  165
Ident stack size:     158
Pascal errors:        0
