
R65 COMPILE 4.3: program LADDERS          21/2/24 page 1


   1 (    4) { ladders: climb up the ladders
   2 (    4) 
   3 (    4)   Demo mode: ladders /D
   4 (    4) 
   5 (    4)   2024 rricharz                      }
   6 (    4) 
   7 (    4) program ladders;
   8 (    4) uses syslib,plotlib,ledlib,arglib,strlib;
   9 ( 3780) 
  10 ( 3780) const erase=0; ball=$6ff6;
  11 ( 3783)       nfloors=5; vfloors=20; holesize=22;
  12 ( 3783)       gravity=-0.25; reflection=-0.7;
  13 ( 3783)       laddersize=8; autorepeat=false;
  14 ( 3783)       cleft=chr($03); cright=chr($16);
  15 ( 3783)       cup=chr($1a); cdown=chr($18); esc=chr(0);
  16 ( 3783)       face1=$8b43; face2=$2a48;
  17 ( 3783)       face3=$034a; face4=$084a;
  18 ( 3783) 
  19 ( 3783) var bx,by,bxs,bys,bxspeed,byspeed,fx,fxs: real;
  20 ( 3783)     fxspeed,jump,jumpspeed: real;
  21 ( 3783)     floor,ffloor,fy,fys,fyspeed: integer;
  22 ( 3783)     holes,ladders: array[nfloors] of integer;
  23 ( 3783)     score,count: integer;
  24 ( 3783)     demomode:boolean;
  25 ( 3783) 
  26 ( 3783) {$I IRANDOM:P}
IRANDOM:P       .02  SP 0000-0200 0002 12/02/24
{I}    1 ( 3783) { irandom: real and integer random functions with limit
{I}    2 ( 3783) }
{I}    3 ( 3783) 
{I}    4 ( 3783) func rrandom(min,max:real):real;
{I}    5 ( 3783) begin
{I}    6 ( 3783)   rrandom := min + (conv(random)/255.0) * (max - min);
{I}    7 ( 3821) end;
{I}    8 ( 3829) 
{I}    9 ( 3830) func irandom(min,max:integer):integer;
{I}   10 ( 3830) begin
{I}   11 ( 3830)   irandom := trunc(rrandom(conv(min),conv(max)));
{I}   12 ( 3853) end;
{I}   13 ( 3858) 
  27 ( 3859) 
  28 ( 3859) func getoption(opt:char):boolean;
  29 ( 3859) var i,dummy,savecarg:integer;
  30 ( 3862)     options:array[15] of char;
  31 ( 3862)     default:boolean;
  32 ( 3862) begin
  33 ( 3862)   savecarg:=carg; { save for next call to getoption }
  34 ( 3872)   agetstring(options,default,dummy,dummy);
  35 ( 3912)   getoption:=false;
  36 ( 3914)   if not default then begin
  37 ( 3923)     if options[0]<>'/' then argerror(103);
  38 ( 3946)     for i:=1 to 15 do
  39 ( 3954)       if options[i]=opt then getoption:=true;
  40 ( 3981)   end;
  41 ( 3999)   carg:=savecarg;
  42 ( 3999) end;
  43 ( 4007) 
  44 ( 4008) func onfloor(f,y:integer):boolean;
  45 ( 4008) begin
  46 ( 4008)   onfloor:=(f*vfloors+1=y);

----------------------------------------------------------------------

R65 COMPILE 4.3: program LADDERS          21/2/24 page 2

  47 ( 4028) end;
  48 ( 4032) 
  49 ( 4033) func onupladder(f:integer;x:real):boolean;
  50 ( 4033) begin
  51 ( 4033)   onupladder:=(trunc(x)>=ladders[f]+1) and
  52 ( 4057)     (trunc(x)<=ladders[f]+2);
  53 ( 4076) end;
  54 ( 4081) 
  55 ( 4082) func ondownladder(f:integer;x:real):boolean;
  56 ( 4082) begin
  57 ( 4082)   if f=0 then ondownladder:=false
  58 ( 4097)   else ondownladder:=(trunc(x)>=ladders[f-1]+1) and
  59 ( 4128)     (trunc(x+0.5)<=ladders[f-1]+2);
  60 ( 4157) end;
  61 ( 4162) 
  62 ( 4163) func onhole(f:integer;x:real):boolean;
  63 ( 4163) begin
  64 ( 4163)   onhole:=(x>=conv(holes[f]-5)) and
  65 ( 4187)       (x<=conv(holes[f]+holesize+1));
  66 ( 4209) end;
  67 ( 4214) 
  68 ( 4215) proc showface;
  69 ( 4215) var fysum:integer;
  70 ( 4218) begin
  71 ( 4218)   fysum:=fy+trunc(jump);
  72 ( 4230)   plotmap(trunc(fxs),fys,erase);
  73 ( 4255)   plotmap(trunc(fxs)+4,fys,erase);
  74 ( 4277)   plotmap(trunc(fxs),fys+4,erase);
  75 ( 4299)   plotmap(trunc(fxs)+4,fys+4,erase);
  76 ( 4324)   plotmap(trunc(fx),fysum,face1);
  77 ( 4344)   plotmap(trunc(fx)+4,fysum,face2);
  78 ( 4367)   plotmap(trunc(fx),fysum+4,face3);
  79 ( 4390)   plotmap(trunc(fx)+4,fysum+4,face4);
  80 ( 4416)   fxs:=fx; fys:=fysum;
  81 ( 4428) end;
  82 ( 4436) 
  83 ( 4437) proc showladder(f:integer);
  84 ( 4437) var i,x1,x2,y1,y2:integer;
  85 ( 4440) begin
  86 ( 4440)   if f<nfloors then begin
  87 ( 4449)     x1:=ladders[f]; x2:=x1+laddersize;
  88 ( 4470)     y1:=f*vfloors+1; y2:=y1+vfloors-1;
  89 ( 4498)     move(x1,y1); draw(x1,y2,white);
  90 ( 4533)     move(x2,y1); draw(x2,y2,white);
  91 ( 4563)     i:=1;
  92 ( 4565)     for i:=1 to 5 do begin
  93 ( 4586)       move(x1,y1+4*i-1); draw(x2,y1+4*i-1,white);
  94 ( 4638)     end;
  95 ( 4638)   end;
  96 ( 4652) end;
  97 ( 4652) 
  98 ( 4653) proc init; forward;
  99 ( 4656) 
 100 ( 4656) proc showresult;
 101 ( 4656) var s:cpnt;
 102 ( 4659) begin
 103 ( 4659)   s:=new;
 104 ( 4667)   write(@s,' ',score,' 0F ',count);
 105 ( 4694)   ledstring(s);
 106 ( 4704)   release(s);

----------------------------------------------------------------------

R65 COMPILE 4.3: program LADDERS          21/2/24 page 3

 107 ( 4714) end;
 108 ( 4714) 
 109 ( 4715) proc ladderup;
 110 ( 4715) begin
 111 ( 4715)   if (ffloor<nfloors) and onupladder(ffloor,fx)
 112 ( 4733)   then begin
 113 ( 4746)     fx:=conv(ladders[ffloor]+1);
 114 ( 4760)     fyspeed:=1; fxspeed:=0.0;
 115 ( 4779)   end;
 116 ( 4785) end;
 117 ( 4785) 
 118 ( 4786) func expaint: boolean;
 119 ( 4786) { paint picture and apply motion }
 120 ( 4786) var f:integer;
 121 ( 4789)     s:cpnt;
 122 ( 4789) begin
 123 ( 4789)   if demomode then begin
 124 ( 4795)     if ffloor=nfloors then fxspeed:=2.0
 125 ( 4808)     else if (ffloor<nfloors) and onupladder(ffloor,fx)
 126 ( 4836)     then ladderup
 127 ( 4849)     else if onfloor(ffloor,fy) then  begin
 128 ( 4875)       if (trunc(fx)>=ladders[ffloor]+1) then begin
 129 ( 4897)         if fxspeed>1.0 then fxspeed:=0.0
 130 ( 4916)         else fxspeed:=-2.0;
 131 ( 4937)       end else begin
 132 ( 4947)         if fxspeed<-1.0 then fxspeed:=0.0
 133 ( 4964)         else fxspeed:=2.0
 134 ( 4979)       end;
 135 ( 4991)     end;
 136 ( 4991)   end;
 137 ( 4991) 
 138 ( 4991)   expaint:=false;
 139 ( 4993)   if (ffloor=nfloors) and (trunc(fx)>xsize-10) then
 140 ( 5017)   begin
 141 ( 5018)     score:=score+1; count:=count+1;
 142 ( 5038)     if count>=10 then begin
 143 ( 5050)       if demomode then begin
 144 ( 5057)         score:=0; count:=0; init;
 145 ( 5076)       end else begin
 146 ( 5079)         expaint:=true; exit;
 147 ( 5086)       end;
 148 ( 5086)     end;
 149 ( 5086)     init;
 150 ( 5090)     fx:=1.0; fy:=1; fxspeed:=0.0; ffloor:=0;
 151 ( 5122)     showresult;
 152 ( 5130)     exit;
 153 ( 5131)   end;
 154 ( 5131)   { check for next floor on ladder }
 155 ( 5131)   if ffloor<nfloors then
 156 ( 5137)     if onfloor(ffloor+1,fy) then begin
 157 ( 5160)       ffloor:=ffloor+1; fyspeed:=0;
 158 ( 5176)     end;
 159 ( 5180)   if ffloor>0 then
 160 ( 5186)     if onfloor(ffloor-1,fy) then begin
 161 ( 5209)       ffloor:=ffloor-1; fyspeed:=0;
 162 ( 5225)     end;
 163 ( 5229)   { paint face }
 164 ( 5229)   showface;
 165 ( 5233)   { paint ball }
 166 ( 5233)   plotmap(trunc(bxs),trunc(bys),erase);

----------------------------------------------------------------------

R65 COMPILE 4.3: program LADDERS          21/2/24 page 4

 167 ( 5255)   plotmap(trunc(bx),trunc(by),ball);
 168 ( 5278)   for f:=0 to nfloors-1 do showladder(f);
 169 ( 5308)   bxs:=bx; bys:=by;
 170 ( 5334)   { move face }
 171 ( 5346)   fx:=fx+fxspeed; fy:=fy+fyspeed;
 172 ( 5369)   if fx>conv(xsize-8) then begin
 173 ( 5391)     fx:=conv(xsize-8); fxspeed:=0.0;
 174 ( 5412)   end;
 175 ( 5418)   if (fx<1.0) then begin
 176 ( 5431)     fx:=1.0; fxspeed:=-0.0;
 177 ( 5452)   end;
 178 ( 5459)   { check for ladder }
 179 ( 5459)   if onupladder(ffloor,fx) or ondownladder(ffloor,fx)
 180 ( 5483)     then fxspeed:=0.0;
 181 ( 5505)   { check for hole (face) and jump over it }
 182 ( 5511)   if (jump<=0.01) and onhole(ffloor,fx) then begin
 183 ( 5543)     jumpspeed:=1.3; jump:=jump+jumpspeed;
 184 ( 5564)   end else if jump>0.0 then begin
 185 ( 5593)     jump:=jump+jumpspeed;
 186 ( 5602)     jumpspeed:=jumpspeed+gravity;
 187 ( 5627)   end;
 188 ( 5634)   if jump<=0.0 then jump:=0.0;
 189 ( 5656)   { move ball }
 190 ( 5662)   bx:=bx+bxspeed; by:=by+byspeed;
 191 ( 5687)   { check for borders }
 192 ( 5700)   if bx>=conv(xsize-4) then begin
 193 ( 5713)     bx:=conv(xsize-4); bxspeed:=-bxspeed;
 194 ( 5728)   end else if bx<2.0 then begin
 195 ( 5757)     bx:=2.0; bxspeed:=-bxspeed;
 196 ( 5772)   end;
 197 ( 5785)   { check for reflection on ceiling }
 198 ( 5785)   if by>=conv((floor+1)*vfloors-4) then begin
 199 ( 5806)     by:=conv((floor+1)*vfloors-4);
 200 ( 5822)     byspeed:=reflection*byspeed;
 201 ( 5835)   end;
 202 ( 5848)   { check for hole (ball) }
 203 ( 5848)   if (bx>=conv(holes[floor])) and
 204 ( 5864)       (bx<=conv(holes[floor]+holesize-4)) and
 205 ( 5886)      (by<=conv(floor*vfloors+1)) then begin
 206 ( 5906)      { fall through hole }
 207 ( 5909)     byspeed:=byspeed+gravity;
 208 ( 5921)     if floor>0 then floor:=floor-1;
 209 ( 5944)   end else if by<conv(floor*vfloors+1) then begin
 210 ( 5970)     { reflection on floor }
 211 ( 5973)     by:=conv(floor*vfloors+2); { jump a bit }
 212 ( 5990)     byspeed:=reflection*byspeed;
 213 ( 5996)   end else
 214 ( 6009)     byspeed:=byspeed+gravity;
 215 ( 6024)   { check for border on bottom floor }
 216 ( 6031)   if (by<4.0) and ((bx<=2.0) or (bx>=conv(xsize-4)))
 217 ( 6070)   then begin
 218 ( 6072)     if bx<2.0 then bx:=2.0
 219 ( 6091)     else if bx>=conv(xsize-4) then bx:=conv(xsize-4);
 220 ( 6127)     by:=conv(nfloors*vfloors+1);
 221 ( 6142)     byspeed:=0.0; floor:=nfloors;
 222 ( 6163)   end;
 223 ( 6167)   { check for hit }
 224 ( 6167)   if (bx>=fx-4.0) and (bx<=fx+8.0) and
 225 ( 6207)      (trunc(by)>=fy-4) and (trunc(by)<=fy+8)
 226 ( 6237)     then begin

----------------------------------------------------------------------

R65 COMPILE 4.3: program LADDERS          21/2/24 page 5

 227 ( 6240)       count:=count+1;
 228 ( 6249)       showresult;
 229 ( 6258)       if count>=10 then
 230 ( 6264)         expaint:=true;
 231 ( 6270)       init;
 232 ( 6278)     end;
 233 ( 6278) end;
 234 ( 6278) 
 235 ( 6279) proc ladderup;
 236 ( 6279) begin
 237 ( 6279)   if (ffloor<nfloors) and onupladder(ffloor,fx)
 238 ( 6297)   then begin
 239 ( 6310)     fx:=conv(ladders[ffloor]+1);
 240 ( 6324)     fyspeed:=1; fxspeed:=0.0;
 241 ( 6343)   end;
 242 ( 6349) end;
 243 ( 6349) 
 244 ( 6350) proc ladderdown;
 245 ( 6350) begin
 246 ( 6350)   if (ffloor>0) and ondownladder(ffloor,fx)
 247 ( 6368)   then begin
 248 ( 6381)     fx:=conv(ladders[ffloor-1]+1);
 249 ( 6398)     fyspeed:=-1; fxspeed:=0.0;
 250 ( 6418)   end;
 251 ( 6424) end;
 252 ( 6424) 
 253 ( 6425) func exkey(key:char):boolean;
 254 ( 6425) { check for key typed }
 255 ( 6425) begin
 256 ( 6425)   exkey:=(key=esc);
 257 ( 6437)   case key of
 258 ( 6441)    cup:    ladderup;
 259 ( 6456)    cdown:  ladderdown;
 260 ( 6470)    cleft:  if onfloor(ffloor,fy) then
 261 ( 6496)              if fxspeed>1.0 then fxspeed:=0.0
 262 ( 6515)              else fxspeed:=-2.0;
 263 ( 6536)    cright: if onfloor(ffloor,fy) then
 264 ( 6569)              if fxspeed<-1.0 then fxspeed:=0.0
 265 ( 6589)              else fxspeed:=2.0
 266 ( 6604)    end {case};
 267 ( 6618) end;
 268 ( 6618) 
 269 ( 6619) proc init;
 270 ( 6619) begin
 271 ( 6619)   cleargr;
 272 ( 6628)   showresult;
 273 ( 6632)   bx:=2.0; by:=conv(nfloors*vfloors+1);
 274 ( 6652)   bxs:=bx; bys:=by;
 275 ( 6671)   bxspeed:=2.0; byspeed:=0.0;
 276 ( 6701)   fx:=1.0; fy:=1; jump:=0.0;  jumpspeed:=0.0;
 277 ( 6743)   fxs:=fx; fys:=fy;
 278 ( 6761)   fxspeed:=0.0; fyspeed:=0;
 279 ( 6783)   { make and show holes }
 280 ( 6787)   holes[0]:=-50;
 281 ( 6791)   move(0,0); draw(xsize,0,white);
 282 ( 6818)   for floor:=1 to nfloors do begin
 283 ( 6835)     holes[floor]:=irandom(1,xsize-holesize-1);
 284 ( 6857)     move(0,floor*vfloors);
 285 ( 6876)     draw(xsize-1,floor*vfloors,white);
 286 ( 6896)     move(holes[floor],floor*vfloors);

----------------------------------------------------------------------

R65 COMPILE 4.3: program LADDERS          21/2/24 page 6

 287 ( 6917)     draw(holes[floor]+holesize,floor*vfloors,black);
 288 ( 6943)   end;
 289 ( 6943)   { make and show ladders }
 290 ( 6957)   for floor:=0 to nfloors-1 do begin
 291 ( 6977)     repeat
 292 ( 6977)       ladders[floor]:=irandom(2,xsize-laddersize-2);
 293 ( 6999)     until ((ladders[floor]+laddersize<holes[floor])
 294 ( 7018)       or (ladders[floor]>holes[floor]+holesize)) and
 295 ( 7044)       ((ladders[floor]+laddersize<holes[floor+1])
 296 ( 7062)       or (ladders[floor]>holes[floor+1]+holesize));
 297 ( 7091)       showladder(floor);
 298 ( 7105)   end;
 299 ( 7105)   ladders[nfloors]:=-laddersize;
 300 ( 7123)   floor:=nfloors;
 301 ( 7130)   ffloor:=0;
 302 ( 7136) end;
 303 ( 7140) 
 304 ( 7141) {$I IANIMATE:P}
IANIMATE:P      .0C  SP 0000-0400 0004 12/02/24
{I}    1 ( 7141) { ianimate - run animation in loop
{I}    2 ( 7141)   proc expaint;
{I}    3 ( 7141)     Called to paint one picture and apply motion.
{I}    4 ( 7141)   func exkey(ch:char):boolean;
{I}    5 ( 7141)     Called to check for key and stop loop if true  }
{I}    6 ( 7141) 
{I}    7 ( 7141) proc animate(arepeat:boolean);
{I}    8 ( 7141) { arepeat: auto repeat cursor keys without delay }
{I}    9 ( 7141) const toggle=chr($0c);
{I}   10 ( 7144)       cleft=chr($03); cright=chr($16);
{I}   11 ( 7144)       cup=chr($1a); cdown=chr($18); esc=chr(0);
{I}   12 ( 7144) mem   sflag=$1781:integer&;
{I}   13 ( 7144)       emuflags=$1707:integer&;
{I}   14 ( 7144) var   ch:char;
{I}   15 ( 7144)       dummy:integer;
{I}   16 ( 7144)       stop:boolean;
{I}   17 ( 7144) begin
{I}   18 ( 7144)   repeat
{I}   19 ( 7144)     repeat
{I}   20 ( 7146)       stop:=expaint;
{I}   21 ( 7152)       dummy:=syncscreen; { sleep for up to 30 msec }
{I}   22 ( 7166)       ch:=keypressed; { sleep for 10 msec }
{I}   23 ( 7174)       { sflag bit 8 is escape flag. Pass it through }
{I}   24 ( 7174)     until (ord(ch)<>0) or ((sflag and $80)<>0)
{I}   25 ( 7190)       or stop;
{I}   26 ( 7192)     if not(((ch=cup) or (ch=cdown) or (ch=cleft) or
{I}   27 ( 7222)        (ch=cright)) and
{I}   28 ( 7231)        ((emuflags and 1)<>0) and arepeat) then
{I}   29 ( 7247)        { cursor keys auto repeat without delay }
{I}   30 ( 7248)        keypressed := chr(0);
{I}   31 ( 7253)     sflag:=sflag and $7f; { clear escape flag }
{I}   32 ( 7271)     if ch=toggle then write(toggle);
{I}   33 ( 7284)   until exkey(ch) or stop;
{I}   34 ( 7296) end;
 305 ( 7305) 
 306 ( 7305) begin
 307 ( 7305)   score:=0; count:=0;
 308 ( 7315)   demomode:=getoption('D');
 309 ( 7329)   if demomode then writeln('Demo mode');
 310 ( 7356)   grinit; fullview;
 311 ( 7364)   init;
 312 ( 7368)   animate(autorepeat);

----------------------------------------------------------------------

R65 COMPILE 4.3: program LADDERS          21/2/24 page 7

 313 ( 7376)   splitview;
 314 ( 7380)   showresult;
 315 ( 7384)   writeln('Score ',score,' of ',count);
 316 ( 7412) end.

End compile

Code lenght:          7411
Compiler stack size:  134
Ident stack size:     194
Pascal errors:        0
