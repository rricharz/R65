
R65 COMPILE 4.3: program LADDERS          21/2/24 page 1


   1 (    4) { ladders: climb up the ladders
   2 (    4) 
   3 (    4)   Demo mode: ladders /D
   4 (    4) 
   5 (    4)   2024 rricharz                      }
   6 (    4) 
   7 (    4) program ladders;
   8 (    4) uses syslib,plotlib,ledlib,arglib,strlib;
   9 ( 3780) 
  10 ( 3780) const erase=0; ball=$6ff6;
  11 ( 3783)       nfloors=5; vfloors=20; holesize=22;
  12 ( 3783)       gravity=-0.25; reflection=-0.7;
  13 ( 3783)       laddersize=8; autorepeat=false;
  14 ( 3783)       cleft=chr($03); cright=chr($16);
  15 ( 3783)       cup=chr($1a); cdown=chr($18); esc=chr(0);
  16 ( 3783)       face1=$8b43; face2=$2a48;
  17 ( 3783)       face3=$034a; face4=$084a;
  18 ( 3783) 
  19 ( 3783) var bx,by,bxs,bys,bxspeed,byspeed,fx,fxs: real;
  20 ( 3783)     fxspeed,jump,jumpspeed: real;
  21 ( 3783)     floor,ffloor,fy,fys,fyspeed: integer;
  22 ( 3783)     holes,ladders: array[nfloors] of integer;
  23 ( 3783)     score,count: integer;
  24 ( 3783)     demomode:boolean;
  25 ( 3783) 
  26 ( 3783) {$I IRANDOM:P}
IRANDOM:P       .02  SP 0000-0200 0002 12/02/24
{I}    1 ( 3783) { irandom: real and integer random functions with limit
{I}    2 ( 3783) }
{I}    3 ( 3783) 
{I}    4 ( 3783) func rrandom(min,max:real):real;
{I}    5 ( 3783) begin
{I}    6 ( 3783)   rrandom := min + (conv(random)/255.0) * (max - min);
{I}    7 ( 3821) end;
{I}    8 ( 3829) 
{I}    9 ( 3830) func irandom(min,max:integer):integer;
{I}   10 ( 3830) begin
{I}   11 ( 3830)   irandom := trunc(rrandom(conv(min),conv(max)));
{I}   12 ( 3853) end;
{I}   13 ( 3858) 
  27 ( 3859) 
  28 ( 3859) func getoption(opt:char):boolean;
  29 ( 3859) var i,dummy,savecarg:integer;
  30 ( 3862)     options:array[15] of char;
  31 ( 3862)     default:boolean;
  32 ( 3862) begin
  33 ( 3862)   savecarg:=carg; { save for next call to getoption }
  34 ( 3872)   agetstring(options,default,dummy,dummy);
  35 ( 3912)   getoption:=false;
  36 ( 3914)   if not default then begin
  37 ( 3923)     if options[0]<>'/' then argerror(103);
  38 ( 3946)     for i:=1 to 15 do
  39 ( 3954)       if options[i]=opt then getoption:=true;
  40 ( 3981)   end;
  41 ( 3999)   carg:=savecarg;
  42 ( 3999) end;
  43 ( 4007) 
  44 ( 4008) func onfloor(f,y:integer):boolean;
  45 ( 4008) begin
  46 ( 4008)   onfloor:=(f*vfloors+1=y);

----------------------------------------------------------------------

R65 COMPILE 4.3: program LADDERS          21/2/24 page 2

  47 ( 4028) end;
  48 ( 4032) 
  49 ( 4033) func onupladder(f:integer;x:real):boolean;
  50 ( 4033) begin
  51 ( 4033)   onupladder:=(trunc(x)>=ladders[f]+1) and
  52 ( 4057)     (trunc(x)<=ladders[f]+2);
  53 ( 4076) end;
  54 ( 4081) 
  55 ( 4082) func ondownladder(f:integer;x:real):boolean;
  56 ( 4082) begin
  57 ( 4082)   if f=0 then ondownladder:=false
  58 ( 4097)   else ondownladder:=(trunc(x)>=ladders[f-1]+1) and
  59 ( 4128)     (trunc(x+0.5)<=ladders[f-1]+2);
  60 ( 4157) end;
  61 ( 4162) 
  62 ( 4163) func onhole(f:integer;x:real):boolean;
  63 ( 4163) begin
  64 ( 4163)   onhole:=(x>=conv(holes[f]-5)) and
  65 ( 4187)       (x<=conv(holes[f]+holesize+1));
  66 ( 4209) end;
  67 ( 4214) 
  68 ( 4215) proc showface;
  69 ( 4215) var fysum:integer;
  70 ( 4218) begin
  71 ( 4218)   fysum:=fy+trunc(jump);
  72 ( 4230)   plotmap(trunc(fxs),fys,erase);
  73 ( 4255)   plotmap(trunc(fxs)+4,fys,erase);
  74 ( 4277)   plotmap(trunc(fxs),fys+4,erase);
  75 ( 4299)   plotmap(trunc(fxs)+4,fys+4,erase);
  76 ( 4324)   plotmap(trunc(fx),fysum,face1);
  77 ( 4344)   plotmap(trunc(fx)+4,fysum,face2);
  78 ( 4367)   plotmap(trunc(fx),fysum+4,face3);
  79 ( 4390)   plotmap(trunc(fx)+4,fysum+4,face4);
  80 ( 4416)   fxs:=fx; fys:=fysum;
  81 ( 4428) end;
  82 ( 4436) 
  83 ( 4437) proc showladder(f:integer);
  84 ( 4437) var i,x1,x2,y1,y2:integer;
  85 ( 4440) begin
  86 ( 4440)   if f<nfloors then begin
  87 ( 4449)     x1:=ladders[f]; x2:=x1+laddersize;
  88 ( 4470)     y1:=f*vfloors+1; y2:=y1+vfloors-1;
  89 ( 4498)     move(x1,y1); draw(x1,y2,white);
  90 ( 4533)     move(x2,y1); draw(x2,y2,white);
  91 ( 4563)     i:=1;
  92 ( 4565)     for i:=1 to 5 do begin
  93 ( 4586)       move(x1,y1+4*i-1); draw(x2,y1+4*i-1,white);
  94 ( 4638)     end;
  95 ( 4638)   end;
  96 ( 4652) end;
  97 ( 4652) 
  98 ( 4653) proc init; forward;
  99 ( 4656) 
 100 ( 4656) proc showresult;
 101 ( 4656) var s:cpnt;
 102 ( 4659) begin
 103 ( 4659)   s:=new;
 104 ( 4667)   write(@s,score,' 0F ',count);
 105 ( 4692)   ledstring(s);
 106 ( 4702)   release(s);

----------------------------------------------------------------------

R65 COMPILE 4.3: program LADDERS          21/2/24 page 3

 107 ( 4712) end;
 108 ( 4712) 
 109 ( 4713) proc ladderup;
 110 ( 4713) begin
 111 ( 4713)   if (ffloor<nfloors) and onupladder(ffloor,fx)
 112 ( 4731)   then begin
 113 ( 4744)     fx:=conv(ladders[ffloor]+1);
 114 ( 4758)     fyspeed:=1; fxspeed:=0.0;
 115 ( 4777)   end;
 116 ( 4783) end;
 117 ( 4783) 
 118 ( 4784) func expaint: boolean;
 119 ( 4784) { paint picture and apply motion }
 120 ( 4784) var f:integer;
 121 ( 4787)     s:cpnt;
 122 ( 4787) begin
 123 ( 4787)   if demomode then begin
 124 ( 4793)     if ffloor=nfloors then fxspeed:=2.0
 125 ( 4806)     else if (ffloor<nfloors) and onupladder(ffloor,fx)
 126 ( 4834)     then ladderup
 127 ( 4847)     else if onfloor(ffloor,fy) then  begin
 128 ( 4873)       if (trunc(fx)>=ladders[ffloor]+laddersize div 2)
 129 ( 4895)       then begin
 130 ( 4898)         if fxspeed>1.0 then fxspeed:=0.0
 131 ( 4917)         else fxspeed:=-2.0;
 132 ( 4938)       end else begin
 133 ( 4948)         if fxspeed<-1.0 then fxspeed:=0.0
 134 ( 4965)         else fxspeed:=2.0
 135 ( 4980)       end;
 136 ( 4992)     end;
 137 ( 4992)   end;
 138 ( 4992) 
 139 ( 4992)   expaint:=false;
 140 ( 4994)   if (ffloor=nfloors) and (trunc(fx)>xsize-10) then
 141 ( 5018)   begin
 142 ( 5019)     score:=score+1; count:=count+1;
 143 ( 5039)     if count>=10 then begin
 144 ( 5051)       expaint:=true; exit;
 145 ( 5061)     end;
 146 ( 5061)     fx:=1.0; fy:=1; fxspeed:=0.0; ffloor:=0;
 147 ( 5093)     showresult;
 148 ( 5101)     exit;
 149 ( 5102)   end;
 150 ( 5102)   { check for next floor on ladder }
 151 ( 5102)   if ffloor<nfloors then
 152 ( 5108)     if onfloor(ffloor+1,fy) then begin
 153 ( 5131)       ffloor:=ffloor+1; fyspeed:=0;
 154 ( 5147)     end;
 155 ( 5151)   if ffloor>0 then
 156 ( 5157)     if onfloor(ffloor-1,fy) then begin
 157 ( 5180)       ffloor:=ffloor-1; fyspeed:=0;
 158 ( 5196)     end;
 159 ( 5200)   { paint face }
 160 ( 5200)   showface;
 161 ( 5204)   { paint ball }
 162 ( 5204)   plotmap(trunc(bxs),trunc(bys),erase);
 163 ( 5226)   plotmap(trunc(bx),trunc(by),ball);
 164 ( 5249)   for f:=0 to nfloors-1 do showladder(f);
 165 ( 5279)   bxs:=bx; bys:=by;
 166 ( 5305)   { move face }

----------------------------------------------------------------------

R65 COMPILE 4.3: program LADDERS          21/2/24 page 4

 167 ( 5317)   fx:=fx+fxspeed; fy:=fy+fyspeed;
 168 ( 5340)   if fx>conv(xsize-8) then begin
 169 ( 5362)     fx:=conv(xsize-8); fxspeed:=0.0;
 170 ( 5383)   end;
 171 ( 5389)   if (fx<1.0) then begin
 172 ( 5402)     fx:=1.0; fxspeed:=-0.0;
 173 ( 5423)   end;
 174 ( 5430)   { check for ladder }
 175 ( 5430)   if onupladder(ffloor,fx) or ondownladder(ffloor,fx)
 176 ( 5454)     then fxspeed:=0.0;
 177 ( 5476)   { check for hole (face) and jump over it }
 178 ( 5482)   if (jump<=0.01) and onhole(ffloor,fx) then begin
 179 ( 5514)     jumpspeed:=1.3; jump:=jump+jumpspeed;
 180 ( 5535)   end else if jump>0.0 then begin
 181 ( 5564)     jump:=jump+jumpspeed;
 182 ( 5573)     jumpspeed:=jumpspeed+gravity;
 183 ( 5598)   end;
 184 ( 5605)   if jump<=0.0 then jump:=0.0;
 185 ( 5627)   { move ball }
 186 ( 5633)   bx:=bx+bxspeed; by:=by+byspeed;
 187 ( 5658)   { check for borders }
 188 ( 5671)   if bx>=conv(xsize-4) then begin
 189 ( 5684)     bx:=conv(xsize-4); bxspeed:=-bxspeed;
 190 ( 5699)   end else if bx<2.0 then begin
 191 ( 5728)     bx:=2.0; bxspeed:=-bxspeed;
 192 ( 5743)   end;
 193 ( 5756)   { check for reflection on ceiling }
 194 ( 5756)   if by>=conv((floor+1)*vfloors-4) then begin
 195 ( 5777)     by:=conv((floor+1)*vfloors-4);
 196 ( 5793)     byspeed:=reflection*byspeed;
 197 ( 5806)   end;
 198 ( 5819)   { check for hole (ball) }
 199 ( 5819)   if (bx>=conv(holes[floor])) and
 200 ( 5835)       (bx<=conv(holes[floor]+holesize-4)) and
 201 ( 5857)      (by<=conv(floor*vfloors+1)) then begin
 202 ( 5877)      { fall through hole }
 203 ( 5880)     byspeed:=byspeed+gravity;
 204 ( 5892)     if floor>0 then floor:=floor-1;
 205 ( 5915)   end else if by<conv(floor*vfloors+1) then begin
 206 ( 5941)     { reflection on floor }
 207 ( 5944)     by:=conv(floor*vfloors+2); { jump a bit }
 208 ( 5961)     byspeed:=reflection*byspeed;
 209 ( 5967)   end else
 210 ( 5980)     byspeed:=byspeed+gravity;
 211 ( 5995)   { check for border on bottom floor }
 212 ( 6002)   if (by<4.0) and ((bx<=2.0) or (bx>=conv(xsize-4)))
 213 ( 6041)   then begin
 214 ( 6043)     if bx<2.0 then bx:=2.0
 215 ( 6062)     else if bx>=conv(xsize-4) then bx:=conv(xsize-4);
 216 ( 6098)     by:=conv(nfloors*vfloors+1);
 217 ( 6113)     byspeed:=0.0; floor:=nfloors;
 218 ( 6134)   end;
 219 ( 6138)   { check for hit }
 220 ( 6138)   if (bx>=fx-4.0) and (bx<=fx+8.0) and
 221 ( 6178)      (trunc(by)>=fy-4) and (trunc(by)<=fy+8)
 222 ( 6208)     then begin
 223 ( 6211)       count:=count+1;
 224 ( 6220)       showresult;
 225 ( 6229)       if demomode and (count>=99) then begin
 226 ( 6241)         count:=0; score:=0;

----------------------------------------------------------------------

R65 COMPILE 4.3: program LADDERS          21/2/24 page 5

 227 ( 6252)       end;
 228 ( 6256)       if (not demomode) and (count>=10) then
 229 ( 6268)         expaint:=true;
 230 ( 6274)       init;
 231 ( 6282)     end;
 232 ( 6282) end;
 233 ( 6282) 
 234 ( 6283) proc ladderup;
 235 ( 6283) begin
 236 ( 6283)   if (ffloor<nfloors) and onupladder(ffloor,fx)
 237 ( 6301)   then begin
 238 ( 6314)     fx:=conv(ladders[ffloor]+1);
 239 ( 6328)     fyspeed:=1; fxspeed:=0.0;
 240 ( 6347)   end;
 241 ( 6353) end;
 242 ( 6353) 
 243 ( 6354) proc ladderdown;
 244 ( 6354) begin
 245 ( 6354)   if (ffloor>0) and ondownladder(ffloor,fx)
 246 ( 6372)   then begin
 247 ( 6385)     fx:=conv(ladders[ffloor-1]+1);
 248 ( 6402)     fyspeed:=-1; fxspeed:=0.0;
 249 ( 6422)   end;
 250 ( 6428) end;
 251 ( 6428) 
 252 ( 6429) func exkey(key:char):boolean;
 253 ( 6429) { check for key typed }
 254 ( 6429) begin
 255 ( 6429)   exkey:=(key=esc);
 256 ( 6441)   case key of
 257 ( 6445)    cup:    ladderup;
 258 ( 6460)    cdown:  ladderdown;
 259 ( 6474)    cleft:  if onfloor(ffloor,fy) then
 260 ( 6500)              if fxspeed>1.0 then fxspeed:=0.0
 261 ( 6519)              else fxspeed:=-2.0;
 262 ( 6540)    cright: if onfloor(ffloor,fy) then
 263 ( 6573)              if fxspeed<-1.0 then fxspeed:=0.0
 264 ( 6593)              else fxspeed:=2.0
 265 ( 6608)    end {case};
 266 ( 6622) end;
 267 ( 6622) 
 268 ( 6623) proc init;
 269 ( 6623) begin
 270 ( 6623)   cleargr;
 271 ( 6632)   showresult;
 272 ( 6636)   bx:=2.0; by:=conv(nfloors*vfloors+1);
 273 ( 6656)   bxs:=bx; bys:=by;
 274 ( 6675)   bxspeed:=2.0; byspeed:=0.0;
 275 ( 6705)   fx:=1.0; fy:=1; jump:=0.0;  jumpspeed:=0.0;
 276 ( 6747)   fxs:=fx; fys:=fy;
 277 ( 6765)   fxspeed:=0.0; fyspeed:=0;
 278 ( 6787)   { make and show holes }
 279 ( 6791)   holes[0]:=-50;
 280 ( 6795)   move(0,0); draw(xsize,0,white);
 281 ( 6822)   for floor:=1 to nfloors do begin
 282 ( 6839)     holes[floor]:=irandom(1,xsize-holesize-1);
 283 ( 6861)     move(0,floor*vfloors);
 284 ( 6880)     draw(xsize-1,floor*vfloors,white);
 285 ( 6900)     move(holes[floor],floor*vfloors);
 286 ( 6921)     draw(holes[floor]+holesize,floor*vfloors,black);

----------------------------------------------------------------------

R65 COMPILE 4.3: program LADDERS          21/2/24 page 6

 287 ( 6947)   end;
 288 ( 6947)   { make and show ladders }
 289 ( 6961)   for floor:=0 to nfloors-1 do begin
 290 ( 6981)     repeat
 291 ( 6981)       ladders[floor]:=irandom(2,xsize-laddersize-2);
 292 ( 7003)     until ((ladders[floor]+laddersize<holes[floor])
 293 ( 7022)       or (ladders[floor]>holes[floor]+holesize)) and
 294 ( 7048)       ((ladders[floor]+laddersize<holes[floor+1])
 295 ( 7066)       or (ladders[floor]>holes[floor+1]+holesize));
 296 ( 7095)       showladder(floor);
 297 ( 7109)   end;
 298 ( 7109)   ladders[nfloors]:=-laddersize;
 299 ( 7127)   floor:=nfloors;
 300 ( 7134)   ffloor:=0;
 301 ( 7140) end;
 302 ( 7144) 
 303 ( 7145) {$I IANIMATE:P}
IANIMATE:P      .0C  SP 0000-0400 0004 12/02/24
{I}    1 ( 7145) { ianimate - run animation in loop
{I}    2 ( 7145)   proc expaint;
{I}    3 ( 7145)     Called to paint one picture and apply motion.
{I}    4 ( 7145)   func exkey(ch:char):boolean;
{I}    5 ( 7145)     Called to check for key and stop loop if true  }
{I}    6 ( 7145) 
{I}    7 ( 7145) proc animate(arepeat:boolean);
{I}    8 ( 7145) { arepeat: auto repeat cursor keys without delay }
{I}    9 ( 7145) const toggle=chr($0c);
{I}   10 ( 7148)       cleft=chr($03); cright=chr($16);
{I}   11 ( 7148)       cup=chr($1a); cdown=chr($18); esc=chr(0);
{I}   12 ( 7148) mem   sflag=$1781:integer&;
{I}   13 ( 7148)       emuflags=$1707:integer&;
{I}   14 ( 7148) var   ch:char;
{I}   15 ( 7148)       dummy:integer;
{I}   16 ( 7148)       stop:boolean;
{I}   17 ( 7148) begin
{I}   18 ( 7148)   repeat
{I}   19 ( 7148)     repeat
{I}   20 ( 7150)       stop:=expaint;
{I}   21 ( 7156)       dummy:=syncscreen; { sleep for up to 30 msec }
{I}   22 ( 7170)       ch:=keypressed; { sleep for 10 msec }
{I}   23 ( 7178)       { sflag bit 8 is escape flag. Pass it through }
{I}   24 ( 7178)     until (ord(ch)<>0) or ((sflag and $80)<>0)
{I}   25 ( 7194)       or stop;
{I}   26 ( 7196)     if not(((ch=cup) or (ch=cdown) or (ch=cleft) or
{I}   27 ( 7226)        (ch=cright)) and
{I}   28 ( 7235)        ((emuflags and 1)<>0) and arepeat) then
{I}   29 ( 7251)        { cursor keys auto repeat without delay }
{I}   30 ( 7252)        keypressed := chr(0);
{I}   31 ( 7257)     sflag:=sflag and $7f; { clear escape flag }
{I}   32 ( 7275)     if ch=toggle then write(toggle);
{I}   33 ( 7288)   until exkey(ch) or stop;
{I}   34 ( 7300) end;
 304 ( 7309) 
 305 ( 7309) begin
 306 ( 7309)   score:=0; count:=0;
 307 ( 7319)   demomode:=getoption('D');
 308 ( 7333)   if demomode then writeln('demo mode');
 309 ( 7360)   grinit; fullview;
 310 ( 7368)   init;
 311 ( 7372)   animate(autorepeat);
 312 ( 7380)   splitview;

----------------------------------------------------------------------

R65 COMPILE 4.3: program LADDERS          21/2/24 page 7

 313 ( 7384)   showresult;
 314 ( 7388)   writeln('Score ',score,' of ',count);
 315 ( 7416) end.

End compile

Code lenght:          7415
Compiler stack size:  134
Ident stack size:     194
Pascal errors:        0
