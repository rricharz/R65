
R65 COMPILE 4.3: program LADDERS          27/2/24 page 1


   1 (    4) { ladders: climb up the ladders
   2 (    4) 
   3 (    4)   Demo mode: ladders /D
   4 (    4) 
   5 (    4)   2024 rricharz                      }
   6 (    4) 
   7 (    4) program ladders;
   8 (    4) uses syslib,plotlib,ledlib,arglib,strlib;
   9 ( 3780) 
  10 ( 3780) const erase=0; ball=$6ff6;
  11 ( 3783)       nfloors=5; vfloors=20; holesize=22;
  12 ( 3783)       gravity=-0.25; reflection=-0.7;
  13 ( 3783)       laddersize=8; autorepeat=false;
  14 ( 3783)       cleft=chr($03); cright=chr($16);
  15 ( 3783)       cup=chr($1a); cdown=chr($18); esc=chr(0);
  16 ( 3783)       face1=$8b43; face2=$2a48;
  17 ( 3783)       face3=$034a; face4=$084a;
  18 ( 3783) 
  19 ( 3783) var bx,by,bxs,bys,bxspeed,byspeed,fx,fxs: real;
  20 ( 3783)     fxspeed,jump,jumpspeed: real;
  21 ( 3783)     floor,ffloor,fy,fys,fyspeed: integer;
  22 ( 3783)     holes,ladders: array[nfloors] of integer;
  23 ( 3783)     score,count: integer;
  24 ( 3783)     demomode:boolean;
  25 ( 3783) 
  26 ( 3783) {$I IRANDOM:P}
IRANDOM:P       .02  SP 0000-0200 0002 12/02/24
{I}    1 ( 3783) { irandom: real and integer random functions with limit
{I}    2 ( 3783) }
{I}    3 ( 3783) 
{I}    4 ( 3783) func rrandom(min,max:real):real;
{I}    5 ( 3783) begin
{I}    6 ( 3783)   rrandom := min + (conv(random)/255.0) * (max - min);
{I}    7 ( 3821) end;
{I}    8 ( 3829) 
{I}    9 ( 3830) func irandom(min,max:integer):integer;
{I}   10 ( 3830) begin
{I}   11 ( 3830)   irandom := trunc(rrandom(conv(min),conv(max)));
{I}   12 ( 3853) end;
{I}   13 ( 3858) 
  27 ( 3859) {$I IOPTION:P}
IOPTION:P       .02  SP 0000-0200 00F2 22/02/24
{I}    1 ( 3859) { ioption - check and set option }
{I}    2 ( 3859) 
{I}    3 ( 3859) func option(opt:char):boolean;
{I}    4 ( 3859) var i,dummy,savecarg:integer;
{I}    5 ( 3862)     options:array[15] of char;
{I}    6 ( 3862)     default:boolean;
{I}    7 ( 3862) begin
{I}    8 ( 3862)   savecarg:=carg; { save for next call to option }
{I}    9 ( 3872)   agetstring(options,default,dummy,dummy);
{I}   10 ( 3912)   option:=false;
{I}   11 ( 3914)   if not default then begin
{I}   12 ( 3923)     if options[0]<>'/' then argerror(103);
{I}   13 ( 3946)     for i:=1 to 15 do
{I}   14 ( 3954)       if options[i]=opt then option:=true;
{I}   15 ( 3981)   end;
{I}   16 ( 3999)   carg:=savecarg;
{I}   17 ( 3999) end;
  28 ( 4008) 
  29 ( 4008) func getoption(opt:char):boolean;

----------------------------------------------------------------------

R65 COMPILE 4.3: program LADDERS          27/2/24 page 2

  30 ( 4008) var i,dummy,savecarg:integer;
  31 ( 4011)     options:array[15] of char;
  32 ( 4011)     default:boolean;
  33 ( 4011) begin
  34 ( 4011)   savecarg:=carg; { save for next call to getoption }
  35 ( 4021)   agetstring(options,default,dummy,dummy);
  36 ( 4061)   getoption:=false;
  37 ( 4063)   if not default then begin
  38 ( 4072)     if options[0]<>'/' then argerror(103);
  39 ( 4095)     for i:=1 to 15 do
  40 ( 4103)       if options[i]=opt then getoption:=true;
  41 ( 4130)   end;
  42 ( 4148)   carg:=savecarg;
  43 ( 4148) end;
  44 ( 4156) 
  45 ( 4157) func onfloor(f,y:integer):boolean;
  46 ( 4157) begin
  47 ( 4157)   onfloor:=(f*vfloors+1=y);
  48 ( 4177) end;
  49 ( 4181) 
  50 ( 4182) func onupladder(f:integer;x:real):boolean;
  51 ( 4182) begin
  52 ( 4182)   onupladder:=(trunc(x)>=ladders[f]+1) and
  53 ( 4206)     (trunc(x)<=ladders[f]+2);
  54 ( 4225) end;
  55 ( 4230) 
  56 ( 4231) func ondownladder(f:integer;x:real):boolean;
  57 ( 4231) begin
  58 ( 4231)   if f=0 then ondownladder:=false
  59 ( 4246)   else ondownladder:=(trunc(x)>=ladders[f-1]+1) and
  60 ( 4277)     (trunc(x+0.5)<=ladders[f-1]+2);
  61 ( 4306) end;
  62 ( 4311) 
  63 ( 4312) func onhole(f:integer;x:real):boolean;
  64 ( 4312) begin
  65 ( 4312)   onhole:=(x>=conv(holes[f]-5)) and
  66 ( 4336)       (x<=conv(holes[f]+holesize+1));
  67 ( 4358) end;
  68 ( 4363) 
  69 ( 4364) proc showface;
  70 ( 4364) var fysum:integer;
  71 ( 4367) begin
  72 ( 4367)   fysum:=fy+trunc(jump);
  73 ( 4379)   plotmap(trunc(fxs),fys,erase);
  74 ( 4404)   plotmap(trunc(fxs)+4,fys,erase);
  75 ( 4426)   plotmap(trunc(fxs),fys+4,erase);
  76 ( 4448)   plotmap(trunc(fxs)+4,fys+4,erase);
  77 ( 4473)   plotmap(trunc(fx),fysum,face1);
  78 ( 4493)   plotmap(trunc(fx)+4,fysum,face2);
  79 ( 4516)   plotmap(trunc(fx),fysum+4,face3);
  80 ( 4539)   plotmap(trunc(fx)+4,fysum+4,face4);
  81 ( 4565)   fxs:=fx; fys:=fysum;
  82 ( 4577) end;
  83 ( 4585) 
  84 ( 4586) proc showladder(f:integer);
  85 ( 4586) var i,x1,x2,y1,y2:integer;
  86 ( 4589) begin
  87 ( 4589)   if f<nfloors then begin
  88 ( 4598)     x1:=ladders[f]; x2:=x1+laddersize;
  89 ( 4619)     y1:=f*vfloors+1; y2:=y1+vfloors-1;

----------------------------------------------------------------------

R65 COMPILE 4.3: program LADDERS          27/2/24 page 3

  90 ( 4647)     move(x1,y1); draw(x1,y2,white);
  91 ( 4682)     move(x2,y1); draw(x2,y2,white);
  92 ( 4712)     i:=1;
  93 ( 4714)     for i:=1 to 5 do begin
  94 ( 4735)       move(x1,y1+4*i-1); draw(x2,y1+4*i-1,white);
  95 ( 4787)     end;
  96 ( 4787)   end;
  97 ( 4801) end;
  98 ( 4801) 
  99 ( 4802) proc init; forward;
 100 ( 4805) 
 101 ( 4805) proc showresult;
 102 ( 4805) var s:cpnt;
 103 ( 4808) begin
 104 ( 4808)   s:=new;
 105 ( 4816)   write(@s,' ',score,' 0F ',count);
 106 ( 4843)   ledstring(s);
 107 ( 4853)   release(s);
 108 ( 4863) end;
 109 ( 4863) 
 110 ( 4864) proc ladderup;
 111 ( 4864) begin
 112 ( 4864)   if (ffloor<nfloors) and onupladder(ffloor,fx)
 113 ( 4882)   then begin
 114 ( 4895)     fx:=conv(ladders[ffloor]+1);
 115 ( 4909)     fyspeed:=1; fxspeed:=0.0;
 116 ( 4928)   end;
 117 ( 4934) end;
 118 ( 4934) 
 119 ( 4935) func expaint: boolean;
 120 ( 4935) { paint picture and apply motion }
 121 ( 4935) var f:integer;
 122 ( 4938)     s:cpnt;
 123 ( 4938) begin
 124 ( 4938)   if demomode then begin
 125 ( 4944)     if ffloor=nfloors then fxspeed:=2.0
 126 ( 4957)     else if (ffloor<nfloors) and onupladder(ffloor,fx)
 127 ( 4985)     then ladderup
 128 ( 4998)     else if onfloor(ffloor,fy) then  begin
 129 ( 5024)       if (trunc(fx)>=ladders[ffloor]+1) then begin
 130 ( 5046)         if fxspeed>1.0 then fxspeed:=0.0
 131 ( 5065)         else fxspeed:=-2.0;
 132 ( 5086)       end else begin
 133 ( 5096)         if fxspeed<-1.0 then fxspeed:=0.0
 134 ( 5113)         else fxspeed:=2.0
 135 ( 5128)       end;
 136 ( 5140)     end;
 137 ( 5140)   end;
 138 ( 5140) 
 139 ( 5140)   expaint:=false;
 140 ( 5142)   if (ffloor=nfloors) and (trunc(fx)>xsize-10) then
 141 ( 5166)   begin
 142 ( 5167)     score:=score+1; count:=count+1;
 143 ( 5187)     if count>=10 then begin
 144 ( 5199)       if demomode then begin
 145 ( 5206)         score:=0; count:=0; init;
 146 ( 5225)       end else begin
 147 ( 5228)         expaint:=true; exit;
 148 ( 5235)       end;
 149 ( 5235)     end;

----------------------------------------------------------------------

R65 COMPILE 4.3: program LADDERS          27/2/24 page 4

 150 ( 5235)     init;
 151 ( 5239)     fx:=1.0; fy:=1; fxspeed:=0.0; ffloor:=0;
 152 ( 5271)     showresult;
 153 ( 5279)     exit;
 154 ( 5280)   end;
 155 ( 5280)   { check for next floor on ladder }
 156 ( 5280)   if ffloor<nfloors then
 157 ( 5286)     if onfloor(ffloor+1,fy) then begin
 158 ( 5309)       ffloor:=ffloor+1; fyspeed:=0;
 159 ( 5325)     end;
 160 ( 5329)   if ffloor>0 then
 161 ( 5335)     if onfloor(ffloor-1,fy) then begin
 162 ( 5358)       ffloor:=ffloor-1; fyspeed:=0;
 163 ( 5374)     end;
 164 ( 5378)   { paint face }
 165 ( 5378)   showface;
 166 ( 5382)   { paint ball }
 167 ( 5382)   plotmap(trunc(bxs),trunc(bys),erase);
 168 ( 5404)   plotmap(trunc(bx),trunc(by),ball);
 169 ( 5427)   for f:=0 to nfloors-1 do showladder(f);
 170 ( 5457)   bxs:=bx; bys:=by;
 171 ( 5483)   { move face }
 172 ( 5495)   fx:=fx+fxspeed; fy:=fy+fyspeed;
 173 ( 5518)   if fx>conv(xsize-8) then begin
 174 ( 5540)     fx:=conv(xsize-8); fxspeed:=0.0;
 175 ( 5561)   end;
 176 ( 5567)   if (fx<1.0) then begin
 177 ( 5580)     fx:=1.0; fxspeed:=-0.0;
 178 ( 5601)   end;
 179 ( 5608)   { check for ladder }
 180 ( 5608)   if onupladder(ffloor,fx) or ondownladder(ffloor,fx)
 181 ( 5632)     then fxspeed:=0.0;
 182 ( 5654)   { check for hole (face) and jump over it }
 183 ( 5660)   if (jump<=0.01) and onhole(ffloor,fx) then begin
 184 ( 5692)     jumpspeed:=1.3; jump:=jump+jumpspeed;
 185 ( 5713)   end else if jump>0.0 then begin
 186 ( 5742)     jump:=jump+jumpspeed;
 187 ( 5751)     jumpspeed:=jumpspeed+gravity;
 188 ( 5776)   end;
 189 ( 5783)   if jump<=0.0 then jump:=0.0;
 190 ( 5805)   { move ball }
 191 ( 5811)   bx:=bx+bxspeed; by:=by+byspeed;
 192 ( 5836)   { check for borders }
 193 ( 5849)   if bx>=conv(xsize-4) then begin
 194 ( 5862)     bx:=conv(xsize-4); bxspeed:=-bxspeed;
 195 ( 5877)   end else if bx<2.0 then begin
 196 ( 5906)     bx:=2.0; bxspeed:=-bxspeed;
 197 ( 5921)   end;
 198 ( 5934)   { check for reflection on ceiling }
 199 ( 5934)   if by>=conv((floor+1)*vfloors-4) then begin
 200 ( 5955)     by:=conv((floor+1)*vfloors-4);
 201 ( 5971)     byspeed:=reflection*byspeed;
 202 ( 5984)   end;
 203 ( 5997)   { check for hole (ball) }
 204 ( 5997)   if (bx>=conv(holes[floor])) and
 205 ( 6013)       (bx<=conv(holes[floor]+holesize-4)) and
 206 ( 6035)      (by<=conv(floor*vfloors+1)) then begin
 207 ( 6055)      { fall through hole }
 208 ( 6058)     byspeed:=byspeed+gravity;
 209 ( 6070)     if floor>0 then floor:=floor-1;

----------------------------------------------------------------------

R65 COMPILE 4.3: program LADDERS          27/2/24 page 5

 210 ( 6093)   end else if by<conv(floor*vfloors+1) then begin
 211 ( 6119)     { reflection on floor }
 212 ( 6122)     by:=conv(floor*vfloors+2); { jump a bit }
 213 ( 6139)     byspeed:=reflection*byspeed;
 214 ( 6145)   end else
 215 ( 6158)     byspeed:=byspeed+gravity;
 216 ( 6173)   { check for border on bottom floor }
 217 ( 6180)   if (by<4.0) and ((bx<=2.0) or (bx>=conv(xsize-4)))
 218 ( 6219)   then begin
 219 ( 6221)     if bx<2.0 then bx:=2.0
 220 ( 6240)     else if bx>=conv(xsize-4) then bx:=conv(xsize-4);
 221 ( 6276)     by:=conv(nfloors*vfloors+1);
 222 ( 6291)     byspeed:=0.0; floor:=nfloors;
 223 ( 6312)   end;
 224 ( 6316)   { check for hit }
 225 ( 6316)   if (bx>=fx-4.0) and (bx<=fx+8.0) and
 226 ( 6356)      (trunc(by)>=fy-4) and (trunc(by)<=fy+8)
 227 ( 6386)     then begin
 228 ( 6389)       count:=count+1;
 229 ( 6398)       showresult;
 230 ( 6407)       if count>=10 then
 231 ( 6413)         if demomode then begin
 232 ( 6421)           count:=0; init;
 233 ( 6434)         end else expaint:=true;
 234 ( 6439)       init;
 235 ( 6447)     end;
 236 ( 6447) end;
 237 ( 6447) 
 238 ( 6448) proc ladderup;
 239 ( 6448) begin
 240 ( 6448)   if (ffloor<nfloors) and onupladder(ffloor,fx)
 241 ( 6466)   then begin
 242 ( 6479)     fx:=conv(ladders[ffloor]+1);
 243 ( 6493)     fyspeed:=1; fxspeed:=0.0;
 244 ( 6512)   end;
 245 ( 6518) end;
 246 ( 6518) 
 247 ( 6519) proc ladderdown;
 248 ( 6519) begin
 249 ( 6519)   if (ffloor>0) and ondownladder(ffloor,fx)
 250 ( 6537)   then begin
 251 ( 6550)     fx:=conv(ladders[ffloor-1]+1);
 252 ( 6567)     fyspeed:=-1; fxspeed:=0.0;
 253 ( 6587)   end;
 254 ( 6593) end;
 255 ( 6593) 
 256 ( 6594) func exkey(key:char):boolean;
 257 ( 6594) { check for key typed }
 258 ( 6594) begin
 259 ( 6594)   exkey:=(key=esc);
 260 ( 6606)   case key of
 261 ( 6610)    cup:    ladderup;
 262 ( 6625)    cdown:  ladderdown;
 263 ( 6639)    cleft:  if onfloor(ffloor,fy) then
 264 ( 6665)              if fxspeed>1.0 then fxspeed:=0.0
 265 ( 6684)              else fxspeed:=-2.0;
 266 ( 6705)    cright: if onfloor(ffloor,fy) then
 267 ( 6738)              if fxspeed<-1.0 then fxspeed:=0.0
 268 ( 6758)              else fxspeed:=2.0
 269 ( 6773)    end {case};

----------------------------------------------------------------------

R65 COMPILE 4.3: program LADDERS          27/2/24 page 6

 270 ( 6787) end;
 271 ( 6787) 
 272 ( 6788) proc init;
 273 ( 6788) begin
 274 ( 6788)   cleargr;
 275 ( 6797)   showresult;
 276 ( 6801)   bx:=2.0; by:=conv(nfloors*vfloors+1);
 277 ( 6821)   bxs:=bx; bys:=by;
 278 ( 6840)   bxspeed:=2.0; byspeed:=0.0;
 279 ( 6870)   fx:=1.0; fy:=1; jump:=0.0;  jumpspeed:=0.0;
 280 ( 6912)   fxs:=fx; fys:=fy;
 281 ( 6930)   fxspeed:=0.0; fyspeed:=0;
 282 ( 6952)   { make and show holes }
 283 ( 6956)   holes[0]:=-50;
 284 ( 6960)   move(0,0); draw(xsize,0,white);
 285 ( 6987)   for floor:=1 to nfloors do begin
 286 ( 7004)     holes[floor]:=irandom(1,xsize-holesize-1);
 287 ( 7026)     move(0,floor*vfloors);
 288 ( 7045)     draw(xsize-1,floor*vfloors,white);
 289 ( 7065)     move(holes[floor],floor*vfloors);
 290 ( 7086)     draw(holes[floor]+holesize,floor*vfloors,black);
 291 ( 7112)   end;
 292 ( 7112)   { make and show ladders }
 293 ( 7126)   for floor:=0 to nfloors-1 do begin
 294 ( 7146)     repeat
 295 ( 7146)       ladders[floor]:=irandom(2,xsize-laddersize-2);
 296 ( 7168)     until ((ladders[floor]+laddersize<holes[floor])
 297 ( 7187)       or (ladders[floor]>holes[floor]+holesize)) and
 298 ( 7213)       ((ladders[floor]+laddersize<holes[floor+1])
 299 ( 7231)       or (ladders[floor]>holes[floor+1]+holesize));
 300 ( 7260)       showladder(floor);
 301 ( 7274)   end;
 302 ( 7274)   ladders[nfloors]:=-laddersize;
 303 ( 7292)   floor:=nfloors;
 304 ( 7299)   ffloor:=0;
 305 ( 7305) end;
 306 ( 7309) 
 307 ( 7310) {$I IANIMATE:P}
IANIMATE:P      .0C  SP 0000-0400 0004 12/02/24
{I}    1 ( 7310) { ianimate - run animation in loop
{I}    2 ( 7310)   proc expaint;
{I}    3 ( 7310)     Called to paint one picture and apply motion.
{I}    4 ( 7310)   func exkey(ch:char):boolean;
{I}    5 ( 7310)     Called to check for key and stop loop if true  }
{I}    6 ( 7310) 
{I}    7 ( 7310) proc animate(arepeat:boolean);
{I}    8 ( 7310) { arepeat: auto repeat cursor keys without delay }
{I}    9 ( 7310) const toggle=chr($0c);
{I}   10 ( 7313)       cleft=chr($03); cright=chr($16);
{I}   11 ( 7313)       cup=chr($1a); cdown=chr($18); esc=chr(0);
{I}   12 ( 7313) mem   sflag=$1781:integer&;
{I}   13 ( 7313)       emuflags=$1707:integer&;
{I}   14 ( 7313) var   ch:char;
{I}   15 ( 7313)       dummy:integer;
{I}   16 ( 7313)       stop:boolean;
{I}   17 ( 7313) begin
{I}   18 ( 7313)   repeat
{I}   19 ( 7313)     repeat
{I}   20 ( 7315)       stop:=expaint;
{I}   21 ( 7321)       dummy:=syncscreen; { sleep for up to 30 msec }
{I}   22 ( 7335)       ch:=keypressed; { sleep for 10 msec }

----------------------------------------------------------------------

R65 COMPILE 4.3: program LADDERS          27/2/24 page 7

{I}   23 ( 7343)       { sflag bit 8 is escape flag. Pass it through }
{I}   24 ( 7343)     until (ord(ch)<>0) or ((sflag and $80)<>0)
{I}   25 ( 7359)       or stop;
{I}   26 ( 7361)     if not(((ch=cup) or (ch=cdown) or (ch=cleft) or
{I}   27 ( 7391)        (ch=cright)) and
{I}   28 ( 7400)        ((emuflags and 1)<>0) and arepeat) then
{I}   29 ( 7416)        { cursor keys auto repeat without delay }
{I}   30 ( 7417)        keypressed := chr(0);
{I}   31 ( 7422)     sflag:=sflag and $7f; { clear escape flag }
{I}   32 ( 7440)     if ch=toggle then write(toggle);
{I}   33 ( 7453)   until exkey(ch) or stop;
{I}   34 ( 7465) end;
 308 ( 7474) 
 309 ( 7474) begin
 310 ( 7474)   score:=0; count:=0;
 311 ( 7484)   if option('H') then begin
 312 ( 7498)     writeln('/D   endless demo mode');
 313 ( 7530)     exit;
 314 ( 7531)   end;
 315 ( 7531)   demomode:=option('D');
 316 ( 7541)   if demomode then writeln('Demo mode');
 317 ( 7568)   grinit; fullview;
 318 ( 7576)   init;
 319 ( 7580)   animate(autorepeat);
 320 ( 7588)   splitview;
 321 ( 7592)   showresult;
 322 ( 7596)   writeln('Score ',score,' of ',count);
 323 ( 7624) end.

End compile

Code lenght:          7623
Compiler stack size:  136
Ident stack size:     196
Pascal errors:        0
