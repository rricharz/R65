
R65 COMPILE 4.2: program CALC             13/11/23 page 1


   1 (    4) {
   2 (    4)    Pascal CALC for R65 computer system
   3 (    4) 
   4 (    4)    Note: The R65 Pascal system used
   5 (    4)    32 bit floating point representation,
   6 (    4)    which is not suitable for serious
   7 (    4)    calculations, but was widely used
   8 (    4)    in early 8-bit microprocessor
   9 (    4)    systems. CALC tries to handle
  10 (    4)    this limited accuracy.
  11 (    4) 
  12 (    4)    Written 2019-2023 by rricharz  }
  13 (    4) 
  14 (    4) program calc;
  15 (    4) uses syslib,mathlib,strlib;
  16 ( 5068) 
  17 ( 5068) var ch: char;
  18 ( 5071)     r,lastr: real;
  19 ( 5071)     stop,dotused: boolean;
  20 ( 5071) 
  21 ( 5071) proc release(s: cpnt);
  22 ( 5071) {********************}
  23 ( 5071) { Only the last allocated string can be released }
  24 ( 5071) { This is suitable for recursive functions }
  25 ( 5071) mem endstk=$000e: integer;
  26 ( 5074) begin
  27 ( 5074)   if cpnt(endstk)=s then endstk:=endstk+strsize;
  28 ( 5092) end;
  29 ( 5096) 
  30 ( 5097) func fix(rf: real): integer;
  31 ( 5097) {**************************}
  32 ( 5097) begin
  33 ( 5097)   if (rf>32767.5) then begin
  34 ( 5115)       write(invvid,'Integer value exceeds');
  35 ( 5143)       write(' upper limit, set to 32767');
  36 ( 5170)       writeln(norvid); fix:=$7fff;
  37 ( 5182)     end else if (rf<-32768.5) then begin
  38 ( 5203)       write(invvid,'Integer value exceeds');
  39 ( 5231)       write(' lower limit, set to -32768');
  40 ( 5259)       writeln(norvid); fix:=$8000;
  41 ( 5271)     end else
  42 ( 5275)     fix:=trunc(rf);
  43 ( 5284) end;
  44 ( 5289) 
  45 ( 5290) proc checkfor(c: char);
  46 ( 5290) {*********************}
  47 ( 5290) begin
  48 ( 5290)   if ch<>c then begin
  49 ( 5304)     write(invvid,'SYNTAX ERROR: expected ');
  50 ( 5334)     if c=cr then write('<eol>')
  51 ( 5350)     else write(c);
  52 ( 5358)     write(' but found ');
  53 ( 5370)     if ch=cr then writeln('<eol>',norvid)
  54 ( 5388)     else writeln(ch,norvid);
  55 ( 5412)   end;
  56 ( 5412) end;
  57 ( 5412) 
  58 ( 5413) proc skip(c:char);
  59 ( 5413) {****************}

----------------------------------------------------------------------

R65 COMPILE 4.2: program CALC             13/11/23 page 2

  60 ( 5413) begin
  61 ( 5413)   checkfor(c); read(@input,ch);
  62 ( 5436) end;
  63 ( 5437) 
  64 ( 5438) func isnumber(cn:char):boolean;
  65 ( 5438) {*****************************}
  66 ( 5438) begin
  67 ( 5438)   isnumber:=(cn>='0') and (cn<='9');
  68 ( 5457) end;
  69 ( 5462) 
  70 ( 5463) proc writehex(f:file; r: integer);
  71 ( 5463) {********************************}
  72 ( 5463) var mask, m, n, r1: integer;
  73 ( 5466) begin
  74 ( 5466)   write(@f,'$'); mask := $f000; n := 12;
  75 ( 5485)   while mask <>0 do begin
  76 ( 5499)     r1 := (r and mask) shr n;
  77 ( 5508)     if r1 < 10 then write(@f,r1)
  78 ( 5532)     else  write(@f,chr(ord(r1)+ord('A')-10));
  79 ( 5559)     mask := mask shr 4; n := n - 4;
  80 ( 5576)   end;
  81 ( 5581) end;
  82 ( 5584) 
  83 ( 5585) proc writebinary(f:file; r: integer);
  84 ( 5585) {***********************************}
  85 ( 5585) var mask: integer;
  86 ( 5588) begin
  87 ( 5588)   write(@f,'% '); mask := $8000;
  88 ( 5602)   while mask <> 0 do begin
  89 ( 5616)    if (r and mask) <> 0 then write(@f,'1')
  90 ( 5638)    else write(@f,'0');
  91 ( 5650)    mask := mask shr 1;
  92 ( 5656)    if mask = $0800 then write(@f,' ');
  93 ( 5680)    if mask = $0080 then write(@f,' ');
  94 ( 5698)    if mask = $0008 then write(@f,' ');
  95 ( 5716)   end;
  96 ( 5716) end;
  97 ( 5719) 
  98 ( 5720) proc writeauto(f:file;r:real);
  99 ( 5720) {****************************}
 100 ( 5720) { outputs 5 digits }
 101 ( 5720) var m,m1,max,rnd: real;
 102 ( 5723)     i1,d1:integer;
 103 ( 5723)     sign: char;
 104 ( 5723) begin
 105 ( 5723)   sign:=' '; m:=r;
 106 ( 5731)   if m<0. then begin
 107 ( 5756)     sign:='-'; m:=-m;
 108 ( 5765)   end;
 109 ( 5778)   if dotused and (m>=10000.0) then writeflo(f,r)
 110 ( 5803)   else if m=0. then begin
 111 ( 5831)     write(@f,' 0',tab8,tab8); writehex(f,0);
 112 ( 5861)     write(@f,'  ',tab8); writebinary(f,0);
 113 ( 5885)   end else if r=conv($8000) then begin
 114 ( 5899)     write(@f,'-32768',tab8,tab8); write(@f,'$8000');
 115 ( 5933)     write(@f,'  ',tab8);
 116 ( 5945)     write(@f,'% 1000 0000 0000 0000');
 117 ( 5973)   end else if m>=32767.5 then writeflo(f,r)
 118 ( 5996)   else if m<0.01 then writeflo(f,r)
 119 ( 6031)   else begin

----------------------------------------------------------------------

R65 COMPILE 4.2: program CALC             13/11/23 page 3

 120 ( 6046)     if m>=10000. then begin
 121 ( 6059)       d1:=0; rnd:=0.5
 122 ( 6068)     end else if m>=1000. then begin
 123 ( 6096)       d1:=1; rnd:=0.05
 124 ( 6105)     end else if m>=100. then begin
 125 ( 6133)       d1:=2; rnd:=0.005
 126 ( 6142)     end else if m>=10. then begin
 127 ( 6170)       d1:=3; rnd:=0.0005
 128 ( 6179)     end else if m>=1. then begin
 129 ( 6207)       d1:=4; rnd:=0.00005
 130 ( 6216)     end else if m>=0.1 then begin
 131 ( 6244)       d1:=5; rnd:=0.000005
 132 ( 6253)     end else begin
 133 ( 6268)       d1:=6; rnd:=0.0000005
 134 ( 6274)     end;
 135 ( 6286)     m:=m+rnd; { round }
 136 ( 6305)     write(@f,sign,trunc(m));
 137 ( 6324)     m1:=m-conv(trunc(m));
 138 ( 6337)     if d1>0 then write(@f,'.');
 139 ( 6363)     for i1:=1 to d1 do begin
 140 ( 6382)       m1:=10.*m1; write(@f,trunc(m1));
 141 ( 6415)       m1:=m1-conv(trunc(m1));
 142 ( 6428)     end;
 143 ( 6436)     write(@f,'  ',tab8); writehex(f,trunc(r+rnd));
 144 ( 6486)     write(@f,'  ',tab8); writebinary(f,trunc(r+rnd))
 145 ( 6515)   end;
 146 ( 6522) end;
 147 ( 6522) 
 148 ( 6523) func express:real;
 149 ( 6523) {****************}
 150 ( 6523) var
 151 ( 6523)   re: real;
 152 ( 6526) 
 153 ( 6526) func binval: integer;
 154 ( 6526) {*******************}
 155 ( 6526) begin
 156 ( 6526)   if (ch='0') then binval:=0
 157 ( 6541)   else if (ch='1') then binval:=1
 158 ( 6560)   else binval:=-1;
 159 ( 6571) end;
 160 ( 6576) 
 161 ( 6577) func hexval: integer;
 162 ( 6577) {*******************}
 163 ( 6577) begin
 164 ( 6577)   if (ch>='0') and (ch<='9')
 165 ( 6595)     then hexval:=ord(ch)-ord('0')
 166 ( 6606)   else if (ch>='A') and (ch<='F')
 167 ( 6627)     then hexval:=ord(ch)-ord('A')+10
 168 ( 6639)   else hexval:=-1;
 169 ( 6651) end;
 170 ( 6656) 
 171 ( 6657) func isletter(ch:char):boolean;
 172 ( 6657) {*****************************}
 173 ( 6657) begin
 174 ( 6657)   isletter:=(ord(ch)>=ord('A'))and(ord(ch)<=ord('Z'))
 175 ( 6675) end;
 176 ( 6681) 
 177 ( 6682) func function:real;
 178 ( 6682) {*****************}
 179 ( 6682) var i: integer;

----------------------------------------------------------------------

R65 COMPILE 4.2: program CALC             13/11/23 page 4

 180 ( 6685)     r: real;
 181 ( 6685)     lstring: cpnt;
 182 ( 6685) begin
 183 ( 6685)   lstring:=strnew;
 184 ( 6693)   lstring[0]:=chr(0);
 185 ( 6701)   strins(ch,0,lstring); read(@input,ch); i:=1;
 186 ( 6733)   while isletter(ch) do begin
 187 ( 6752)     strins(ch,i,lstring); read(@input,ch); i:=i+1;
 188 ( 6785)   end;
 189 ( 6790)   stop:=false;
 190 ( 6795)   if strcmp(lstring,'R')=0 then begin
 191 ( 6818)     function:=lastr; release(lstring); exit;
 192 ( 6844)   end;
 193 ( 6844)   if strcmp(lstring,'PI')=0 then begin
 194 ( 6864)     function:=pi; release(lstring); exit;
 195 ( 6890)   end;
 196 ( 6890)   { functions with single argument follow }
 197 ( 6890)   checkfor('('); r:=express; skip(')');
 198 ( 6918)   if strcmp(lstring,'SQR')=0 then begin
 199 ( 6939)     function:=r*r; release(lstring); exit;
 200 ( 6972)   end;
 201 ( 6972)   if strcmp(lstring,'SQRT')=0 then begin
 202 ( 6994)     if r>=0.0 then r:=sqrt(r)
 203 ( 7015)     else begin
 204 ( 7036)       writeln(invvid,'Negative argument not allowed',
 205 ( 7069)         norvid); r:=0.0
 206 ( 7078)     end;
 207 ( 7090)     function:=r; release(lstring); exit;
 208 ( 7113)   end;
 209 ( 7113)   writeln(invvid,'Unknown function ',lstring,norvid);
 210 ( 7148)   function:=0.0;
 211 ( 7154)   release(lstring);
 212 ( 7170) end;
 213 ( 7170) 
 214 ( 7171) func factor:real;
 215 ( 7171) {***************}
 216 ( 7171) var negative:boolean;
 217 ( 7174)     rf,rt: real;
 218 ( 7174)     i,iv: integer;
 219 ( 7174) begin
 220 ( 7174)   negative:=false; rf:=0.;
 221 ( 7188)   read(@input,ch);
 222 ( 7202)   if ch='-' then begin
 223 ( 7210)     negative:=true;
 224 ( 7215)     read(@input,ch);
 225 ( 7227)   end;
 226 ( 7228)   if ch='(' then begin
 227 ( 7235)     stop:=false; rf:=express;
 228 ( 7250)     checkfor(')'); read(@input,ch);
 229 ( 7272)   end else if ch='%' then begin
 230 ( 7283)     stop:=false; read(@input,ch); iv:=0;
 231 ( 7303)     while binval>=0 do begin
 232 ( 7319)       iv:=(iv shl 1)+binval; read(@input,ch);
 233 ( 7345)     end;
 234 ( 7346)     rf:=conv(iv);
 235 ( 7353)   end else if ch='$' then begin
 236 ( 7370)     stop:=false;
 237 ( 7375)     read(@input,ch);
 238 ( 7387)     iv:=0;
 239 ( 7390)     while hexval>=0 do begin

----------------------------------------------------------------------

R65 COMPILE 4.2: program CALC             13/11/23 page 5

 240 ( 7406)       iv:=(iv shl 4)+hexval; read(@input,ch);
 241 ( 7432)     end;
 242 ( 7433)     rf:=conv(iv);
 243 ( 7440)   end else if isletter(ch) then begin
 244 ( 7462)     rf:=function;
 245 ( 7471)   end else if ch<>chr(0) then begin
 246 ( 7488)     if ch<>cr then begin
 247 ( 7498)       if ch<>cr then stop:=false;
 248 ( 7513)       if ch='+' then read(@input,ch);
 249 ( 7535)       {if ch='-' then begin
 250 ( 7536)         negative:=true; read(@input,ch);
 251 ( 7536)       end;}
 252 ( 7536)       if not isnumber(ch) then
 253 ( 7548)         writeln(invvid,
 254 ( 7554)           'SYNTAX ERROR: NUMBER EXPECTED',norvid);
 255 ( 7594)       while isnumber(ch) do begin
 256 ( 7609)         rt:=rf+rf; rt:=rt+rt;
 257 ( 7634)         rf:=rt+rt+rf+rf+conv(ord(ch)-ord('0'));
 258 ( 7681)         read(@input,ch);
 259 ( 7697)       end;
 260 ( 7698)       if ch='.' then begin
 261 ( 7708)         dotused:=true; read(@input,ch); rt:=0.1;
 262 ( 7732)         while isnumber(ch) do begin
 263 ( 7753)           rf:=rf+conv(ord(ch)-ord('0'))*rt;
 264 ( 7767)           rt:=rt/10.;
 265 ( 7793)           read(@input,ch);
 266 ( 7808)         end;
 267 ( 7809)       end;
 268 ( 7812)     end;
 269 ( 7812)     if negative then rf:=-rf;
 270 ( 7819)   end;
 271 ( 7832)   factor:=rf;
 272 ( 7832) end;
 273 ( 7844) 
 274 ( 7845) func simexp:real;
 275 ( 7845) {***************}
 276 ( 7845) var
 277 ( 7845)   rs: real;
 278 ( 7848) begin
 279 ( 7848)   rs:=factor;
 280 ( 7856)   while (ch='*') or (ch='/') or (ch='&') or (ch='<')
 281 ( 7891)     or (ch='>') do begin
 282 ( 7904)     case ch of
 283 ( 7904)       '*': begin
 284 ( 7915)              rs:=rs*factor;
 285 ( 7927)            end;
 286 ( 7934)       '/': begin
 287 ( 7944)              rs:=rs/factor;
 288 ( 7956)            end;
 289 ( 7963)       '&': begin
 290 ( 7973)              rs:=conv(fix(rs) and fix(factor));
 291 ( 8002)            end;
 292 ( 8009)       '<': begin
 293 ( 8019)              read(@input,ch);
 294 ( 8027)              checkfor('<');
 295 ( 8036)              rs:=conv(fix(rs) shl fix(factor));
 296 ( 8065)              end;
 297 ( 8072)       '>': begin
 298 ( 8082)              read(@input,ch);
 299 ( 8090)              checkfor('>');

----------------------------------------------------------------------

R65 COMPILE 4.2: program CALC             13/11/23 page 6

 300 ( 8099)              rs:=conv(fix(rs) shr fix(factor));
 301 ( 8128)            end
 302 ( 8135)       end {case};
 303 ( 8137)   end;
 304 ( 8137)   simexp:=rs;
 305 ( 8140) end;
 306 ( 8152) 
 307 ( 8153) {********body of express********}
 308 ( 8153) begin
 309 ( 8153)   re:=simexp;
 310 ( 8161)   while (ch='+') or (ch='-') or (ch='|') do begin
 311 ( 8193)     case ch of
 312 ( 8193)       '+': begin
 313 ( 8204)              re:=re+simexp;
 314 ( 8216)            end;
 315 ( 8223)       '-': begin
 316 ( 8233)              re:=re-simexp;
 317 ( 8245)            end;
 318 ( 8252)       '|': begin
 319 ( 8262)              re:=conv(fix(re) or fix(factor));
 320 ( 8291)            end
 321 ( 8298)     end {case};
 322 ( 8300)   end;
 323 ( 8300)   express:=re;
 324 ( 8303) end;
 325 ( 8315) 
 326 ( 8316) {*********main body********}
 327 ( 8316) begin
 328 ( 8316)   writeln('Enter an expression, examples are:');
 329 ( 8359)   writeln('32767     input decimal number');
 330 ( 8396)   writeln('$FFF      input hex number');
 331 ( 8429)   writeln('%1101     input binary number');
 332 ( 8465)   writeln('-55.35    input negative number');
 333 ( 8503)   writeln('2*(5+28)  math expression');
 334 ( 8535)   writeln('R*3       last result');
 335 ( 8563)   writeln('<return>,<esc>    exit');
 336 ( 8592)   writeln('operators: +,-,*,/,(),&,|,<<,>>');
 337 ( 8630)   writeln('functions: SQRT(),SQR()');
 338 ( 8660)   r:=0.0; lastr:=0.0;
 339 ( 8678)   dotused:=false;
 340 ( 8686)   repeat
 341 ( 8690)     stop:=true;
 342 ( 8692)     writeauto(output,r); writeln;
 343 ( 8710)     dotused:=false; lastr:=r;
 344 ( 8722)     r:=express; checkfor(cr);
 345 ( 8754)   until stop;
 346 ( 8754) end.
 347 ( 8761) 

End compile

Code lenght:          8760
Compiler stack size:  117
Ident stack size:     122
Pascal errors:        0
