
R65 COMPILE 4.2: program CALC             7/12/23 page 1


   1 (    4)  {
   2 (    4)    Pascal CALC for R65 computer system
   3 (    4) 
   4 (    4)    Note: The R65 Pascal system used
   5 (    4)    32 bit floating point representation,
   6 (    4)    which is not suitable for serious
   7 (    4)    calculations, but was widely used
   8 (    4)    in early 8-bit microprocessor
   9 (    4)    systems. CALC tries to handle
  10 (    4)    this limited accuracy.
  11 (    4) 
  12 (    4)    Written 2019-2023 by rricharz  }
  13 (    4) 
  14 (    4) program calc;
  15 (    4) uses syslib,mathlib,strlib,ledlib;
  16 ( 5524) 
  17 ( 5524) mem vidpnt=$00e9:integer;
  18 ( 5527) 
  19 ( 5527) var ch: char;
  20 ( 5527)     r,lastr: real;
  21 ( 5527)     stop,dotused,firsterror: boolean;
  22 ( 5527) 
  23 ( 5527) proc clearinput;
  24 ( 5527) {**************}
  25 ( 5527) begin
  26 ( 5527)   buffpn:=-1;
  27 ( 5534) end;
  28 ( 5539) 
  29 ( 5540) proc error(s1,s2:cpnt);
  30 ( 5540) {*********************}
  31 ( 5540) begin
  32 ( 5540)   if firsterror then
  33 ( 5545)     writeln(invvid,'Error: ',s1,' ',s2,norvid);
  34 ( 5584)   firsterror:=false;
  35 ( 5586) end;
  36 ( 5590) 
  37 ( 5591) proc readch;
  38 ( 5591) {**********}
  39 ( 5591) begin
  40 ( 5591)   if firsterror then read(@input,ch)
  41 ( 5606)   else ch:=cr;
  42 ( 5617) end;
  43 ( 5621) 
  44 ( 5622) proc release(s: cpnt);
  45 ( 5622) {********************}
  46 ( 5622) { Only the last allocated string can be released }
  47 ( 5622) { This is suitable for recursive functions }
  48 ( 5622) mem endstk=$000e: integer;
  49 ( 5625) begin
  50 ( 5625)   if cpnt(endstk)=s then endstk:=endstk+strsize
  51 ( 5641)   else error('Cannot release string',' ');
  52 ( 5684) end;
  53 ( 5684) 
  54 ( 5685) func fix(rf: real): integer;
  55 ( 5685) {**************************}
  56 ( 5685) var rnd:real;
  57 ( 5688) begin
  58 ( 5688)   if rf>=0.0 then rnd:=0.5 else rnd:=-0.5;
  59 ( 5727)   if (rf>=32767.5) then begin

----------------------------------------------------------------------

R65 COMPILE 4.2: program CALC             7/12/23 page 2

  60 ( 5747)       error('Integer value exceeds',
  61 ( 5774)         'upper limit, set to 32767');
  62 ( 5808)       fix:=$7fff;
  63 ( 5811)     end else if (rf<=-32768.5) then begin
  64 ( 5832)       error('Integer value exceeds',
  65 ( 5859)         ' lower limit, set to -32768');
  66 ( 5895)       fix:=$8000;
  67 ( 5898)     end else fix:=trunc(rf+rnd);
  68 ( 5918) end;
  69 ( 5923) 
  70 ( 5924) proc checkfor(c: char);
  71 ( 5924) {*********************}
  72 ( 5924) var s1,s2:cpnt;
  73 ( 5927) begin
  74 ( 5927)   if ch<>c then begin
  75 ( 5938)     s1:=strnew; s2:=strnew;
  76 ( 5957)     strcpy('Expected ',s1);
  77 ( 5983)     if c=cr then strcpy('Expected <eol>',s1)
  78 ( 6010)     else strinsc(c,9,s1);
  79 ( 6039)     strcpy('but found ',s2);
  80 ( 6062)     if ch=cr then strcpy('but found <eol>',s2)
  81 ( 6090)     else strinsc(ch,10,s2);
  82 ( 6119)     error(s1,s2);
  83 ( 6133)     release(s2); release(s1);
  84 ( 6153)   end;
  85 ( 6153) end;
  86 ( 6153) 
  87 ( 6154) proc skip(c:char);
  88 ( 6154) {****************}
  89 ( 6154) begin
  90 ( 6154)   checkfor(c); readch;
  91 ( 6173) end;
  92 ( 6173) 
  93 ( 6174) func isnumber(cn:char):boolean;
  94 ( 6174) {*****************************}
  95 ( 6174) begin
  96 ( 6174)   isnumber:=(cn>='0') and (cn<='9');
  97 ( 6193) end;
  98 ( 6198) 
  99 ( 6199) proc writehex(f:file; r: integer);
 100 ( 6199) {********************************}
 101 ( 6199) var mask, m, n, r1: integer;
 102 ( 6202) begin
 103 ( 6202)   write(@f,'$'); mask := $f000; n := 12;
 104 ( 6221)   while mask <>0 do begin
 105 ( 6235)     r1 := (r and mask) shr n;
 106 ( 6244)     if r1 < 10 then write(@f,r1)
 107 ( 6268)     else  write(@f,chr(ord(r1)+ord('A')-10));
 108 ( 6295)     mask := mask shr 4; n := n - 4;
 109 ( 6312)   end;
 110 ( 6317) end;
 111 ( 6320) 
 112 ( 6321) proc writebinary(f:file; r: integer);
 113 ( 6321) {***********************************}
 114 ( 6321) var mask: integer;
 115 ( 6324) begin
 116 ( 6324)   write(@f,'% '); mask := $8000;
 117 ( 6338)   while mask <> 0 do begin
 118 ( 6352)    if (r and mask) <> 0 then write(@f,'1')
 119 ( 6374)    else write(@f,'0');

----------------------------------------------------------------------

R65 COMPILE 4.2: program CALC             7/12/23 page 3

 120 ( 6386)    mask := mask shr 1;
 121 ( 6392)    if mask = $0800 then write(@f,' ');
 122 ( 6416)    if mask = $0080 then write(@f,' ');
 123 ( 6434)    if mask = $0008 then write(@f,' ');
 124 ( 6452)   end;
 125 ( 6452) end;
 126 ( 6455) 
 127 ( 6456) proc showled(s1:cpnt);
 128 ( 6456) {********************}
 129 ( 6456) var s2:cpnt;
 130 ( 6459)     pos,i,l:integer;
 131 ( 6459) begin
 132 ( 6459)   s2:=strnew;
 133 ( 6467)   strcpy(s1,s2);
 134 ( 6485)   { remove any space }
 135 ( 6485)   pos:=strpos(' ',s2,0);
 136 ( 6501)   while pos>=0 do begin
 137 ( 6515)     strdelc(pos,s2);
 138 ( 6529)     pos:=strpos(' ',s2,0);
 139 ( 6545)   end;
 140 ( 6549)   { remove any plus sign }
 141 ( 6552)   pos:=strpos('+',s2,0);
 142 ( 6568)   while pos>=0 do begin
 143 ( 6582)     strdelc(pos,s2);
 144 ( 6596)     pos:=strpos('+',s2,0);
 145 ( 6612)   end;
 146 ( 6616)   { convert point to bit 8 }
 147 ( 6619)   pos:=strpos('.',s2,0);
 148 ( 6635)   while pos>0 do begin
 149 ( 6649)     strdelc(pos,s2);
 150 ( 6663)     s2[pos-1]:=chr(ord(s2[pos-1]) or 128);
 151 ( 6686)     pos:=strpos('.',s2,0);
 152 ( 6707)   end;
 153 ( 6711)   { remove unnecessary 0 in exponent, if necessary }
 154 ( 6714)   l:=strlen(s2);
 155 ( 6726)   if (l>8) and (s2[l-2]='0') and
 156 ( 6753)     (strpos('e',s2,0)>0) then strdelc(l-2,s2);
 157 ( 6794)   { remove e as a last resort (exp is negative) }
 158 ( 6794)   if strlen(s2)>8 then begin
 159 ( 6809)     pos:=strpos('e',s2,0);
 160 ( 6828)     if pos>0 then strdelc(pos,s2);
 161 ( 6856)   end;
 162 ( 6856)   { right justify }
 163 ( 6856)   while strlen(s2)<8 do strinsc(' ',0,s2);
 164 ( 6888)   { show converted string }
 165 ( 6891)   ledstring(s2);
 166 ( 6901)   release(s2);
 167 ( 6911) end;
 168 ( 6911) 
 169 ( 6912) proc writeauto(f:file;r:real);
 170 ( 6912) {****************************}
 171 ( 6912) { outputs 5 digits }
 172 ( 6912) var m,m1,max,rnd: real;
 173 ( 6915)     i1,d1:integer;
 174 ( 6915)     sign: char;
 175 ( 6915) begin
 176 ( 6915)   sign:=' '; m:=r;
 177 ( 6923)   if m<0. then begin
 178 ( 6948)     sign:='-'; m:=-m;
 179 ( 6957)   end;

----------------------------------------------------------------------

R65 COMPILE 4.2: program CALC             7/12/23 page 4

 180 ( 6970)   if dotused and (m>=10000.0) then writeflo(f,r)
 181 ( 6995)   else if m=0. then write(@f,' 0')
 182 ( 7034)   else if r=conv($8000) then write(@f,'-32768 ')
 183 ( 7065)   else if m>=32767.5 then writeflo(f,r)
 184 ( 7089)   else if m<0.01 then writeflo(f,r)
 185 ( 7124)   else begin
 186 ( 7139)     if m>=10000. then begin
 187 ( 7152)       d1:=0; rnd:=0.5
 188 ( 7161)     end else if m>=1000. then begin
 189 ( 7189)       d1:=1; rnd:=0.05
 190 ( 7198)     end else if m>=100. then begin
 191 ( 7226)       d1:=2; rnd:=0.005
 192 ( 7235)     end else if m>=10. then begin
 193 ( 7263)       d1:=3; rnd:=0.0005
 194 ( 7272)     end else if m>=1. then begin
 195 ( 7300)       d1:=4; rnd:=0.00005
 196 ( 7309)     end else if m>=0.1 then begin
 197 ( 7337)       d1:=5; rnd:=0.000005
 198 ( 7346)     end else begin
 199 ( 7361)       d1:=6; rnd:=0.0000005
 200 ( 7367)     end;
 201 ( 7379)     m:=m+rnd; { round }
 202 ( 7398)     write(@f,sign,trunc(m));
 203 ( 7417)     m1:=m-conv(trunc(m));
 204 ( 7430)     if m1<=rnd then begin
 205 ( 7451)       for i1:=1 to d1+1 do write(@f,' ');
 206 ( 7484)       d1:=0;
 207 ( 7500)     end;
 208 ( 7504)     if d1>0 then write(@f,'.');
 209 ( 7522)     for i1:=1 to d1 do begin
 210 ( 7541)       m1:=10.*m1; write(@f,trunc(m1));
 211 ( 7574)       m1:=m1-conv(trunc(m1));
 212 ( 7587)     end;
 213 ( 7595)   end;
 214 ( 7609) end;
 215 ( 7609) 
 216 ( 7610) proc showresult;
 217 ( 7610) {**************}
 218 ( 7610) var s1: cpnt;
 219 ( 7613)     rnd: real;
 220 ( 7613) begin
 221 ( 7613)   s1:=strnew;
 222 ( 7621)   writeauto(@s1,r);
 223 ( 7641)   write(s1);
 224 ( 7646)   if (r>-32768.5) and (r<32767.5) then begin
 225 ( 7674)     if r>=0.0 then rnd:=0.5 else rnd:=-0.5;
 226 ( 7714)     tab(16); writehex(output,fix(r));
 227 ( 7751)     tab(24); writebinary(output,fix(r));
 228 ( 7781)   end;
 229 ( 7781)   writeln;
 230 ( 7781)   showled(s1);
 231 ( 7797)   release(s1);
 232 ( 7807) end;
 233 ( 7807) 
 234 ( 7808) func express:real;
 235 ( 7808) {****************}
 236 ( 7808) var
 237 ( 7808)   re: real;
 238 ( 7811) 
 239 ( 7811) func binval: integer;

----------------------------------------------------------------------

R65 COMPILE 4.2: program CALC             7/12/23 page 5

 240 ( 7811) {*******************}
 241 ( 7811) begin
 242 ( 7811)   if (ch='0') then binval:=0
 243 ( 7826)   else if (ch='1') then binval:=1
 244 ( 7845)   else binval:=-1;
 245 ( 7856) end;
 246 ( 7861) 
 247 ( 7862) func hexval: integer;
 248 ( 7862) {*******************}
 249 ( 7862) begin
 250 ( 7862)   if (ch>='0') and (ch<='9')
 251 ( 7880)     then hexval:=ord(ch)-ord('0')
 252 ( 7891)   else if (ch>='A') and (ch<='F')
 253 ( 7912)     then hexval:=ord(ch)-ord('A')+10
 254 ( 7924)   else hexval:=-1;
 255 ( 7936) end;
 256 ( 7941) 
 257 ( 7942) func isletter(ch:char):boolean;
 258 ( 7942) {*****************************}
 259 ( 7942) begin
 260 ( 7942)   isletter:=(ord(ch)>=ord('A'))and(ord(ch)<=ord('Z'))
 261 ( 7960) end;
 262 ( 7966) 
 263 ( 7967) func function:real;
 264 ( 7967) {*****************}
 265 ( 7967) var i: integer;
 266 ( 7970)     r: real;
 267 ( 7970)     lstring: cpnt;
 268 ( 7970) begin
 269 ( 7970)   lstring:=strnew;
 270 ( 7978)   lstring[0]:=chr(0);
 271 ( 7986)   strinsc(ch,0,lstring); readch; i:=1;
 272 ( 8013)   while isletter(ch) do begin
 273 ( 8032)     strinsc(ch,i,lstring); readch; i:=i+1;
 274 ( 8060)   end;
 275 ( 8065)   stop:=false;
 276 ( 8070)   if strcmp(lstring,'R')=0 then begin
 277 ( 8093)     function:=lastr; release(lstring); exit;
 278 ( 8119)   end;
 279 ( 8119)   if strcmp(lstring,'PI')=0 then begin
 280 ( 8139)     function:=pi; release(lstring); exit;
 281 ( 8165)   end;
 282 ( 8165)   if strcmp(lstring,'E')=0 then begin
 283 ( 8184)     function:=e; release(lstring); exit;
 284 ( 8210)   end;
 285 ( 8210)   { functions with single argument follow }
 286 ( 8210)   checkfor('('); r:=express; skip(')');
 287 ( 8238)   if strcmp(lstring,'SQR')=0 then begin
 288 ( 8259)     function:=r*r; release(lstring); exit;
 289 ( 8292)   end;
 290 ( 8292)   if strcmp(lstring,'SQRT')=0 then begin
 291 ( 8314)     function:=sqrt(r); release(lstring); exit;
 292 ( 8348)   end;
 293 ( 8348)   if strcmp(lstring,'SIN')=0 then begin
 294 ( 8369)     function:=sin(r); release(lstring); exit;
 295 ( 8403)   end;
 296 ( 8403)   if strcmp(lstring,'COS')=0 then begin
 297 ( 8424)     function:=cos(r); release(lstring); exit;
 298 ( 8458)   end;
 299 ( 8458)   if strcmp(lstring,'TAN')=0 then begin

----------------------------------------------------------------------

R65 COMPILE 4.2: program CALC             7/12/23 page 6

 300 ( 8479)     function:=tan(r); release(lstring); exit;
 301 ( 8513)   end;
 302 ( 8513)   if strcmp(lstring,'EXP')=0 then begin
 303 ( 8534)     function:=exp(r); release(lstring); exit;
 304 ( 8568)   end;
 305 ( 8568)   if strcmp(lstring,'LN')=0 then begin
 306 ( 8588)     function:=ln(r); release(lstring); exit;
 307 ( 8622)   end;
 308 ( 8622)   if strcmp(lstring,'LOG')=0 then begin
 309 ( 8643)     function:=log(r); release(lstring); exit;
 310 ( 8677)   end;
 311 ( 8677)   error('Unknow function',lstring);
 312 ( 8705)   function:=0.0;
 313 ( 8711)   release(lstring);
 314 ( 8727) end;
 315 ( 8727) 
 316 ( 8728) proc exponent(var r:real);
 317 ( 8728) {************************}
 318 ( 8728) var minus:boolean;
 319 ( 8731)     exp:integer;
 320 ( 8731) begin
 321 ( 8731)   minus:=false;
 322 ( 8735)   if ch='-' then begin minus:=true; readch end
 323 ( 8759)   else if ch='+' then readch;
 324 ( 8776)   exp:=0;
 325 ( 8778)   if isnumber(ch) then begin
 326 ( 8794)     exp:=ord(ch)-ord('0'); readch
 327 ( 8808)   end else error('Expecting','exponent');
 328 ( 8844)   if isnumber(ch) then begin
 329 ( 8856)     exp:=10*exp+(ord(ch)-ord('0')); readch;
 330 ( 8882)   end;
 331 ( 8882)   if minus then
 332 ( 8882)     while exp>0 do begin r:=0.1*r; exp:=exp-1 end
 333 ( 8924)   else
 334 ( 8929)     while exp>0 do begin r:=10.0*r; exp:=exp-1 end;
 335 ( 8975) end;
 336 ( 8978) 
 337 ( 8979) func factor:real;
 338 ( 8979) {***************}
 339 ( 8979) var negative:boolean;
 340 ( 8982)     rf,rt: real;
 341 ( 8982)     i,iv: integer;
 342 ( 8982) begin
 343 ( 8982)   negative:=false; rf:=0.;  readch;
 344 ( 9006)   if ch='-' then begin
 345 ( 9013)     negative:=true; readch;
 346 ( 9026)   end;
 347 ( 9026)   if ch='(' then begin
 348 ( 9033)     stop:=false; rf:=express;
 349 ( 9048)     checkfor(')'); readch;
 350 ( 9066)   end else if ch='%' then begin
 351 ( 9076)     stop:=false; readch; iv:=0;
 352 ( 9091)     while binval>=0 do begin
 353 ( 9107)       iv:=(iv shl 1)+binval; readch;
 354 ( 9129)     end;
 355 ( 9129)     rf:=conv(iv);
 356 ( 9136)   end else if ch='$' then begin
 357 ( 9153)     stop:=false; readch; iv:=0;
 358 ( 9168)     while hexval>=0 do begin
 359 ( 9184)       iv:=(iv shl 4)+hexval; readch;

----------------------------------------------------------------------

R65 COMPILE 4.2: program CALC             7/12/23 page 7

 360 ( 9206)     end;
 361 ( 9206)     rf:=conv(iv);
 362 ( 9213)   end else if isletter(ch) then rf:=function
 363 ( 9238)   else if ch<>chr(0) then begin
 364 ( 9261)     if ch<>cr then begin
 365 ( 9271)       if ch<>cr then stop:=false;
 366 ( 9286)       if ch='+' then readch;
 367 ( 9304)       {if ch='-' then begin
 368 ( 9304)         negative:=true; readch;
 369 ( 9304)       end;}
 370 ( 9304)       if not isnumber(ch) then
 371 ( 9316)         error('Expected','number');
 372 ( 9346)       while isnumber(ch) do begin
 373 ( 9361)         rt:=rf+rf; rt:=rt+rt;
 374 ( 9386)         rf:=rt+rt+rf+rf+conv(ord(ch)-ord('0'));
 375 ( 9433)         readch;
 376 ( 9445)       end;
 377 ( 9445)       if ch='.' then begin
 378 ( 9455)         dotused:=true; readch; rt:=0.1;
 379 ( 9474)         while isnumber(ch) do begin
 380 ( 9495)           rf:=rf+conv(ord(ch)-ord('0'))*rt;
 381 ( 9509)           rt:=rt/10.; readch;
 382 ( 9546)         end;
 383 ( 9546)       end;
 384 ( 9549)       if ch='E' then begin readch; exponent(rf) end;
 385 ( 9579)     end;
 386 ( 9579)     if negative then rf:=-rf;
 387 ( 9586)   end;
 388 ( 9599)   factor:=rf;
 389 ( 9599) end;
 390 ( 9611) 
 391 ( 9612) func simexp:real;
 392 ( 9612) {***************}
 393 ( 9612) var
 394 ( 9612)   rs,divisor: real;
 395 ( 9615) begin
 396 ( 9615)   rs:=factor;
 397 ( 9623)   while (ch='*') or (ch='/') or (ch='&') or (ch='<')
 398 ( 9658)     or (ch='>') or (ch='^') do begin
 399 ( 9679)     case ch of
 400 ( 9679)       '*': begin rs:=rs*factor; end;
 401 ( 9709)       '/': begin
 402 ( 9719)              divisor:=factor;
 403 ( 9725)              if divisor=0.0 then
 404 ( 9743)                error('Division','by zero')
 405 ( 9768)              else
 406 ( 9774)                rs:=rs/divisor;
 407 ( 9783)            end;
 408 ( 9796)       '&': rs:=conv(fix(rs) and fix(factor));
 409 ( 9835)       '^': rs:=exp(factor*ln(rs));
 410 ( 9881)       '<': begin
 411 ( 9897)              readch; checkfor('<');
 412 ( 9909)              rs:=conv(fix(rs) shl fix(factor));
 413 ( 9938)              end;
 414 ( 9945)       '>': begin
 415 ( 9955)              readch; checkfor('>');
 416 ( 9967)              rs:=conv(fix(rs) shr fix(factor));
 417 ( 9996)            end
 418 (10003)       end {case};
 419 (10005)   end;

----------------------------------------------------------------------

R65 COMPILE 4.2: program CALC             7/12/23 page 8

 420 (10005)   simexp:=rs;
 421 (10008) end;
 422 (10020) 
 423 (10021) {********body of express********}
 424 (10021) begin
 425 (10021)   re:=simexp;
 426 (10029)   while (ch='+') or (ch='-') or (ch='|') do begin
 427 (10061)     case ch of
 428 (10061)       '+': begin re:=re+simexp; end;
 429 (10091)       '-': begin re:=re-simexp; end;
 430 (10120)       '|': begin
 431 (10130)              re:=conv(fix(re) or fix(factor));
 432 (10159)            end
 433 (10166)     end {case};
 434 (10168)   end;
 435 (10168)   express:=re;
 436 (10171) end;
 437 (10183) 
 438 (10184) {*********main body********}
 439 (10184) begin
 440 (10184)   write(invvid);
 441 (10189)   writeln('Enter an expression, for example:        ');
 442 (10237)   writeln('32767      input decimal number          ');
 443 (10285)   writeln('$FFF       input hex number              ');
 444 (10333)   writeln('%1101      input binary number           ');
 445 (10381)   writeln('-55.35     input negative number         ');
 446 (10429)   writeln('2*(5+28)   math expression               ');
 447 (10477)   writeln('R*3        last result                   ');
 448 (10525)   writeln('<return>,<esc>    exit                   ');
 449 (10573)   writeln('Operators: +,-,*,/,^,(),&,|,<<,>>        ');
 450 (10621)   writeln('Functions: SQRT(),SQR(),SIN(),COS()      ');
 451 (10669)   writeln('           TAN(),EXP(),LN(),LOG()        ');
 452 (10717)   writeln(norvid);
 453 (10726)   r:=0.0; lastr:=0.0; dotused:=false;
 454 (10752)   repeat
 455 (10756)     firsterror:=true;
 456 (10758)     clearinput;
 457 (10766)     stop:=true; showresult;
 458 (10776)     dotused:=false; lastr:=r; r:=express; checkfor(cr);
 459 (10814)   until stop;
 460 (10814) end.

End compile

Code lenght:          10820
Compiler stack size:  140
Ident stack size:     138
Pascal errors:        0
