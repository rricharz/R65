
R65 COMPILE 4.2: program CALC             14/11/23 page 1


   1 (    4) {
   2 (    4)    Pascal CALC for R65 computer system
   3 (    4) 
   4 (    4)    Note: The R65 Pascal system used
   5 (    4)    32 bit floating point representation,
   6 (    4)    which is not suitable for serious
   7 (    4)    calculations, but was widely used
   8 (    4)    in early 8-bit microprocessor
   9 (    4)    systems. CALC tries to handle
  10 (    4)    this limited accuracy.
  11 (    4) 
  12 (    4)    Written 2019-2023 by rricharz  }
  13 (    4) 
  14 (    4) program calc;
  15 (    4) uses syslib,mathlib,strlib;
  16 ( 5380) 
  17 ( 5380) var ch: char;
  18 ( 5383)     r,lastr: real;
  19 ( 5383)     stop,dotused: boolean;
  20 ( 5383) 
  21 ( 5383) proc release(s: cpnt);
  22 ( 5383) {********************}
  23 ( 5383) { Only the last allocated string can be released }
  24 ( 5383) { This is suitable for recursive functions }
  25 ( 5383) mem endstk=$000e: integer;
  26 ( 5386) begin
  27 ( 5386)   if cpnt(endstk)=s then endstk:=endstk+strsize;
  28 ( 5404) end;
  29 ( 5408) 
  30 ( 5409) func fix(rf: real): integer;
  31 ( 5409) {**************************}
  32 ( 5409) begin
  33 ( 5409)   if (rf>32767.5) then begin
  34 ( 5427)       write(invvid,'Integer value exceeds');
  35 ( 5455)       write(' upper limit, set to 32767');
  36 ( 5482)       writeln(norvid); fix:=$7fff;
  37 ( 5494)     end else if (rf<-32768.5) then begin
  38 ( 5515)       write(invvid,'Integer value exceeds');
  39 ( 5543)       write(' lower limit, set to -32768');
  40 ( 5571)       writeln(norvid); fix:=$8000;
  41 ( 5583)     end else
  42 ( 5587)     fix:=trunc(rf);
  43 ( 5596) end;
  44 ( 5601) 
  45 ( 5602) proc checkfor(c: char);
  46 ( 5602) {*********************}
  47 ( 5602) begin
  48 ( 5602)   if ch<>c then begin
  49 ( 5616)     write(invvid,'SYNTAX ERROR: expected ');
  50 ( 5646)     if c=cr then write('<eol>')
  51 ( 5662)     else write(c);
  52 ( 5670)     write(' but found ');
  53 ( 5682)     if ch=cr then writeln('<eol>',norvid)
  54 ( 5700)     else writeln(ch,norvid);
  55 ( 5724)   end;
  56 ( 5724) end;
  57 ( 5724) 
  58 ( 5725) proc skip(c:char);
  59 ( 5725) {****************}

----------------------------------------------------------------------

R65 COMPILE 4.2: program CALC             14/11/23 page 2

  60 ( 5725) begin
  61 ( 5725)   checkfor(c); read(@input,ch);
  62 ( 5748) end;
  63 ( 5749) 
  64 ( 5750) func isnumber(cn:char):boolean;
  65 ( 5750) {*****************************}
  66 ( 5750) begin
  67 ( 5750)   isnumber:=(cn>='0') and (cn<='9');
  68 ( 5769) end;
  69 ( 5774) 
  70 ( 5775) proc writehex(f:file; r: integer);
  71 ( 5775) {********************************}
  72 ( 5775) var mask, m, n, r1: integer;
  73 ( 5778) begin
  74 ( 5778)   write(@f,'$'); mask := $f000; n := 12;
  75 ( 5797)   while mask <>0 do begin
  76 ( 5811)     r1 := (r and mask) shr n;
  77 ( 5820)     if r1 < 10 then write(@f,r1)
  78 ( 5844)     else  write(@f,chr(ord(r1)+ord('A')-10));
  79 ( 5871)     mask := mask shr 4; n := n - 4;
  80 ( 5888)   end;
  81 ( 5893) end;
  82 ( 5896) 
  83 ( 5897) proc writebinary(f:file; r: integer);
  84 ( 5897) {***********************************}
  85 ( 5897) var mask: integer;
  86 ( 5900) begin
  87 ( 5900)   write(@f,'% '); mask := $8000;
  88 ( 5914)   while mask <> 0 do begin
  89 ( 5928)    if (r and mask) <> 0 then write(@f,'1')
  90 ( 5950)    else write(@f,'0');
  91 ( 5962)    mask := mask shr 1;
  92 ( 5968)    if mask = $0800 then write(@f,' ');
  93 ( 5992)    if mask = $0080 then write(@f,' ');
  94 ( 6010)    if mask = $0008 then write(@f,' ');
  95 ( 6028)   end;
  96 ( 6028) end;
  97 ( 6031) 
  98 ( 6032) proc writeauto(f:file;r:real);
  99 ( 6032) {****************************}
 100 ( 6032) { outputs 5 digits }
 101 ( 6032) var m,m1,max,rnd: real;
 102 ( 6035)     i1,d1:integer;
 103 ( 6035)     sign: char;
 104 ( 6035) begin
 105 ( 6035)   sign:=' '; m:=r;
 106 ( 6043)   if m<0. then begin
 107 ( 6068)     sign:='-'; m:=-m;
 108 ( 6077)   end;
 109 ( 6090)   if dotused and (m>=10000.0) then writeflo(f,r)
 110 ( 6115)   else if m=0. then begin
 111 ( 6143)     write(@f,' 0',tab8,tab8); writehex(f,0);
 112 ( 6173)     write(@f,'  ',tab8); writebinary(f,0);
 113 ( 6197)   end else if r=conv($8000) then begin
 114 ( 6211)     write(@f,'-32768',tab8,tab8); write(@f,'$8000');
 115 ( 6245)     write(@f,'  ',tab8);
 116 ( 6257)     write(@f,'% 1000 0000 0000 0000');
 117 ( 6285)   end else if m>=32767.5 then writeflo(f,r)
 118 ( 6308)   else if m<0.01 then writeflo(f,r)
 119 ( 6343)   else begin

----------------------------------------------------------------------

R65 COMPILE 4.2: program CALC             14/11/23 page 3

 120 ( 6358)     if m>=10000. then begin
 121 ( 6371)       d1:=0; rnd:=0.5
 122 ( 6380)     end else if m>=1000. then begin
 123 ( 6408)       d1:=1; rnd:=0.05
 124 ( 6417)     end else if m>=100. then begin
 125 ( 6445)       d1:=2; rnd:=0.005
 126 ( 6454)     end else if m>=10. then begin
 127 ( 6482)       d1:=3; rnd:=0.0005
 128 ( 6491)     end else if m>=1. then begin
 129 ( 6519)       d1:=4; rnd:=0.00005
 130 ( 6528)     end else if m>=0.1 then begin
 131 ( 6556)       d1:=5; rnd:=0.000005
 132 ( 6565)     end else begin
 133 ( 6580)       d1:=6; rnd:=0.0000005
 134 ( 6586)     end;
 135 ( 6598)     m:=m+rnd; { round }
 136 ( 6617)     write(@f,sign,trunc(m));
 137 ( 6636)     m1:=m-conv(trunc(m));
 138 ( 6649)     if d1>0 then write(@f,'.');
 139 ( 6675)     for i1:=1 to d1 do begin
 140 ( 6694)       m1:=10.*m1; write(@f,trunc(m1));
 141 ( 6727)       m1:=m1-conv(trunc(m1));
 142 ( 6740)     end;
 143 ( 6748)     write(@f,'  ',tab8); writehex(f,trunc(r+rnd));
 144 ( 6798)     write(@f,'  ',tab8); writebinary(f,trunc(r+rnd))
 145 ( 6827)   end;
 146 ( 6834) end;
 147 ( 6834) 
 148 ( 6835) func express:real;
 149 ( 6835) {****************}
 150 ( 6835) var
 151 ( 6835)   re: real;
 152 ( 6838) 
 153 ( 6838) func binval: integer;
 154 ( 6838) {*******************}
 155 ( 6838) begin
 156 ( 6838)   if (ch='0') then binval:=0
 157 ( 6853)   else if (ch='1') then binval:=1
 158 ( 6872)   else binval:=-1;
 159 ( 6883) end;
 160 ( 6888) 
 161 ( 6889) func hexval: integer;
 162 ( 6889) {*******************}
 163 ( 6889) begin
 164 ( 6889)   if (ch>='0') and (ch<='9')
 165 ( 6907)     then hexval:=ord(ch)-ord('0')
 166 ( 6918)   else if (ch>='A') and (ch<='F')
 167 ( 6939)     then hexval:=ord(ch)-ord('A')+10
 168 ( 6951)   else hexval:=-1;
 169 ( 6963) end;
 170 ( 6968) 
 171 ( 6969) func isletter(ch:char):boolean;
 172 ( 6969) {*****************************}
 173 ( 6969) begin
 174 ( 6969)   isletter:=(ord(ch)>=ord('A'))and(ord(ch)<=ord('Z'))
 175 ( 6987) end;
 176 ( 6993) 
 177 ( 6994) func function:real;
 178 ( 6994) {*****************}
 179 ( 6994) var i: integer;

----------------------------------------------------------------------

R65 COMPILE 4.2: program CALC             14/11/23 page 4

 180 ( 6997)     r: real;
 181 ( 6997)     lstring: cpnt;
 182 ( 6997) begin
 183 ( 6997)   lstring:=strnew;
 184 ( 7005)   lstring[0]:=chr(0);
 185 ( 7013)   strins(ch,0,lstring); read(@input,ch); i:=1;
 186 ( 7045)   while isletter(ch) do begin
 187 ( 7064)     strins(ch,i,lstring); read(@input,ch); i:=i+1;
 188 ( 7097)   end;
 189 ( 7102)   stop:=false;
 190 ( 7107)   if strcmp(lstring,'R')=0 then begin
 191 ( 7130)     function:=lastr; release(lstring); exit;
 192 ( 7156)   end;
 193 ( 7156)   if strcmp(lstring,'PI')=0 then begin
 194 ( 7176)     function:=pi; release(lstring); exit;
 195 ( 7202)   end;
 196 ( 7202)   if strcmp(lstring,'E')=0 then begin
 197 ( 7221)     function:=e; release(lstring); exit;
 198 ( 7247)   end;
 199 ( 7247)   { functions with single argument follow }
 200 ( 7247)   checkfor('('); r:=express; skip(')');
 201 ( 7275)   if strcmp(lstring,'SQR')=0 then begin
 202 ( 7296)     function:=r*r; release(lstring); exit;
 203 ( 7329)   end;
 204 ( 7329)   if strcmp(lstring,'SQRT')=0 then begin
 205 ( 7351)     function:=sqrt(r); release(lstring); exit;
 206 ( 7385)   end;
 207 ( 7385)   if strcmp(lstring,'SIN')=0 then begin
 208 ( 7406)     function:=sin(r); release(lstring); exit;
 209 ( 7440)   end;
 210 ( 7440)   if strcmp(lstring,'COS')=0 then begin
 211 ( 7461)     function:=cos(r); release(lstring); exit;
 212 ( 7495)   end;
 213 ( 7495)   if strcmp(lstring,'TAN')=0 then begin
 214 ( 7516)     function:=tan(r); release(lstring); exit;
 215 ( 7550)   end;
 216 ( 7550)   if strcmp(lstring,'EXP')=0 then begin
 217 ( 7571)     function:=exp(r); release(lstring); exit;
 218 ( 7605)   end;
 219 ( 7605)   if strcmp(lstring,'LN')=0 then begin
 220 ( 7625)     function:=ln(r); release(lstring); exit;
 221 ( 7659)   end;
 222 ( 7659)   if strcmp(lstring,'LOG')=0 then begin
 223 ( 7680)     function:=log(r); release(lstring); exit;
 224 ( 7714)   end;
 225 ( 7714)   writeln(invvid,'Unknown function ',lstring,norvid);
 226 ( 7749)   function:=0.0;
 227 ( 7755)   release(lstring);
 228 ( 7771) end;
 229 ( 7771) 
 230 ( 7772) func factor:real;
 231 ( 7772) {***************}
 232 ( 7772) var negative:boolean;
 233 ( 7775)     rf,rt: real;
 234 ( 7775)     i,iv: integer;
 235 ( 7775) begin
 236 ( 7775)   negative:=false; rf:=0.;  read(@input,ch);
 237 ( 7803)   if ch='-' then begin
 238 ( 7811)     negative:=true; read(@input,ch);
 239 ( 7828)   end;

----------------------------------------------------------------------

R65 COMPILE 4.2: program CALC             14/11/23 page 5

 240 ( 7829)   if ch='(' then begin
 241 ( 7836)     stop:=false; rf:=express;
 242 ( 7851)     checkfor(')'); read(@input,ch);
 243 ( 7873)   end else if ch='%' then begin
 244 ( 7884)     stop:=false; read(@input,ch); iv:=0;
 245 ( 7904)     while binval>=0 do begin
 246 ( 7920)       iv:=(iv shl 1)+binval; read(@input,ch);
 247 ( 7946)     end;
 248 ( 7947)     rf:=conv(iv);
 249 ( 7954)   end else if ch='$' then begin
 250 ( 7971)     stop:=false; read(@input,ch); iv:=0;
 251 ( 7991)     while hexval>=0 do begin
 252 ( 8007)       iv:=(iv shl 4)+hexval; read(@input,ch);
 253 ( 8033)     end;
 254 ( 8034)     rf:=conv(iv);
 255 ( 8041)   end else if isletter(ch) then begin
 256 ( 8063)     write(invvid); rf:=function; write(norvid)
 257 ( 8083)   end else if ch<>chr(0) then begin
 258 ( 8095)     if ch<>cr then begin
 259 ( 8105)       if ch<>cr then stop:=false;
 260 ( 8120)       if ch='+' then read(@input,ch);
 261 ( 8142)       {if ch='-' then begin
 262 ( 8143)         negative:=true; read(@input,ch);
 263 ( 8143)       end;}
 264 ( 8143)       if not isnumber(ch) then
 265 ( 8155)         writeln(invvid,
 266 ( 8161)           'SYNTAX ERROR: NUMBER EXPECTED',norvid);
 267 ( 8201)       while isnumber(ch) do begin
 268 ( 8216)         rt:=rf+rf; rt:=rt+rt;
 269 ( 8241)         rf:=rt+rt+rf+rf+conv(ord(ch)-ord('0'));
 270 ( 8288)         read(@input,ch);
 271 ( 8304)       end;
 272 ( 8305)       if ch='.' then begin
 273 ( 8315)         dotused:=true; read(@input,ch); rt:=0.1;
 274 ( 8339)         while isnumber(ch) do begin
 275 ( 8360)           rf:=rf+conv(ord(ch)-ord('0'))*rt;
 276 ( 8374)           rt:=rt/10.; read(@input,ch);
 277 ( 8415)         end;
 278 ( 8416)       end;
 279 ( 8419)     end;
 280 ( 8419)     if negative then rf:=-rf;
 281 ( 8426)   end;
 282 ( 8439)   factor:=rf;
 283 ( 8439) end;
 284 ( 8451) 
 285 ( 8452) func simexp:real;
 286 ( 8452) {***************}
 287 ( 8452) var
 288 ( 8452)   rs: real;
 289 ( 8455) begin
 290 ( 8455)   rs:=factor;
 291 ( 8463)   while (ch='*') or (ch='/') or (ch='&') or (ch='<')
 292 ( 8498)     or (ch='>') do begin
 293 ( 8511)     case ch of
 294 ( 8511)       '*': begin rs:=rs*factor; end;
 295 ( 8541)       '/': begin rs:=rs/factor; end;
 296 ( 8570)       '&': begin
 297 ( 8580)              rs:=conv(fix(rs) and fix(factor));
 298 ( 8609)            end;
 299 ( 8616)       '<': begin

----------------------------------------------------------------------

R65 COMPILE 4.2: program CALC             14/11/23 page 6

 300 ( 8626)              read(@input,ch); checkfor('<');
 301 ( 8643)              rs:=conv(fix(rs) shl fix(factor));
 302 ( 8672)              end;
 303 ( 8679)       '>': begin
 304 ( 8689)              read(@input,ch); checkfor('>');
 305 ( 8706)              rs:=conv(fix(rs) shr fix(factor));
 306 ( 8735)            end
 307 ( 8742)       end {case};
 308 ( 8744)   end;
 309 ( 8744)   simexp:=rs;
 310 ( 8747) end;
 311 ( 8759) 
 312 ( 8760) {********body of express********}
 313 ( 8760) begin
 314 ( 8760)   re:=simexp;
 315 ( 8768)   while (ch='+') or (ch='-') or (ch='|') do begin
 316 ( 8800)     case ch of
 317 ( 8800)       '+': begin re:=re+simexp; end;
 318 ( 8830)       '-': begin re:=re-simexp; end;
 319 ( 8859)       '|': begin
 320 ( 8869)              re:=conv(fix(re) or fix(factor));
 321 ( 8898)            end
 322 ( 8905)     end {case};
 323 ( 8907)   end;
 324 ( 8907)   express:=re;
 325 ( 8910) end;
 326 ( 8922) 
 327 ( 8923) {*********main body********}
 328 ( 8923) begin
 329 ( 8923)   write(invvid);
 330 ( 8928)   writeln('Enter an expression, for example:        ');
 331 ( 8976)   writeln('32767      input decimal number          ');
 332 ( 9024)   writeln('$FFF       input hex number              ');
 333 ( 9072)   writeln('%1101      input binary number           ');
 334 ( 9120)   writeln('-55.35     input negative number         ');
 335 ( 9168)   writeln('2*(5+28)   math expression               ');
 336 ( 9216)   writeln('R*3        last result                   ');
 337 ( 9264)   writeln('<return>,<esc>    exit                   ');
 338 ( 9312)   writeln('Operators: +,-,*,/,(),&,|,<<,>>          ');
 339 ( 9360)   writeln('Functions: SQRT(),SQR(),SIN(),COS()      ');
 340 ( 9408)   writeln('           TAN(),EXP(),LN(),LOG()        ');
 341 ( 9456)   writeln(norvid);
 342 ( 9465)   r:=0.0; lastr:=0.0; dotused:=false;
 343 ( 9491)   repeat
 344 ( 9495)     stop:=true; writeauto(output,r); writeln;
 345 ( 9515)     dotused:=false; lastr:=r; r:=express; checkfor(cr);
 346 ( 9559)   until stop;
 347 ( 9559) end.

End compile

Code lenght:          9565
Compiler stack size:  120
Ident stack size:     124
Pascal errors:        0
