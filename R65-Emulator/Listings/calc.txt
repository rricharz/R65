
R65 COMPILE 4.2: program CALC             6/12/23 page 1


   1 (    4)  {
   2 (    4)    Pascal CALC for R65 computer system
   3 (    4) 
   4 (    4)    Note: The R65 Pascal system used
   5 (    4)    32 bit floating point representation,
   6 (    4)    which is not suitable for serious
   7 (    4)    calculations, but was widely used
   8 (    4)    in early 8-bit microprocessor
   9 (    4)    systems. CALC tries to handle
  10 (    4)    this limited accuracy.
  11 (    4) 
  12 (    4)    Written 2019-2023 by rricharz  }
  13 (    4) 
  14 (    4) program calc;
  15 (    4) uses syslib,mathlib,strlib,ledlib;
  16 ( 5524) 
  17 ( 5524) mem vidpnt=$00e9:integer;
  18 ( 5527) 
  19 ( 5527) var ch: char;
  20 ( 5527)     r,lastr: real;
  21 ( 5527)     stop,dotused,firsterror: boolean;
  22 ( 5527) 
  23 ( 5527) proc clearinput;
  24 ( 5527) {**************}
  25 ( 5527) begin
  26 ( 5527)   buffpn:=-1;
  27 ( 5534) end;
  28 ( 5539) 
  29 ( 5540) proc error(s1,s2:cpnt);
  30 ( 5540) {*********************}
  31 ( 5540) begin
  32 ( 5540)   if firsterror then
  33 ( 5545)     writeln(invvid,'Error: ',s1,' ',s2,norvid);
  34 ( 5584)   firsterror:=false;
  35 ( 5586) end;
  36 ( 5590) 
  37 ( 5591) proc readch;
  38 ( 5591) begin
  39 ( 5591)   if firsterror then read(@input,ch)
  40 ( 5606)   else ch:=cr;
  41 ( 5617) end;
  42 ( 5621) 
  43 ( 5622) proc release(s: cpnt);
  44 ( 5622) {********************}
  45 ( 5622) { Only the last allocated string can be released }
  46 ( 5622) { This is suitable for recursive functions }
  47 ( 5622) mem endstk=$000e: integer;
  48 ( 5625) begin
  49 ( 5625)   if cpnt(endstk)=s then endstk:=endstk+strsize
  50 ( 5641)   else error('Cannot release string',' ');
  51 ( 5684) end;
  52 ( 5684) 
  53 ( 5685) func fix(rf: real): integer;
  54 ( 5685) {**************************}
  55 ( 5685) begin
  56 ( 5685)   if (rf>32767.5) then begin
  57 ( 5703)       error('Integer value exceeds',
  58 ( 5730)         'upper limit, set to 32767');
  59 ( 5764)       fix:=$7fff;

----------------------------------------------------------------------

R65 COMPILE 4.2: program CALC             6/12/23 page 2

  60 ( 5767)     end else if (rf<-32768.5) then begin
  61 ( 5788)       error('Integer value exceeds',
  62 ( 5815)         ' lower limit, set to -32768');
  63 ( 5851)       fix:=$8000;
  64 ( 5854)     end else
  65 ( 5858)     fix:=trunc(rf);
  66 ( 5867) end;
  67 ( 5872) 
  68 ( 5873) proc checkfor(c: char);
  69 ( 5873) {*********************}
  70 ( 5873) var s1,s2:cpnt;
  71 ( 5876) begin
  72 ( 5876)   if ch<>c then begin
  73 ( 5887)     s1:=strnew; s2:=strnew;
  74 ( 5906)     strcpy('Expected ',s1);
  75 ( 5932)     if c=cr then strcpy('Expected <eol>',s1)
  76 ( 5959)     else strinsc(c,9,s1);
  77 ( 5988)     strcpy('but found ',s2);
  78 ( 6011)     if ch=cr then strcpy('but found <eol>',s2)
  79 ( 6039)     else strinsc(ch,10,s2);
  80 ( 6068)     error(s1,s2);
  81 ( 6082)     release(s2); release(s1);
  82 ( 6102)   end;
  83 ( 6102) end;
  84 ( 6102) 
  85 ( 6103) proc skip(c:char);
  86 ( 6103) {****************}
  87 ( 6103) begin
  88 ( 6103)   checkfor(c); readch;
  89 ( 6122) end;
  90 ( 6122) 
  91 ( 6123) func isnumber(cn:char):boolean;
  92 ( 6123) {*****************************}
  93 ( 6123) begin
  94 ( 6123)   isnumber:=(cn>='0') and (cn<='9');
  95 ( 6142) end;
  96 ( 6147) 
  97 ( 6148) proc writehex(f:file; r: integer);
  98 ( 6148) {********************************}
  99 ( 6148) var mask, m, n, r1: integer;
 100 ( 6151) begin
 101 ( 6151)   write(@f,'$'); mask := $f000; n := 12;
 102 ( 6170)   while mask <>0 do begin
 103 ( 6184)     r1 := (r and mask) shr n;
 104 ( 6193)     if r1 < 10 then write(@f,r1)
 105 ( 6217)     else  write(@f,chr(ord(r1)+ord('A')-10));
 106 ( 6244)     mask := mask shr 4; n := n - 4;
 107 ( 6261)   end;
 108 ( 6266) end;
 109 ( 6269) 
 110 ( 6270) proc writebinary(f:file; r: integer);
 111 ( 6270) {***********************************}
 112 ( 6270) var mask: integer;
 113 ( 6273) begin
 114 ( 6273)   write(@f,'% '); mask := $8000;
 115 ( 6287)   while mask <> 0 do begin
 116 ( 6301)    if (r and mask) <> 0 then write(@f,'1')
 117 ( 6323)    else write(@f,'0');
 118 ( 6335)    mask := mask shr 1;
 119 ( 6341)    if mask = $0800 then write(@f,' ');

----------------------------------------------------------------------

R65 COMPILE 4.2: program CALC             6/12/23 page 3

 120 ( 6365)    if mask = $0080 then write(@f,' ');
 121 ( 6383)    if mask = $0008 then write(@f,' ');
 122 ( 6401)   end;
 123 ( 6401) end;
 124 ( 6404) 
 125 ( 6405) proc showled(s1:cpnt);
 126 ( 6405) {********************}
 127 ( 6405) var s2:cpnt;
 128 ( 6408)     pos1,i,mask:integer;
 129 ( 6408) begin
 130 ( 6408)   s2:=strnew;
 131 ( 6416)   { s1 is left justfied (except space for minus}
 132 ( 6420)   { s1 has no end mark and should not be modified }
 133 ( 6420)   mask:=0;
 134 ( 6422)   for i:=11 downto 0 do begin
 135 ( 6443)     if (s1[i]<>' ') and (s1[i]<>'+') then begin
 136 ( 6470)       if s1[i]='.' then
 137 ( 6485)         mask:=128
 138 ( 6489)       else begin
 139 ( 6498)         strinsc(chr(ord(s1[i]) or mask),0,s2);
 140 ( 6526)         mask:=0;
 141 ( 6528)       end;
 142 ( 6532)     end;
 143 ( 6532)   end;
 144 ( 6532)   while strlen(s2)<8 do strinsc(' ',0,s2);
 145 ( 6578)   if (strlen(s2)>8) and (s2[7]='0') and
 146 ( 6607)     (s2[6]='-') and (s2[5]='e') then strdelc(7,s2);
 147 ( 6647)   if strlen(s2)>8 then strcpy('--------',s2);
 148 ( 6686)   ledstring(s2);
 149 ( 6696)   release(s2);
 150 ( 6706) end;
 151 ( 6706) 
 152 ( 6707) proc writeauto(f:file;r:real);
 153 ( 6707) {****************************}
 154 ( 6707) { outputs 5 digits }
 155 ( 6707) var m,m1,max,rnd: real;
 156 ( 6710)     i1,d1:integer;
 157 ( 6710)     sign: char;
 158 ( 6710)     s1:cpnt;
 159 ( 6710) begin
 160 ( 6710)   { 7-segment display is copy of video memory }
 161 ( 6710)   s1:=cpnt(vidpnt);
 162 ( 6715)   sign:=' '; m:=r;
 163 ( 6725)   if m<0. then begin
 164 ( 6750)     sign:='-'; m:=-m;
 165 ( 6759)   end;
 166 ( 6772)   if dotused and (m>=10000.0) then writeflo(f,r)
 167 ( 6797)   else if m=0. then begin
 168 ( 6825)     write(@f,' 0',tab8,tab8); writehex(f,0);
 169 ( 6855)     write(@f,'  ',tab8); writebinary(f,0);
 170 ( 6879)   end else if r=conv($8000) then begin
 171 ( 6893)     write(@f,'-32768',tab8,tab8); write(@f,'$8000');
 172 ( 6927)     write(@f,'  ',tab8);
 173 ( 6939)     write(@f,'% 1000 0000 0000 0000');
 174 ( 6967)   end else if m>=32767.5 then writeflo(f,r)
 175 ( 6990)   else if m<0.01 then writeflo(f,r)
 176 ( 7025)   else begin
 177 ( 7040)     if m>=10000. then begin
 178 ( 7053)       d1:=0; rnd:=0.5
 179 ( 7062)     end else if m>=1000. then begin

----------------------------------------------------------------------

R65 COMPILE 4.2: program CALC             6/12/23 page 4

 180 ( 7090)       d1:=1; rnd:=0.05
 181 ( 7099)     end else if m>=100. then begin
 182 ( 7127)       d1:=2; rnd:=0.005
 183 ( 7136)     end else if m>=10. then begin
 184 ( 7164)       d1:=3; rnd:=0.0005
 185 ( 7173)     end else if m>=1. then begin
 186 ( 7201)       d1:=4; rnd:=0.00005
 187 ( 7210)     end else if m>=0.1 then begin
 188 ( 7238)       d1:=5; rnd:=0.000005
 189 ( 7247)     end else begin
 190 ( 7262)       d1:=6; rnd:=0.0000005
 191 ( 7268)     end;
 192 ( 7280)     m:=m+rnd; { round }
 193 ( 7299)     write(@f,sign,trunc(m));
 194 ( 7318)     m1:=m-conv(trunc(m));
 195 ( 7331)     if m1<=rnd then begin
 196 ( 7352)       for i1:=1 to d1+1 do write(@f,' ');
 197 ( 7385)       d1:=0;
 198 ( 7401)     end;
 199 ( 7405)     if d1>0 then write(@f,'.');
 200 ( 7423)     for i1:=1 to d1 do begin
 201 ( 7442)       m1:=10.*m1; write(@f,trunc(m1));
 202 ( 7475)       m1:=m1-conv(trunc(m1));
 203 ( 7488)     end;
 204 ( 7496)     write(@f,'  ',tab8); writehex(f,trunc(r+rnd));
 205 ( 7546)     write(@f,'  ',tab8); writebinary(f,trunc(r+rnd))
 206 ( 7575)   end;
 207 ( 7582)   showled(s1);
 208 ( 7592) end;
 209 ( 7592) 
 210 ( 7593) func express:real;
 211 ( 7593) {****************}
 212 ( 7593) var
 213 ( 7593)   re: real;
 214 ( 7596) 
 215 ( 7596) func binval: integer;
 216 ( 7596) {*******************}
 217 ( 7596) begin
 218 ( 7596)   if (ch='0') then binval:=0
 219 ( 7611)   else if (ch='1') then binval:=1
 220 ( 7630)   else binval:=-1;
 221 ( 7641) end;
 222 ( 7646) 
 223 ( 7647) func hexval: integer;
 224 ( 7647) {*******************}
 225 ( 7647) begin
 226 ( 7647)   if (ch>='0') and (ch<='9')
 227 ( 7665)     then hexval:=ord(ch)-ord('0')
 228 ( 7676)   else if (ch>='A') and (ch<='F')
 229 ( 7697)     then hexval:=ord(ch)-ord('A')+10
 230 ( 7709)   else hexval:=-1;
 231 ( 7721) end;
 232 ( 7726) 
 233 ( 7727) func isletter(ch:char):boolean;
 234 ( 7727) {*****************************}
 235 ( 7727) begin
 236 ( 7727)   isletter:=(ord(ch)>=ord('A'))and(ord(ch)<=ord('Z'))
 237 ( 7745) end;
 238 ( 7751) 
 239 ( 7752) func function:real;

----------------------------------------------------------------------

R65 COMPILE 4.2: program CALC             6/12/23 page 5

 240 ( 7752) {*****************}
 241 ( 7752) var i: integer;
 242 ( 7755)     r: real;
 243 ( 7755)     lstring: cpnt;
 244 ( 7755) begin
 245 ( 7755)   lstring:=strnew;
 246 ( 7763)   lstring[0]:=chr(0);
 247 ( 7771)   strinsc(ch,0,lstring); readch; i:=1;
 248 ( 7798)   while isletter(ch) do begin
 249 ( 7817)     strinsc(ch,i,lstring); readch; i:=i+1;
 250 ( 7845)   end;
 251 ( 7850)   stop:=false;
 252 ( 7855)   if strcmp(lstring,'R')=0 then begin
 253 ( 7878)     function:=lastr; release(lstring); exit;
 254 ( 7904)   end;
 255 ( 7904)   if strcmp(lstring,'PI')=0 then begin
 256 ( 7924)     function:=pi; release(lstring); exit;
 257 ( 7950)   end;
 258 ( 7950)   if strcmp(lstring,'E')=0 then begin
 259 ( 7969)     function:=e; release(lstring); exit;
 260 ( 7995)   end;
 261 ( 7995)   { functions with single argument follow }
 262 ( 7995)   checkfor('('); r:=express; skip(')');
 263 ( 8023)   if strcmp(lstring,'SQR')=0 then begin
 264 ( 8044)     function:=r*r; release(lstring); exit;
 265 ( 8077)   end;
 266 ( 8077)   if strcmp(lstring,'SQRT')=0 then begin
 267 ( 8099)     function:=sqrt(r); release(lstring); exit;
 268 ( 8133)   end;
 269 ( 8133)   if strcmp(lstring,'SIN')=0 then begin
 270 ( 8154)     function:=sin(r); release(lstring); exit;
 271 ( 8188)   end;
 272 ( 8188)   if strcmp(lstring,'COS')=0 then begin
 273 ( 8209)     function:=cos(r); release(lstring); exit;
 274 ( 8243)   end;
 275 ( 8243)   if strcmp(lstring,'TAN')=0 then begin
 276 ( 8264)     function:=tan(r); release(lstring); exit;
 277 ( 8298)   end;
 278 ( 8298)   if strcmp(lstring,'EXP')=0 then begin
 279 ( 8319)     function:=exp(r); release(lstring); exit;
 280 ( 8353)   end;
 281 ( 8353)   if strcmp(lstring,'LN')=0 then begin
 282 ( 8373)     function:=ln(r); release(lstring); exit;
 283 ( 8407)   end;
 284 ( 8407)   if strcmp(lstring,'LOG')=0 then begin
 285 ( 8428)     function:=log(r); release(lstring); exit;
 286 ( 8462)   end;
 287 ( 8462)   error('Unknow function',lstring);
 288 ( 8490)   function:=0.0;
 289 ( 8496)   release(lstring);
 290 ( 8512) end;
 291 ( 8512) 
 292 ( 8513) proc exponent(var r:real);
 293 ( 8513) {************************}
 294 ( 8513) var minus:boolean;
 295 ( 8516)     exp:integer;
 296 ( 8516) begin
 297 ( 8516)   minus:=false;
 298 ( 8520)   if ch='-' then begin minus:=true; readch end
 299 ( 8544)   else if ch='+' then readch;

----------------------------------------------------------------------

R65 COMPILE 4.2: program CALC             6/12/23 page 6

 300 ( 8561)   exp:=0;
 301 ( 8563)   if isnumber(ch) then begin
 302 ( 8579)     exp:=ord(ch)-ord('0'); readch
 303 ( 8593)   end else error('Expecting','exponent');
 304 ( 8629)   if isnumber(ch) then begin
 305 ( 8641)     exp:=10*exp+(ord(ch)-ord('0')); readch;
 306 ( 8667)   end;
 307 ( 8667)   if minus then
 308 ( 8667)     while exp>0 do begin r:=0.1*r; exp:=exp-1 end
 309 ( 8709)   else
 310 ( 8714)     while exp>0 do begin r:=10.0*r; exp:=exp-1 end;
 311 ( 8760) end;
 312 ( 8763) 
 313 ( 8764) func factor:real;
 314 ( 8764) {***************}
 315 ( 8764) var negative:boolean;
 316 ( 8767)     rf,rt: real;
 317 ( 8767)     i,iv: integer;
 318 ( 8767) begin
 319 ( 8767)   negative:=false; rf:=0.;  readch;
 320 ( 8791)   if ch='-' then begin
 321 ( 8798)     negative:=true; readch;
 322 ( 8811)   end;
 323 ( 8811)   if ch='(' then begin
 324 ( 8818)     stop:=false; rf:=express;
 325 ( 8833)     checkfor(')'); readch;
 326 ( 8851)   end else if ch='%' then begin
 327 ( 8861)     stop:=false; readch; iv:=0;
 328 ( 8876)     while binval>=0 do begin
 329 ( 8892)       iv:=(iv shl 1)+binval; readch;
 330 ( 8914)     end;
 331 ( 8914)     rf:=conv(iv);
 332 ( 8921)   end else if ch='$' then begin
 333 ( 8938)     stop:=false; readch; iv:=0;
 334 ( 8953)     while hexval>=0 do begin
 335 ( 8969)       iv:=(iv shl 4)+hexval; readch;
 336 ( 8991)     end;
 337 ( 8991)     rf:=conv(iv);
 338 ( 8998)   end else if isletter(ch) then rf:=function
 339 ( 9023)   else if ch<>chr(0) then begin
 340 ( 9046)     if ch<>cr then begin
 341 ( 9056)       if ch<>cr then stop:=false;
 342 ( 9071)       if ch='+' then readch;
 343 ( 9089)       {if ch='-' then begin
 344 ( 9089)         negative:=true; readch;
 345 ( 9089)       end;}
 346 ( 9089)       if not isnumber(ch) then
 347 ( 9101)         error('Expected','number');
 348 ( 9131)       while isnumber(ch) do begin
 349 ( 9146)         rt:=rf+rf; rt:=rt+rt;
 350 ( 9171)         rf:=rt+rt+rf+rf+conv(ord(ch)-ord('0'));
 351 ( 9218)         readch;
 352 ( 9230)       end;
 353 ( 9230)       if ch='.' then begin
 354 ( 9240)         dotused:=true; readch; rt:=0.1;
 355 ( 9259)         while isnumber(ch) do begin
 356 ( 9280)           rf:=rf+conv(ord(ch)-ord('0'))*rt;
 357 ( 9294)           rt:=rt/10.; readch;
 358 ( 9331)         end;
 359 ( 9331)       end;

----------------------------------------------------------------------

R65 COMPILE 4.2: program CALC             6/12/23 page 7

 360 ( 9334)       if ch='E' then begin readch; exponent(rf) end;
 361 ( 9364)     end;
 362 ( 9364)     if negative then rf:=-rf;
 363 ( 9371)   end;
 364 ( 9384)   factor:=rf;
 365 ( 9384) end;
 366 ( 9396) 
 367 ( 9397) func simexp:real;
 368 ( 9397) {***************}
 369 ( 9397) var
 370 ( 9397)   rs,divisor: real;
 371 ( 9400) begin
 372 ( 9400)   rs:=factor;
 373 ( 9408)   while (ch='*') or (ch='/') or (ch='&') or (ch='<')
 374 ( 9443)     or (ch='>') or (ch='^') do begin
 375 ( 9464)     case ch of
 376 ( 9464)       '*': begin rs:=rs*factor; end;
 377 ( 9494)       '/': begin
 378 ( 9504)              divisor:=factor;
 379 ( 9510)              if divisor=0.0 then
 380 ( 9528)                error('Division','by zero')
 381 ( 9553)              else
 382 ( 9559)                rs:=rs/divisor;
 383 ( 9568)            end;
 384 ( 9581)       '&': rs:=conv(fix(rs) and fix(factor));
 385 ( 9620)       '^': rs:=exp(factor*ln(rs));
 386 ( 9666)       '<': begin
 387 ( 9682)              readch; checkfor('<');
 388 ( 9694)              rs:=conv(fix(rs) shl fix(factor));
 389 ( 9723)              end;
 390 ( 9730)       '>': begin
 391 ( 9740)              readch; checkfor('>');
 392 ( 9752)              rs:=conv(fix(rs) shr fix(factor));
 393 ( 9781)            end
 394 ( 9788)       end {case};
 395 ( 9790)   end;
 396 ( 9790)   simexp:=rs;
 397 ( 9793) end;
 398 ( 9805) 
 399 ( 9806) {********body of express********}
 400 ( 9806) begin
 401 ( 9806)   re:=simexp;
 402 ( 9814)   while (ch='+') or (ch='-') or (ch='|') do begin
 403 ( 9846)     case ch of
 404 ( 9846)       '+': begin re:=re+simexp; end;
 405 ( 9876)       '-': begin re:=re-simexp; end;
 406 ( 9905)       '|': begin
 407 ( 9915)              re:=conv(fix(re) or fix(factor));
 408 ( 9944)            end
 409 ( 9951)     end {case};
 410 ( 9953)   end;
 411 ( 9953)   express:=re;
 412 ( 9956) end;
 413 ( 9968) 
 414 ( 9969) {*********main body********}
 415 ( 9969) begin
 416 ( 9969)   write(invvid);
 417 ( 9974)   writeln('Enter an expression, for example:        ');
 418 (10022)   writeln('32767      input decimal number          ');
 419 (10070)   writeln('$FFF       input hex number              ');

----------------------------------------------------------------------

R65 COMPILE 4.2: program CALC             6/12/23 page 8

 420 (10118)   writeln('%1101      input binary number           ');
 421 (10166)   writeln('-55.35     input negative number         ');
 422 (10214)   writeln('2*(5+28)   math expression               ');
 423 (10262)   writeln('R*3        last result                   ');
 424 (10310)   writeln('<return>,<esc>    exit                   ');
 425 (10358)   writeln('Operators: +,-,*,/,^,(),&,|,<<,>>        ');
 426 (10406)   writeln('Functions: SQRT(),SQR(),SIN(),COS()      ');
 427 (10454)   writeln('           TAN(),EXP(),LN(),LOG()        ');
 428 (10502)   writeln(norvid);
 429 (10511)   r:=0.0; lastr:=0.0; dotused:=false;
 430 (10537)   repeat
 431 (10541)     firsterror:=true;
 432 (10543)     clearinput;
 433 (10551)     stop:=true; writeauto(output,r); writeln;
 434 (10571)     dotused:=false; lastr:=r; r:=express; checkfor(cr);
 435 (10615)   until stop;
 436 (10615) end.

End compile

Code lenght:          10621
Compiler stack size:  140
Ident stack size:     137
Pascal errors:        0
