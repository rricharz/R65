
R65 Pascal program CALC            9/11/23     page 1


                   1 (    4) {
                   2 (    4)    Pascal CALC for R65 computer system
                   3 (    4) 
                   4 (    4)    Note: The R65 Pascal system used
                   5 (    4)    32 bit floating point representation,
                   6 (    4)    which is not suitable for serious
                   7 (    4)    calculations, but was widely used
                   8 (    4)    in early 8-bit microprocessor
                   9 (    4)    systems. CALC tries to handle
                  10 (    4)    this limited accuracy.
                  11 (    4) 
                  12 (    4)    Written 2019-2023 by rricharz
                  13 (    4) 
                  14 (    4)    The following operators are allowed:
                  15 (    4) 
                  16 (    4)      +,-       prefix for decimal input
                  17 (    4)      +,-,*,/   arithmetic operators
                  18 (    4)      ()        brackets
                  19 (    4)      |,&       bitwise operators
                  20 (    4)      <<,>>     bitwise shift operators
                  21 (    4) 
                  22 (    4)      $XX..     hex numeric input
                  23 (    4)      %XX..     binary numeric input
                  24 (    4) }
                  25 (    4) 
                  26 (    4) program calc;
                  27 (    4) uses syslib,mathlib;
                  28 ( 3782) 
                  29 ( 3782) var ch: char;
                  30 ( 3785)     r,lastr: real;
                  31 ( 3785)     stop,dotused: boolean;
                  32 ( 3785) 
                  33 ( 3785) func fix(rf: real): integer;
                  34 ( 3785) {**************************}
                  35 ( 3785) begin
                  36 ( 3785)   if (rf>32767.5) then
                  37 ( 3803)     begin
                  38 ( 3803)       write(invvid,'Integer value exceeds');
                  39 ( 3831)       write(' upper limit, set to 32767');
                  40 ( 3858)       writeln(norvid);
                  41 ( 3867)       fix:=$7fff;
                  42 ( 3870)     end
                  43 ( 3874)   else if (rf<-32768.5) then
                  44 ( 3891)     begin
                  45 ( 3891)       write(invvid,'Integer value exceeds');
                  46 ( 3919)       write(' lower limit, set to -32768');
                  47 ( 3947)       writeln(norvid);
                  48 ( 3956)       fix:=$8000;
                  49 ( 3959)     end
                  50 ( 3963)   else
                  51 ( 3963)     fix:=trunc(rf);
                  52 ( 3972) end;
                  53 ( 3977) 
                  54 ( 3978) proc checkfor(c: char);
                  55 ( 3978) {*********************}
                  56 ( 3978) begin
                  57 ( 3978)   if ch<>c then
                  58 ( 3987)     begin
                  59 ( 3992)       write(invvid,'SYNTAX ERROR: expected ');

----------------------------------------------------------------------

R65 Pascal program CALC            9/11/23     page 2

                  60 ( 4022)       if c=cr then write('<eol>')
                  61 ( 4038)       else write(c);
                  62 ( 4046)       write(' but found ');
                  63 ( 4058)       if ch=cr then writeln('<eol>',norvid)
                  64 ( 4076)       else writeln(ch,norvid);
                  65 ( 4100)     end;
                  66 ( 4100) end;
                  67 ( 4100) 
                  68 ( 4101) func isnumber(cn:char):boolean;
                  69 ( 4101) {*****************************}
                  70 ( 4101) begin
                  71 ( 4101)   isnumber:=(cn>='0') and (cn<='9');
                  72 ( 4120) end;
                  73 ( 4125) 
                  74 ( 4126) proc writehex(f:file; r: integer);
                  75 ( 4126) {********************************}
                  76 ( 4126) var mask, m, n, r1: integer;
                  77 ( 4129) begin
                  78 ( 4129)   write(@f,'$'); mask := $f000; n := 12;
                  79 ( 4148)   while mask <>0 do
                  80 ( 4158)     begin
                  81 ( 4162)       r1 := (r and mask) shr n;
                  82 ( 4171)       if r1 < 10 then
                  83 ( 4186)         write(@f,r1)
                  84 ( 4195)       else
                  85 ( 4201)         write(@f,chr(ord(r1)+ord('A')-10));
                  86 ( 4222)       mask := mask shr 4; n := n - 4;
                  87 ( 4239)     end;
                  88 ( 4244) end;
                  89 ( 4247) 
                  90 ( 4248) proc writebinary(f:file; r: integer);
                  91 ( 4248) {***********************************}
                  92 ( 4248) var mask: integer;
                  93 ( 4251) begin
                  94 ( 4251)   write(@f,'% ');
                  95 ( 4262)   mask := $8000;
                  96 ( 4265)   while mask <> 0 do
                  97 ( 4275)     begin
                  98 ( 4279)       if (r and mask) <> 0 then write(@f,'1')
                  99 ( 4301)       else write(@f,'0');
                 100 ( 4313)       mask := mask shr 1;
                 101 ( 4319)       if mask = $0800 then write(@f,' ');
                 102 ( 4343)       if mask = $0080 then write(@f,' ');
                 103 ( 4361)       if mask = $0008 then write(@f,' ');
                 104 ( 4379)     end;
                 105 ( 4379) end;
                 106 ( 4382) 
                 107 ( 4383) proc writeauto(f:file;r:real);
                 108 ( 4383) {****************************}
                 109 ( 4383) { outputs 5 digits }
                 110 ( 4383) var m,m1,max,rnd: real;
                 111 ( 4386)     i1:integer;
                 112 ( 4386)     sign: char;
                 113 ( 4386)     d1: integer;
                 114 ( 4386) begin
                 115 ( 4386)   sign:=' '; m:=r;
                 116 ( 4394)   if m<0. then begin
                 117 ( 4419)     sign:='-'; m:=-m;
                 118 ( 4428)   end;
                 119 ( 4441)   if dotused then

----------------------------------------------------------------------

R65 Pascal program CALC            9/11/23     page 3

                 120 ( 4441)     writeflo(f,r)
                 121 ( 4452)   else if m=0. then
                 122 ( 4479)     begin
                 123 ( 4480)       write(@f,' 0',tab8,tab8); writehex(f,0);
                 124 ( 4510)       write(@f,'  ',tab8); writebinary(f,0);
                 125 ( 4534)     end
                 126 ( 4534)   else if r=conv($8000) then
                 127 ( 4546)     begin
                 128 ( 4548)       write(@f,'-32768',tab8,tab8); write(@f,'$8000');
                 129 ( 4582)       write(@f,'  ',tab8);
                 130 ( 4594)       write(@f,'% 1000 0000 0000 0000');
                 131 ( 4622)     end
                 132 ( 4622)   else if m>=32767.5 then writeflo(f,r)
                 133 ( 4645)   else if m<0.01 then writeflo(f,r)
                 134 ( 4680)   else begin
                 135 ( 4695)     if m>=10000. then begin d1:=0; rnd:=0.5 end
                 136 ( 4723)     else if m>=1000. then begin d1:=1; rnd:=0.05 end
                 137 ( 4760)     else if m>=100. then begin d1:=2; rnd:=0.005 end
                 138 ( 4797)     else if m>=10. then begin d1:=3; rnd:=0.0005 end
                 139 ( 4834)     else if m>=1. then begin d1:=4; rnd:=0.00005 end
                 140 ( 4871)     else if m>=0.1 then begin d1:=5; rnd:=0.000005 end
                 141 ( 4908)     else begin d1:=6; rnd:=0.0000005 end;
                 142 ( 4935)     m:=m+rnd; { round }
                 143 ( 4954)     write(@f,sign,trunc(m));
                 144 ( 4973)     m1:=m-conv(trunc(m));
                 145 ( 4986)     if d1>0 then write(@f,'.');
                 146 ( 5012)     for i1:=1 to d1 do begin
                 147 ( 5031)       m1:=10.*m1; write(@f,trunc(m1));
                 148 ( 5064)       m1:=m1-conv(trunc(m1));
                 149 ( 5077)     end;
                 150 ( 5085)     write(@f,'  ',tab8); writehex(f,trunc(r+rnd));
                 151 ( 5135)     write(@f,'  ',tab8); writebinary(f,trunc(r+rnd))
                 152 ( 5164)   end;
                 153 ( 5171) end;
                 154 ( 5171) 
                 155 ( 5172) func express:real;
                 156 ( 5172) {****************}
                 157 ( 5172) var
                 158 ( 5172)   re: real;
                 159 ( 5175) 
                 160 ( 5175) func binval: integer;
                 161 ( 5175) {*******************}
                 162 ( 5175) begin
                 163 ( 5175)   if (ch='0') then binval:=0
                 164 ( 5190)   else if (ch='1') then binval:=1
                 165 ( 5209)   else binval:=-1;
                 166 ( 5220) end;
                 167 ( 5225) 
                 168 ( 5226) func hexval: integer;
                 169 ( 5226) {*******************}
                 170 ( 5226) begin
                 171 ( 5226)   if (ch>='0') and (ch<='9')
                 172 ( 5244)     then hexval:=ord(ch)-ord('0')
                 173 ( 5255)   else if (ch>='A') and (ch<='F')
                 174 ( 5276)     then hexval:=ord(ch)-ord('A')+10
                 175 ( 5288)   else hexval:=-1;
                 176 ( 5300) end;
                 177 ( 5305) 
                 178 ( 5306) func factor:real;
                 179 ( 5306) {***************}

----------------------------------------------------------------------

R65 Pascal program CALC            9/11/23     page 4

                 180 ( 5306) var negative:boolean;
                 181 ( 5309)     rf,rt: real;
                 182 ( 5309)     i,iv: integer;
                 183 ( 5309) begin
                 184 ( 5309)   negative:=false; rf:=0.;
                 185 ( 5323)   read(@input,ch);
                 186 ( 5337)   if ch='(' then begin
                 187 ( 5345)     stop:=false; rf:=express;
                 188 ( 5360)     checkfor(')'); read(@input,ch);
                 189 ( 5382)   end else if ch='%' then begin
                 190 ( 5393)     stop:=false; read(@input,ch); iv:=0;
                 191 ( 5413)     while binval>=0 do begin
                 192 ( 5429)       iv:=(iv shl 1)+binval; read(@input,ch);
                 193 ( 5455)     end;
                 194 ( 5456)     rf:=conv(iv);
                 195 ( 5463)   end else if ch='$' then begin
                 196 ( 5480)     stop:=false;
                 197 ( 5485)     read(@input,ch);
                 198 ( 5497)     iv:=0;
                 199 ( 5500)     while hexval>=0 do begin
                 200 ( 5516)       iv:=(iv shl 4)+hexval; read(@input,ch);
                 201 ( 5542)     end;
                 202 ( 5543)     rf:=conv(iv);
                 203 ( 5550)   end else if ch='R' then begin
                 204 ( 5567)     rf:= lastr; read(@input,ch);
                 205 ( 5590)   end else if ch<>chr(0) then begin
                 206 ( 5602)     if ch<>cr then begin
                 207 ( 5612)       if ch<>cr then stop:=false;
                 208 ( 5627)       if ch='+' then read(@input,ch);
                 209 ( 5649)       if ch='-' then begin
                 210 ( 5657)         negative:=true; read(@input,ch);
                 211 ( 5674)       end;
                 212 ( 5675)       if not isnumber(ch) then
                 213 ( 5687)         writeln(invvid,
                 214 ( 5693)           'SYNTAX ERROR: NUMBER EXPECTED',norvid);
                 215 ( 5733)       while isnumber(ch) do begin
                 216 ( 5748)         rt:=rf+rf; rt:=rt+rt;
                 217 ( 5773)         rf:=rt+rt+rf+rf+conv(ord(ch)-ord('0'));
                 218 ( 5820)         read(@input,ch);
                 219 ( 5836)       end;
                 220 ( 5837)       if ch='.' then begin
                 221 ( 5847)         dotused:=true; read(@input,ch); rt:=0.1;
                 222 ( 5871)         while isnumber(ch) do begin
                 223 ( 5892)           rf:=rf+conv(ord(ch)-ord('0'))*rt;
                 224 ( 5906)           rt:=rt/10.;
                 225 ( 5932)           read(@input,ch);
                 226 ( 5947)         end;
                 227 ( 5948)       end;
                 228 ( 5951)     end;
                 229 ( 5951)     if negative then rf:=-rf;
                 230 ( 5958)   end;
                 231 ( 5971)   factor:=rf;
                 232 ( 5971) end;
                 233 ( 5983) 
                 234 ( 5984) func simexp:real;
                 235 ( 5984) {***************}
                 236 ( 5984) var
                 237 ( 5984)   rs: real;
                 238 ( 5987) begin
                 239 ( 5987)   rs:=factor;

----------------------------------------------------------------------

R65 Pascal program CALC            9/11/23     page 5

                 240 ( 5995)   while (ch='*') or (ch='/') or (ch='&') or (ch='<')
                 241 ( 6030)     or (ch='>') do begin
                 242 ( 6043)     case ch of
                 243 ( 6043)       '*': begin
                 244 ( 6054)              rs:=rs*factor;
                 245 ( 6066)            end;
                 246 ( 6073)       '/': begin
                 247 ( 6083)              rs:=rs/factor;
                 248 ( 6095)            end;
                 249 ( 6102)       '&': begin
                 250 ( 6112)              rs:=conv(fix(rs) and fix(factor));
                 251 ( 6141)            end;
                 252 ( 6148)       '<': begin
                 253 ( 6158)              read(@input,ch);
                 254 ( 6166)              checkfor('<');
                 255 ( 6175)              rs:=conv(fix(rs) shl fix(factor));
                 256 ( 6204)              end;
                 257 ( 6211)       '>': begin
                 258 ( 6221)              read(@input,ch);
                 259 ( 6229)              checkfor('>');
                 260 ( 6238)              rs:=conv(fix(rs) shr fix(factor));
                 261 ( 6267)            end
                 262 ( 6274)       end {case};
                 263 ( 6276)   end;
                 264 ( 6276)   simexp:=rs;
                 265 ( 6279) end;
                 266 ( 6291) 
                 267 ( 6292) {********body of express********}
                 268 ( 6292) begin
                 269 ( 6292)   re:=simexp;
                 270 ( 6300)   while (ch='+') or (ch='-') or (ch='|') do begin
                 271 ( 6332)     case ch of
                 272 ( 6332)       '+': begin
                 273 ( 6343)              re:=re+simexp;
                 274 ( 6355)            end;
                 275 ( 6362)       '-': begin
                 276 ( 6372)              re:=re-simexp;
                 277 ( 6384)            end;
                 278 ( 6391)       '|': begin
                 279 ( 6401)              re:=conv(fix(re) or fix(factor));
                 280 ( 6430)            end
                 281 ( 6437)     end {case};
                 282 ( 6439)   end;
                 283 ( 6439)   express:=re;
                 284 ( 6442) end;
                 285 ( 6454) 
                 286 ( 6455) {*********main body********}
                 287 ( 6455) begin
                 288 ( 6455)   writeln('Enter an expression, examples are:');
                 289 ( 6498)   writeln('32767     input decimal number');
                 290 ( 6535)   writeln('88.       force scientific display');
                 291 ( 6576)   writeln('$FFF      input hex number');
                 292 ( 6609)   writeln('%1101     input binary number');
                 293 ( 6645)   writeln('-55.35    input negative number');
                 294 ( 6683)   writeln('2*(5+28)  math expression');
                 295 ( 6715)   writeln('R*3       last result');
                 296 ( 6743)   writeln('<return>  exit');
                 297 ( 6764)   writeln('operators: +,-,*,/,(),&,|,<<,>>');
                 298 ( 6802)   r:=0.0; lastr:=0.0;
                 299 ( 6820)   dotused:=false;

----------------------------------------------------------------------

R65 Pascal program CALC            9/11/23     page 6

                 300 ( 6828)   repeat
                 301 ( 6832)     stop:=true;
                 302 ( 6834)     writeauto(output,r); writeln;
                 303 ( 6852)     dotused:=false; lastr:=r;
                 304 ( 6864)     r:=express; checkfor(cr);
                 305 ( 6896)   until stop;
                 306 ( 6896) end.
                 307 ( 6903) 

End compile

Code lenght:          6902
Compiler stack size:  82
Ident stack size:     99
Pascal errors:        0
