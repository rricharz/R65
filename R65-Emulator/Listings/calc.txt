
R65 COMPILE 4.2: program CALC             11/11/23 page 1


   1 (    4) {
   2 (    4)    Pascal CALC for R65 computer system
   3 (    4) 
   4 (    4)    Note: The R65 Pascal system used
   5 (    4)    32 bit floating point representation,
   6 (    4)    which is not suitable for serious
   7 (    4)    calculations, but was widely used
   8 (    4)    in early 8-bit microprocessor
   9 (    4)    systems. CALC tries to handle
  10 (    4)    this limited accuracy.
  11 (    4) 
  12 (    4)    Written 2019-2023 by rricharz
  13 (    4) 
  14 (    4)    The following operators are allowed:
  15 (    4) 
  16 (    4)      +,-       prefix for decimal input
  17 (    4)      +,-,*,/   arithmetic operators
  18 (    4)      ()        brackets
  19 (    4)      |,&       bitwise operators
  20 (    4)      <<,>>     bitwise shift operators
  21 (    4) 
  22 (    4)      $XX..     hex numeric input
  23 (    4)      %XX..     binary numeric input
  24 (    4) }
  25 (    4) 
  26 (    4) program calc;
  27 (    4) uses syslib,mathlib;
  28 ( 3782) 
  29 ( 3782) var ch: char;
  30 ( 3785)     r,lastr: real;
  31 ( 3785)     stop,dotused: boolean;
  32 ( 3785) 
  33 ( 3785) func fix(rf: real): integer;
  34 ( 3785) {**************************}
  35 ( 3785) begin
  36 ( 3785)   if (rf>32767.5) then
  37 ( 3803)     begin
  38 ( 3803)       write(invvid,'Integer value exceeds');
  39 ( 3831)       write(' upper limit, set to 32767');
  40 ( 3858)       writeln(norvid);
  41 ( 3867)       fix:=$7fff;
  42 ( 3870)     end
  43 ( 3874)   else if (rf<-32768.5) then
  44 ( 3891)     begin
  45 ( 3891)       write(invvid,'Integer value exceeds');
  46 ( 3919)       write(' lower limit, set to -32768');
  47 ( 3947)       writeln(norvid);
  48 ( 3956)       fix:=$8000;
  49 ( 3959)     end
  50 ( 3963)   else
  51 ( 3963)     fix:=trunc(rf);
  52 ( 3972) end;
  53 ( 3977) 
  54 ( 3978) proc checkfor(c: char);
  55 ( 3978) {*********************}
  56 ( 3978) begin
  57 ( 3978)   if ch<>c then
  58 ( 3987)     begin
  59 ( 3992)       write(invvid,'SYNTAX ERROR: expected ');

----------------------------------------------------------------------

R65 COMPILE 4.2: program CALC             11/11/23 page 2

  60 ( 4022)       if c=cr then write('<eol>')
  61 ( 4038)       else write(c);
  62 ( 4046)       write(' but found ');
  63 ( 4058)       if ch=cr then writeln('<eol>',norvid)
  64 ( 4076)       else writeln(ch,norvid);
  65 ( 4100)     end;
  66 ( 4100) end;
  67 ( 4100) 
  68 ( 4101) func isnumber(cn:char):boolean;
  69 ( 4101) {*****************************}
  70 ( 4101) begin
  71 ( 4101)   isnumber:=(cn>='0') and (cn<='9');
  72 ( 4120) end;
  73 ( 4125) 
  74 ( 4126) proc writehex(f:file; r: integer);
  75 ( 4126) {********************************}
  76 ( 4126) var mask, m, n, r1: integer;
  77 ( 4129) begin
  78 ( 4129)   write(@f,'$'); mask := $f000; n := 12;
  79 ( 4148)   while mask <>0 do
  80 ( 4158)     begin
  81 ( 4162)       r1 := (r and mask) shr n;
  82 ( 4171)       if r1 < 10 then
  83 ( 4186)         write(@f,r1)
  84 ( 4195)       else
  85 ( 4201)         write(@f,chr(ord(r1)+ord('A')-10));
  86 ( 4222)       mask := mask shr 4; n := n - 4;
  87 ( 4239)     end;
  88 ( 4244) end;
  89 ( 4247) 
  90 ( 4248) proc writebinary(f:file; r: integer);
  91 ( 4248) {***********************************}
  92 ( 4248) var mask: integer;
  93 ( 4251) begin
  94 ( 4251)   write(@f,'% ');
  95 ( 4262)   mask := $8000;
  96 ( 4265)   while mask <> 0 do
  97 ( 4275)     begin
  98 ( 4279)       if (r and mask) <> 0 then write(@f,'1')
  99 ( 4301)       else write(@f,'0');
 100 ( 4313)       mask := mask shr 1;
 101 ( 4319)       if mask = $0800 then write(@f,' ');
 102 ( 4343)       if mask = $0080 then write(@f,' ');
 103 ( 4361)       if mask = $0008 then write(@f,' ');
 104 ( 4379)     end;
 105 ( 4379) end;
 106 ( 4382) 
 107 ( 4383) proc writeauto(f:file;r:real);
 108 ( 4383) {****************************}
 109 ( 4383) { outputs 5 digits }
 110 ( 4383) var m,m1,max,rnd: real;
 111 ( 4386)     i1:integer;
 112 ( 4386)     sign: char;
 113 ( 4386)     d1: integer;
 114 ( 4386) begin
 115 ( 4386)   sign:=' '; m:=r;
 116 ( 4394)   if m<0. then begin
 117 ( 4419)     sign:='-'; m:=-m;
 118 ( 4428)   end;
 119 ( 4441)   if dotused and (m>=10000.0) then

----------------------------------------------------------------------

R65 COMPILE 4.2: program CALC             11/11/23 page 3

 120 ( 4458)     writeflo(f,r)
 121 ( 4466)   else if m=0. then
 122 ( 4493)     begin
 123 ( 4494)       write(@f,' 0',tab8,tab8); writehex(f,0);
 124 ( 4524)       write(@f,'  ',tab8); writebinary(f,0);
 125 ( 4548)     end
 126 ( 4548)   else if r=conv($8000) then
 127 ( 4560)     begin
 128 ( 4562)       write(@f,'-32768',tab8,tab8); write(@f,'$8000');
 129 ( 4596)       write(@f,'  ',tab8);
 130 ( 4608)       write(@f,'% 1000 0000 0000 0000');
 131 ( 4636)     end
 132 ( 4636)   else if m>=32767.5 then writeflo(f,r)
 133 ( 4659)   else if m<0.01 then writeflo(f,r)
 134 ( 4694)   else begin
 135 ( 4709)     if m>=10000. then begin d1:=0; rnd:=0.5 end
 136 ( 4737)     else if m>=1000. then begin d1:=1; rnd:=0.05 end
 137 ( 4774)     else if m>=100. then begin d1:=2; rnd:=0.005 end
 138 ( 4811)     else if m>=10. then begin d1:=3; rnd:=0.0005 end
 139 ( 4848)     else if m>=1. then begin d1:=4; rnd:=0.00005 end
 140 ( 4885)     else if m>=0.1 then begin d1:=5; rnd:=0.000005 end
 141 ( 4922)     else begin d1:=6; rnd:=0.0000005 end;
 142 ( 4949)     m:=m+rnd; { round }
 143 ( 4968)     write(@f,sign,trunc(m));
 144 ( 4987)     m1:=m-conv(trunc(m));
 145 ( 5000)     if d1>0 then write(@f,'.');
 146 ( 5026)     for i1:=1 to d1 do begin
 147 ( 5045)       m1:=10.*m1; write(@f,trunc(m1));
 148 ( 5078)       m1:=m1-conv(trunc(m1));
 149 ( 5091)     end;
 150 ( 5099)     write(@f,'  ',tab8); writehex(f,trunc(r+rnd));
 151 ( 5149)     write(@f,'  ',tab8); writebinary(f,trunc(r+rnd))
 152 ( 5178)   end;
 153 ( 5185) end;
 154 ( 5185) 
 155 ( 5186) func express:real;
 156 ( 5186) {****************}
 157 ( 5186) var
 158 ( 5186)   re: real;
 159 ( 5189) 
 160 ( 5189) func binval: integer;
 161 ( 5189) {*******************}
 162 ( 5189) begin
 163 ( 5189)   if (ch='0') then binval:=0
 164 ( 5204)   else if (ch='1') then binval:=1
 165 ( 5223)   else binval:=-1;
 166 ( 5234) end;
 167 ( 5239) 
 168 ( 5240) func hexval: integer;
 169 ( 5240) {*******************}
 170 ( 5240) begin
 171 ( 5240)   if (ch>='0') and (ch<='9')
 172 ( 5258)     then hexval:=ord(ch)-ord('0')
 173 ( 5269)   else if (ch>='A') and (ch<='F')
 174 ( 5290)     then hexval:=ord(ch)-ord('A')+10
 175 ( 5302)   else hexval:=-1;
 176 ( 5314) end;
 177 ( 5319) 
 178 ( 5320) func factor:real;
 179 ( 5320) {***************}

----------------------------------------------------------------------

R65 COMPILE 4.2: program CALC             11/11/23 page 4

 180 ( 5320) var negative:boolean;
 181 ( 5323)     rf,rt: real;
 182 ( 5323)     i,iv: integer;
 183 ( 5323) begin
 184 ( 5323)   negative:=false; rf:=0.;
 185 ( 5337)   read(@input,ch);
 186 ( 5351)   if ch='(' then begin
 187 ( 5359)     stop:=false; rf:=express;
 188 ( 5374)     checkfor(')'); read(@input,ch);
 189 ( 5396)   end else if ch='%' then begin
 190 ( 5407)     stop:=false; read(@input,ch); iv:=0;
 191 ( 5427)     while binval>=0 do begin
 192 ( 5443)       iv:=(iv shl 1)+binval; read(@input,ch);
 193 ( 5469)     end;
 194 ( 5470)     rf:=conv(iv);
 195 ( 5477)   end else if ch='$' then begin
 196 ( 5494)     stop:=false;
 197 ( 5499)     read(@input,ch);
 198 ( 5511)     iv:=0;
 199 ( 5514)     while hexval>=0 do begin
 200 ( 5530)       iv:=(iv shl 4)+hexval; read(@input,ch);
 201 ( 5556)     end;
 202 ( 5557)     rf:=conv(iv);
 203 ( 5564)   end else if ch='R' then begin
 204 ( 5581)     rf:= lastr; read(@input,ch);
 205 ( 5604)   end else if ch<>chr(0) then begin
 206 ( 5616)     if ch<>cr then begin
 207 ( 5626)       if ch<>cr then stop:=false;
 208 ( 5641)       if ch='+' then read(@input,ch);
 209 ( 5663)       if ch='-' then begin
 210 ( 5671)         negative:=true; read(@input,ch);
 211 ( 5688)       end;
 212 ( 5689)       if not isnumber(ch) then
 213 ( 5701)         writeln(invvid,
 214 ( 5707)           'SYNTAX ERROR: NUMBER EXPECTED',norvid);
 215 ( 5747)       while isnumber(ch) do begin
 216 ( 5762)         rt:=rf+rf; rt:=rt+rt;
 217 ( 5787)         rf:=rt+rt+rf+rf+conv(ord(ch)-ord('0'));
 218 ( 5834)         read(@input,ch);
 219 ( 5850)       end;
 220 ( 5851)       if ch='.' then begin
 221 ( 5861)         dotused:=true; read(@input,ch); rt:=0.1;
 222 ( 5885)         while isnumber(ch) do begin
 223 ( 5906)           rf:=rf+conv(ord(ch)-ord('0'))*rt;
 224 ( 5920)           rt:=rt/10.;
 225 ( 5946)           read(@input,ch);
 226 ( 5961)         end;
 227 ( 5962)       end;
 228 ( 5965)     end;
 229 ( 5965)     if negative then rf:=-rf;
 230 ( 5972)   end;
 231 ( 5985)   factor:=rf;
 232 ( 5985) end;
 233 ( 5997) 
 234 ( 5998) func simexp:real;
 235 ( 5998) {***************}
 236 ( 5998) var
 237 ( 5998)   rs: real;
 238 ( 6001) begin
 239 ( 6001)   rs:=factor;

----------------------------------------------------------------------

R65 COMPILE 4.2: program CALC             11/11/23 page 5

 240 ( 6009)   while (ch='*') or (ch='/') or (ch='&') or (ch='<')
 241 ( 6044)     or (ch='>') do begin
 242 ( 6057)     case ch of
 243 ( 6057)       '*': begin
 244 ( 6068)              rs:=rs*factor;
 245 ( 6080)            end;
 246 ( 6087)       '/': begin
 247 ( 6097)              rs:=rs/factor;
 248 ( 6109)            end;
 249 ( 6116)       '&': begin
 250 ( 6126)              rs:=conv(fix(rs) and fix(factor));
 251 ( 6155)            end;
 252 ( 6162)       '<': begin
 253 ( 6172)              read(@input,ch);
 254 ( 6180)              checkfor('<');
 255 ( 6189)              rs:=conv(fix(rs) shl fix(factor));
 256 ( 6218)              end;
 257 ( 6225)       '>': begin
 258 ( 6235)              read(@input,ch);
 259 ( 6243)              checkfor('>');
 260 ( 6252)              rs:=conv(fix(rs) shr fix(factor));
 261 ( 6281)            end
 262 ( 6288)       end {case};
 263 ( 6290)   end;
 264 ( 6290)   simexp:=rs;
 265 ( 6293) end;
 266 ( 6305) 
 267 ( 6306) {********body of express********}
 268 ( 6306) begin
 269 ( 6306)   re:=simexp;
 270 ( 6314)   while (ch='+') or (ch='-') or (ch='|') do begin
 271 ( 6346)     case ch of
 272 ( 6346)       '+': begin
 273 ( 6357)              re:=re+simexp;
 274 ( 6369)            end;
 275 ( 6376)       '-': begin
 276 ( 6386)              re:=re-simexp;
 277 ( 6398)            end;
 278 ( 6405)       '|': begin
 279 ( 6415)              re:=conv(fix(re) or fix(factor));
 280 ( 6444)            end
 281 ( 6451)     end {case};
 282 ( 6453)   end;
 283 ( 6453)   express:=re;
 284 ( 6456) end;
 285 ( 6468) 
 286 ( 6469) {*********main body********}
 287 ( 6469) begin
 288 ( 6469)   writeln('Enter an expression, examples are:');
 289 ( 6512)   writeln('32767     input decimal number');
 290 ( 6549)   writeln('$FFF      input hex number');
 291 ( 6582)   writeln('%1101     input binary number');
 292 ( 6618)   writeln('-55.35    input negative number');
 293 ( 6656)   writeln('2*(5+28)  math expression');
 294 ( 6688)   writeln('R*3       last result');
 295 ( 6716)   writeln('<return>,<esc>    exit');
 296 ( 6745)   writeln('operators: +,-,*,/,(),&,|,<<,>>');
 297 ( 6783)   r:=0.0; lastr:=0.0;
 298 ( 6801)   dotused:=false;
 299 ( 6809)   repeat

----------------------------------------------------------------------

R65 COMPILE 4.2: program CALC             11/11/23 page 6

 300 ( 6813)     stop:=true;
 301 ( 6815)     writeauto(output,r); writeln;
 302 ( 6833)     dotused:=false; lastr:=r;
 303 ( 6845)     r:=express; checkfor(cr);
 304 ( 6877)   until stop;
 305 ( 6877) end.
 306 ( 6884) 

End compile

Code lenght:          6883
Compiler stack size:  82
Ident stack size:     99
Pascal errors:        0
