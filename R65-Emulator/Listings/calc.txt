
R65 COMPILE 4.2: program CALC             14/11/23 page 1


   1 (    4)  {
   2 (    4)    Pascal CALC for R65 computer system
   3 (    4) 
   4 (    4)    Note: The R65 Pascal system used
   5 (    4)    32 bit floating point representation,
   6 (    4)    which is not suitable for serious
   7 (    4)    calculations, but was widely used
   8 (    4)    in early 8-bit microprocessor
   9 (    4)    systems. CALC tries to handle
  10 (    4)    this limited accuracy.
  11 (    4) 
  12 (    4)    Written 2019-2023 by rricharz  }
  13 (    4) 
  14 (    4) program calc;
  15 (    4) uses syslib,mathlib,strlib,ledlib;
  16 ( 5797) 
  17 ( 5797) mem vidpnt=$00e9:integer;
  18 ( 5800) 
  19 ( 5800) var ch: char;
  20 ( 5800)     r,lastr: real;
  21 ( 5800)     stop,dotused: boolean;
  22 ( 5800) 
  23 ( 5800) proc release(s: cpnt);
  24 ( 5800) {********************}
  25 ( 5800) { Only the last allocated string can be released }
  26 ( 5800) { This is suitable for recursive functions }
  27 ( 5800) mem endstk=$000e: integer;
  28 ( 5803) begin
  29 ( 5803)   if cpnt(endstk)=s then endstk:=endstk+strsize;
  30 ( 5821) end;
  31 ( 5825) 
  32 ( 5826) func fix(rf: real): integer;
  33 ( 5826) {**************************}
  34 ( 5826) begin
  35 ( 5826)   if (rf>32767.5) then begin
  36 ( 5844)       write(invvid,'Integer value exceeds');
  37 ( 5872)       write(' upper limit, set to 32767');
  38 ( 5899)       writeln(norvid); fix:=$7fff;
  39 ( 5911)     end else if (rf<-32768.5) then begin
  40 ( 5932)       write(invvid,'Integer value exceeds');
  41 ( 5960)       write(' lower limit, set to -32768');
  42 ( 5988)       writeln(norvid); fix:=$8000;
  43 ( 6000)     end else
  44 ( 6004)     fix:=trunc(rf);
  45 ( 6013) end;
  46 ( 6018) 
  47 ( 6019) proc checkfor(c: char);
  48 ( 6019) {*********************}
  49 ( 6019) begin
  50 ( 6019)   if ch<>c then begin
  51 ( 6033)     write(invvid,'SYNTAX ERROR: expected ');
  52 ( 6063)     if c=cr then write('<eol>')
  53 ( 6079)     else write(c);
  54 ( 6087)     write(' but found ');
  55 ( 6099)     if ch=cr then writeln('<eol>',norvid)
  56 ( 6117)     else writeln(ch,norvid);
  57 ( 6141)   end;
  58 ( 6141) end;
  59 ( 6141) 

----------------------------------------------------------------------

R65 COMPILE 4.2: program CALC             14/11/23 page 2

  60 ( 6142) proc skip(c:char);
  61 ( 6142) {****************}
  62 ( 6142) begin
  63 ( 6142)   checkfor(c); read(@input,ch);
  64 ( 6165) end;
  65 ( 6166) 
  66 ( 6167) func isnumber(cn:char):boolean;
  67 ( 6167) {*****************************}
  68 ( 6167) begin
  69 ( 6167)   isnumber:=(cn>='0') and (cn<='9');
  70 ( 6186) end;
  71 ( 6191) 
  72 ( 6192) proc writehex(f:file; r: integer);
  73 ( 6192) {********************************}
  74 ( 6192) var mask, m, n, r1: integer;
  75 ( 6195) begin
  76 ( 6195)   write(@f,'$'); mask := $f000; n := 12;
  77 ( 6214)   while mask <>0 do begin
  78 ( 6228)     r1 := (r and mask) shr n;
  79 ( 6237)     if r1 < 10 then write(@f,r1)
  80 ( 6261)     else  write(@f,chr(ord(r1)+ord('A')-10));
  81 ( 6288)     mask := mask shr 4; n := n - 4;
  82 ( 6305)   end;
  83 ( 6310) end;
  84 ( 6313) 
  85 ( 6314) proc writebinary(f:file; r: integer);
  86 ( 6314) {***********************************}
  87 ( 6314) var mask: integer;
  88 ( 6317) begin
  89 ( 6317)   write(@f,'% '); mask := $8000;
  90 ( 6331)   while mask <> 0 do begin
  91 ( 6345)    if (r and mask) <> 0 then write(@f,'1')
  92 ( 6367)    else write(@f,'0');
  93 ( 6379)    mask := mask shr 1;
  94 ( 6385)    if mask = $0800 then write(@f,' ');
  95 ( 6409)    if mask = $0080 then write(@f,' ');
  96 ( 6427)    if mask = $0008 then write(@f,' ');
  97 ( 6445)   end;
  98 ( 6445) end;
  99 ( 6448) 
 100 ( 6449) proc showled(s1:cpnt);
 101 ( 6449) {********************}
 102 ( 6449) var s2:cpnt;
 103 ( 6452)     pos1,i,mask:integer;
 104 ( 6452) begin
 105 ( 6452)   s2:=strnew;
 106 ( 6460)   { s1 is left justfied (except space for minus}
 107 ( 6464)   { s1 has no end mark and should not be modified }
 108 ( 6464)   mask:=0;
 109 ( 6466)   for i:=11 downto 0 do begin
 110 ( 6487)     if (s1[i]<>' ') and (s1[i]<>'+') then begin
 111 ( 6514)       if s1[i]='.' then
 112 ( 6529)         mask:=128
 113 ( 6533)       else begin
 114 ( 6542)         strins(chr(ord(s1[i]) or mask),0,s2);
 115 ( 6570)         mask:=0;
 116 ( 6572)       end;
 117 ( 6576)     end;
 118 ( 6576)   end;
 119 ( 6576)   while strlen(s2)<8 do strins(' ',0,s2);

----------------------------------------------------------------------

R65 COMPILE 4.2: program CALC             14/11/23 page 3

 120 ( 6622)   if strlen(s2)>8 then strcpy('--------',s2);
 121 ( 6664)   ledstring(s2);
 122 ( 6674)   release(s2);
 123 ( 6684) end;
 124 ( 6684) 
 125 ( 6685) proc writeauto(f:file;r:real);
 126 ( 6685) {****************************}
 127 ( 6685) { outputs 5 digits }
 128 ( 6685) var m,m1,max,rnd: real;
 129 ( 6688)     i1,d1:integer;
 130 ( 6688)     sign: char;
 131 ( 6688)     s1:cpnt;
 132 ( 6688) begin
 133 ( 6688)   { 7-segment display is copy of video memory }
 134 ( 6688)   s1:=cpnt(vidpnt);
 135 ( 6693)   sign:=' '; m:=r;
 136 ( 6703)   if m<0. then begin
 137 ( 6728)     sign:='-'; m:=-m;
 138 ( 6737)   end;
 139 ( 6750)   if dotused and (m>=10000.0) then writeflo(f,r)
 140 ( 6775)   else if m=0. then begin
 141 ( 6803)     write(@f,' 0',tab8,tab8); writehex(f,0);
 142 ( 6833)     write(@f,'  ',tab8); writebinary(f,0);
 143 ( 6857)   end else if r=conv($8000) then begin
 144 ( 6871)     write(@f,'-32768',tab8,tab8); write(@f,'$8000');
 145 ( 6905)     write(@f,'  ',tab8);
 146 ( 6917)     write(@f,'% 1000 0000 0000 0000');
 147 ( 6945)   end else if m>=32767.5 then writeflo(f,r)
 148 ( 6968)   else if m<0.01 then writeflo(f,r)
 149 ( 7003)   else begin
 150 ( 7018)     if m>=10000. then begin
 151 ( 7031)       d1:=0; rnd:=0.5
 152 ( 7040)     end else if m>=1000. then begin
 153 ( 7068)       d1:=1; rnd:=0.05
 154 ( 7077)     end else if m>=100. then begin
 155 ( 7105)       d1:=2; rnd:=0.005
 156 ( 7114)     end else if m>=10. then begin
 157 ( 7142)       d1:=3; rnd:=0.0005
 158 ( 7151)     end else if m>=1. then begin
 159 ( 7179)       d1:=4; rnd:=0.00005
 160 ( 7188)     end else if m>=0.1 then begin
 161 ( 7216)       d1:=5; rnd:=0.000005
 162 ( 7225)     end else begin
 163 ( 7240)       d1:=6; rnd:=0.0000005
 164 ( 7246)     end;
 165 ( 7258)     m:=m+rnd; { round }
 166 ( 7277)     write(@f,sign,trunc(m));
 167 ( 7296)     m1:=m-conv(trunc(m));
 168 ( 7309)     if d1>0 then write(@f,'.');
 169 ( 7335)     for i1:=1 to d1 do begin
 170 ( 7354)       m1:=10.*m1; write(@f,trunc(m1));
 171 ( 7387)       m1:=m1-conv(trunc(m1));
 172 ( 7400)     end;
 173 ( 7408)     write(@f,'  ',tab8); writehex(f,trunc(r+rnd));
 174 ( 7458)     write(@f,'  ',tab8); writebinary(f,trunc(r+rnd))
 175 ( 7487)   end;
 176 ( 7494)   showled(s1);
 177 ( 7504) end;
 178 ( 7504) 
 179 ( 7505) func express:real;

----------------------------------------------------------------------

R65 COMPILE 4.2: program CALC             14/11/23 page 4

 180 ( 7505) {****************}
 181 ( 7505) var
 182 ( 7505)   re: real;
 183 ( 7508) 
 184 ( 7508) func binval: integer;
 185 ( 7508) {*******************}
 186 ( 7508) begin
 187 ( 7508)   if (ch='0') then binval:=0
 188 ( 7523)   else if (ch='1') then binval:=1
 189 ( 7542)   else binval:=-1;
 190 ( 7553) end;
 191 ( 7558) 
 192 ( 7559) func hexval: integer;
 193 ( 7559) {*******************}
 194 ( 7559) begin
 195 ( 7559)   if (ch>='0') and (ch<='9')
 196 ( 7577)     then hexval:=ord(ch)-ord('0')
 197 ( 7588)   else if (ch>='A') and (ch<='F')
 198 ( 7609)     then hexval:=ord(ch)-ord('A')+10
 199 ( 7621)   else hexval:=-1;
 200 ( 7633) end;
 201 ( 7638) 
 202 ( 7639) func isletter(ch:char):boolean;
 203 ( 7639) {*****************************}
 204 ( 7639) begin
 205 ( 7639)   isletter:=(ord(ch)>=ord('A'))and(ord(ch)<=ord('Z'))
 206 ( 7657) end;
 207 ( 7663) 
 208 ( 7664) func function:real;
 209 ( 7664) {*****************}
 210 ( 7664) var i: integer;
 211 ( 7667)     r: real;
 212 ( 7667)     lstring: cpnt;
 213 ( 7667) begin
 214 ( 7667)   lstring:=strnew;
 215 ( 7675)   lstring[0]:=chr(0);
 216 ( 7683)   strins(ch,0,lstring); read(@input,ch); i:=1;
 217 ( 7715)   while isletter(ch) do begin
 218 ( 7734)     strins(ch,i,lstring); read(@input,ch); i:=i+1;
 219 ( 7767)   end;
 220 ( 7772)   stop:=false;
 221 ( 7777)   if strcmp(lstring,'R')=0 then begin
 222 ( 7800)     function:=lastr; release(lstring); exit;
 223 ( 7826)   end;
 224 ( 7826)   if strcmp(lstring,'PI')=0 then begin
 225 ( 7846)     function:=pi; release(lstring); exit;
 226 ( 7872)   end;
 227 ( 7872)   if strcmp(lstring,'E')=0 then begin
 228 ( 7891)     function:=e; release(lstring); exit;
 229 ( 7917)   end;
 230 ( 7917)   { functions with single argument follow }
 231 ( 7917)   checkfor('('); r:=express; skip(')');
 232 ( 7945)   if strcmp(lstring,'SQR')=0 then begin
 233 ( 7966)     function:=r*r; release(lstring); exit;
 234 ( 7999)   end;
 235 ( 7999)   if strcmp(lstring,'SQRT')=0 then begin
 236 ( 8021)     function:=sqrt(r); release(lstring); exit;
 237 ( 8055)   end;
 238 ( 8055)   if strcmp(lstring,'SIN')=0 then begin
 239 ( 8076)     function:=sin(r); release(lstring); exit;

----------------------------------------------------------------------

R65 COMPILE 4.2: program CALC             14/11/23 page 5

 240 ( 8110)   end;
 241 ( 8110)   if strcmp(lstring,'COS')=0 then begin
 242 ( 8131)     function:=cos(r); release(lstring); exit;
 243 ( 8165)   end;
 244 ( 8165)   if strcmp(lstring,'TAN')=0 then begin
 245 ( 8186)     function:=tan(r); release(lstring); exit;
 246 ( 8220)   end;
 247 ( 8220)   if strcmp(lstring,'EXP')=0 then begin
 248 ( 8241)     function:=exp(r); release(lstring); exit;
 249 ( 8275)   end;
 250 ( 8275)   if strcmp(lstring,'LN')=0 then begin
 251 ( 8295)     function:=ln(r); release(lstring); exit;
 252 ( 8329)   end;
 253 ( 8329)   if strcmp(lstring,'LOG')=0 then begin
 254 ( 8350)     function:=log(r); release(lstring); exit;
 255 ( 8384)   end;
 256 ( 8384)   writeln(invvid,'Unknown function ',lstring,norvid);
 257 ( 8419)   function:=0.0;
 258 ( 8425)   release(lstring);
 259 ( 8441) end;
 260 ( 8441) 
 261 ( 8442) func factor:real;
 262 ( 8442) {***************}
 263 ( 8442) var negative:boolean;
 264 ( 8445)     rf,rt: real;
 265 ( 8445)     i,iv: integer;
 266 ( 8445) begin
 267 ( 8445)   negative:=false; rf:=0.;  read(@input,ch);
 268 ( 8473)   if ch='-' then begin
 269 ( 8481)     negative:=true; read(@input,ch);
 270 ( 8498)   end;
 271 ( 8499)   if ch='(' then begin
 272 ( 8506)     stop:=false; rf:=express;
 273 ( 8521)     checkfor(')'); read(@input,ch);
 274 ( 8543)   end else if ch='%' then begin
 275 ( 8554)     stop:=false; read(@input,ch); iv:=0;
 276 ( 8574)     while binval>=0 do begin
 277 ( 8590)       iv:=(iv shl 1)+binval; read(@input,ch);
 278 ( 8616)     end;
 279 ( 8617)     rf:=conv(iv);
 280 ( 8624)   end else if ch='$' then begin
 281 ( 8641)     stop:=false; read(@input,ch); iv:=0;
 282 ( 8661)     while hexval>=0 do begin
 283 ( 8677)       iv:=(iv shl 4)+hexval; read(@input,ch);
 284 ( 8703)     end;
 285 ( 8704)     rf:=conv(iv);
 286 ( 8711)   end else if isletter(ch) then begin
 287 ( 8733)     write(invvid); rf:=function; write(norvid)
 288 ( 8753)   end else if ch<>chr(0) then begin
 289 ( 8765)     if ch<>cr then begin
 290 ( 8775)       if ch<>cr then stop:=false;
 291 ( 8790)       if ch='+' then read(@input,ch);
 292 ( 8812)       {if ch='-' then begin
 293 ( 8813)         negative:=true; read(@input,ch);
 294 ( 8813)       end;}
 295 ( 8813)       if not isnumber(ch) then
 296 ( 8825)         writeln(invvid,
 297 ( 8831)           'SYNTAX ERROR: NUMBER EXPECTED',norvid);
 298 ( 8871)       while isnumber(ch) do begin
 299 ( 8886)         rt:=rf+rf; rt:=rt+rt;

----------------------------------------------------------------------

R65 COMPILE 4.2: program CALC             14/11/23 page 6

 300 ( 8911)         rf:=rt+rt+rf+rf+conv(ord(ch)-ord('0'));
 301 ( 8958)         read(@input,ch);
 302 ( 8974)       end;
 303 ( 8975)       if ch='.' then begin
 304 ( 8985)         dotused:=true; read(@input,ch); rt:=0.1;
 305 ( 9009)         while isnumber(ch) do begin
 306 ( 9030)           rf:=rf+conv(ord(ch)-ord('0'))*rt;
 307 ( 9044)           rt:=rt/10.; read(@input,ch);
 308 ( 9085)         end;
 309 ( 9086)       end;
 310 ( 9089)     end;
 311 ( 9089)     if negative then rf:=-rf;
 312 ( 9096)   end;
 313 ( 9109)   factor:=rf;
 314 ( 9109) end;
 315 ( 9121) 
 316 ( 9122) func simexp:real;
 317 ( 9122) {***************}
 318 ( 9122) var
 319 ( 9122)   rs: real;
 320 ( 9125) begin
 321 ( 9125)   rs:=factor;
 322 ( 9133)   while (ch='*') or (ch='/') or (ch='&') or (ch='<')
 323 ( 9168)     or (ch='>') or (ch='^') do begin
 324 ( 9189)     case ch of
 325 ( 9189)       '*': begin rs:=rs*factor; end;
 326 ( 9219)       '/': begin rs:=rs/factor; end;
 327 ( 9248)       '&': rs:=conv(fix(rs) and fix(factor));
 328 ( 9287)       '^': rs:=exp(factor*ln(rs));
 329 ( 9333)       '<': begin
 330 ( 9349)              read(@input,ch); checkfor('<');
 331 ( 9366)              rs:=conv(fix(rs) shl fix(factor));
 332 ( 9395)              end;
 333 ( 9402)       '>': begin
 334 ( 9412)              read(@input,ch); checkfor('>');
 335 ( 9429)              rs:=conv(fix(rs) shr fix(factor));
 336 ( 9458)            end
 337 ( 9465)       end {case};
 338 ( 9467)   end;
 339 ( 9467)   simexp:=rs;
 340 ( 9470) end;
 341 ( 9482) 
 342 ( 9483) {********body of express********}
 343 ( 9483) begin
 344 ( 9483)   re:=simexp;
 345 ( 9491)   while (ch='+') or (ch='-') or (ch='|') do begin
 346 ( 9523)     case ch of
 347 ( 9523)       '+': begin re:=re+simexp; end;
 348 ( 9553)       '-': begin re:=re-simexp; end;
 349 ( 9582)       '|': begin
 350 ( 9592)              re:=conv(fix(re) or fix(factor));
 351 ( 9621)            end
 352 ( 9628)     end {case};
 353 ( 9630)   end;
 354 ( 9630)   express:=re;
 355 ( 9633) end;
 356 ( 9645) 
 357 ( 9646) {*********main body********}
 358 ( 9646) begin
 359 ( 9646)   write(invvid);

----------------------------------------------------------------------

R65 COMPILE 4.2: program CALC             14/11/23 page 7

 360 ( 9651)   writeln('Enter an expression, for example:        ');
 361 ( 9699)   writeln('32767      input decimal number          ');
 362 ( 9747)   writeln('$FFF       input hex number              ');
 363 ( 9795)   writeln('%1101      input binary number           ');
 364 ( 9843)   writeln('-55.35     input negative number         ');
 365 ( 9891)   writeln('2*(5+28)   math expression               ');
 366 ( 9939)   writeln('R*3        last result                   ');
 367 ( 9987)   writeln('<return>,<esc>    exit                   ');
 368 (10035)   writeln('Operators: +,-,*,/,^,(),&,|,<<,>>        ');
 369 (10083)   writeln('Functions: SQRT(),SQR(),SIN(),COS()      ');
 370 (10131)   writeln('           TAN(),EXP(),LN(),LOG()        ');
 371 (10179)   writeln(norvid);
 372 (10188)   r:=0.0; lastr:=0.0; dotused:=false;
 373 (10214)   repeat
 374 (10218)     stop:=true; writeauto(output,r); writeln;
 375 (10238)     dotused:=false; lastr:=r; r:=express; checkfor(cr);
 376 (10282)   until stop;
 377 (10282) end.

End compile

Code lenght:          10288
Compiler stack size:  131
Ident stack size:     131
Pascal errors:        0
