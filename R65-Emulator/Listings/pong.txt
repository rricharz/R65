
R65 COMPILE 4.2: program PONG             11/2/24 page 1


   1 (    4) {
   2 (    4)                 ************* *
   3 (    4)                 *             *
   4 (    4)                 *   P O N G   *
   5 (    4)                 *             *
   6 (    4)                 ***************
   7 (    4) 
   8 (    4) This is the pong game for the R65 computer
   9 (    4) system. I wrote the original version 1978,
  10 (    4) first in Basic, and then in Tiny Pascal.
  11 (    4) Unfortunately the original code has been
  12 (    4) lost. This is a recreation written 2018 out
  13 (    4) of memory to demonstrate the capabilities
  14 (    4) of the R65 computer system.
  15 (    4) 
  16 (    4)           rricharz 2018,2019,2024        }
  17 (    4) 
  18 (    4) program pong;
  19 (    4) uses syslib,plotlib;
  20 ( 1566) 
  21 ( 1566) const paddlesize = 24;
  22 ( 1569)       xmin = 40;
  23 ( 1569)       erase=0; ball=$6ff6;
  24 ( 1569)       cup=chr($1a); cdown=chr($18);
  25 ( 1569)       startspeed=0.01;
  26 ( 1569) 
  27 ( 1569) var i,ypaddle,lastypaddle:integer;
  28 ( 1569)     hit,miss: integer;
  29 ( 1569)     xspeed,yspeed,xball,yball:real;
  30 ( 1569)     lastxball,lastyball:real;
  31 ( 1569) 
  32 ( 1569) proc showball;
  33 ( 1569) begin
  34 ( 1569)   plotmap(trunc(lastxball),trunc(lastyball),erase);
  35 ( 1596)   plotmap(trunc(xball),trunc(yball),ball);
  36 ( 1619)   lastxball:=xball;
  37 ( 1619)   lastyball:=yball;
  38 ( 1631) end;
  39 ( 1643) 
  40 ( 1644) proc showpaddle;
  41 ( 1644) begin
  42 ( 1644)   if lastypaddle<>-1 then begin
  43 ( 1657)     move(xsize-3,lastypaddle);
  44 ( 1675)     draw(xsize-3, lastypaddle+paddlesize, black);
  45 ( 1695)   end;
  46 ( 1695)   move(xsize-3,ypaddle);
  47 ( 1710)   draw(xsize-3, ypaddle+paddlesize, white);
  48 ( 1730)   lastypadde:=ypaddle;
  49 ( 1730) end;
  50 ( 1738) 
  51 ( 1739) proc showcount(x,y,count:integer);
  52 ( 1739) var digit: integer;
  53 ( 1742) begin
  54 ( 1742)   digit:=count div 10;
  55 ( 1750)   move(x,y);
  56 ( 1769)   write(@plotdev,chr(ord('0')+digit),
  57 ( 1779)     chr(ord('0')+mod(count,10)));
  58 ( 1801) end;
  59 ( 1801) 
  60 ( 1802) proc init;
  61 ( 1802) begin
  62 ( 1802)   grinit;
  63 ( 1811)   cleargr;
  64 ( 1815)   move(xmin,0);
  65 ( 1825)   draw(xsize,0,white);
  66 ( 1837)   draw(xsize,ysize,white);
  67 ( 1849)   draw(xmin,ysize,white);
  68 ( 1861)   draw(xmin,0,white);
  69 ( 1873)   xball:=1.0;
  70 ( 1879)   yball:=conv(ysize div 2 - 2);
  71 ( 1893)   lastxball:=xball;
  72 ( 1900)   lastyball:=yball;
  73 ( 1912)   xspeed:=1.0 + startspeed * conv(random);
  74 ( 1942)   yspeed:=1.0 + startspeed * conv(random);
  75 ( 1969)   ypaddle:=(ysize-paddlesize) div 2;
  76 ( 1985)   lastypaddle:=-1;
  77 ( 1992)   hit:=0;
  78 ( 1999)   miss:=0;
  79 ( 2005)   move(1,100);
  80 ( 2019)   write(@plotdev,'Hit ');
  81 ( 2028)   showcount(1,90,hit);
  82 ( 2042)   move(1,70);
  83 ( 2052)   write(@plotdev,'Miss');
  84 ( 2061)   showcount(1,60,miss);
  85 ( 2075) end;
  86 ( 2075) 
  87 ( 2076) proc expaint;
  88 ( 2076) begin
  89 ( 2076)   showpaddle;
  90 ( 2085)   xball:=xball+xspeed;
  91 ( 2091)   yball:=yball+yspeed;
  92 ( 2110)   if xball<conv(xmin+2) then begin
  93 ( 2136)     xspeed:=-xspeed;
  94 ( 2139)     xball:=conv(xmin+2);
  95 ( 2157)   end;
  96 ( 2164) 
  97 ( 2164)   if (yball<=conv(ypaddle+paddlesize+2)) and
  98 ( 2182)     (yball>=conv(ypaddle+2)) then begin
  99 ( 2198)     if xball>=conv(xsize-7) then begin
 100 ( 2214)       hit:=hit+1;
 101 ( 2223)       showcount(1,90,hit);
 102 ( 2242)       xspeed:=-xspeed;
 103 ( 2242)       xball:=conv(xsize-7);
 104 ( 2260)     end;
 105 ( 2267)   end else begin
 106 ( 2270)     if xball>=conv(xsize-4) then begin
 107 ( 2283)       miss:=miss+1;
 108 ( 2292)       showcount(1,60,miss);
 109 ( 2311)       xspeed:=-xspeed;
 110 ( 2311)       xball:=conv(xsize-4);
 111 ( 2329)     end;
 112 ( 2336)   end;
 113 ( 2336)   if yball<2.0 then begin
 114 ( 2349)     yspeed:=-yspeed;
 115 ( 2352)     yball:=2.0
 116 ( 2365)   end else if yball>=conv(ysize-4) then begin
 117 ( 2393)     yspeed:=-yspeed;
 118 ( 2396)     yball:=conv(ysize-4);
 119 ( 2414)   end;
 120 ( 2421)   showball;
 121 ( 2425) end;
 122 ( 2425) 
 123 ( 2426) func exkey(key:char):boolean;
 124 ( 2426) var ymax:integer;
 125 ( 2429) begin
 126 ( 2429)   ymax:=ysize-paddlesize-4;
 127 ( 2438)   if (key=cup) and (ypaddle<ymax)  then
 128 ( 2459)     ypaddle := ypaddle+4
 129 ( 2467)   else if (key=cdown) and (ypaddle>5) then
 130 ( 2491)     ypaddle := ypaddle-5
 131 ( 2499)   else if key=cr then init;
 132 ( 2523)   exkey := key=chr(0);
 133 ( 2529) end;
 134 ( 2535) 
 135 ( 2536) {$I IANIMATE:P}
IANIMATE:P      .02  SP 0000-0300 000D 11/02/24
{I}    1 ( 2536) { ianimate - run animation in loop
{I}    2 ( 2536)   proc expaint;
{I}    3 ( 2536)     Called to paint one picture and apply motion.
{I}    4 ( 2536)   func exkey(ch:char):boolean;
{I}    5 ( 2536)     Called to check for key and stop loop if true  }
{I}    6 ( 2536) 
{I}    7 ( 2536) proc animate;
{I}    8 ( 2536) const toggle=chr($0c);
{I}    9 ( 2539) mem sflag=$1781:integer&;
{I}   10 ( 2539) var ch:char;
{I}   11 ( 2539)     dummy:integer;
{I}   12 ( 2539) begin
{I}   13 ( 2539)   repeat
{I}   14 ( 2539)     repeat
{I}   15 ( 2541)       expaint;
{I}   16 ( 2545)       dummy:=syncscreen; { sleep for up to 30 msec }
{I}   17 ( 2555)       ch:=keypressed; { sleep for 10 msec }
{I}   18 ( 2563)       { sflag bit 8 is escape flag. Pass it through }
{I}   19 ( 2563)     until (ord(ch)<>0) or ((sflag and $80)<>0);
{I}   20 ( 2580)     read(@key,ch);
{I}   21 ( 2592)     sflag:=sflag and $7f; { clear escape flag }
{I}   22 ( 2605)     if ch=toggle then write(toggle);
{I}   23 ( 2618)   until exkey(ch);
{I}   24 ( 2630) end;
 136 ( 2634) 
 137 ( 2634) begin
 138 ( 2634)   init;
 139 ( 2640)   writeln('Type RETURN to start new game.');
 140 ( 2677)   animate;
 141 ( 2681)   splitview;
 142 ( 2685) end.
 143 ( 2685) 

End compile

Code lenght:          2684
Compiler stack size:  44
Ident stack size:     104
Pascal errors:        0
