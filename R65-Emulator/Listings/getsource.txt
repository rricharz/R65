
R65 Pascal program GETSOURCE       7/11/23     page 1


                   1 (    4)  {
                   2 (    4)          *****************
                   3 (    4)          *               *
                   4 (    4)          *   getsource   *
                   5 (    4)          *               *
                   6 (    4)          *****************
                   7 (    4) 
                   8 (    4)     make a copy of a source file from
                   9 (    4)     from the disk SOURCEPASCAL or
                  10 (    4)     SOURCECOMPIL on the disk WORK in
                  11 (    4)     drive 1.
                  12 (    4) 
                  13 (    4)     usage: getsource filename
                  14 (    4) 
                  15 (    4)     2019 rricharz (r77@bluewin.ch)
                  16 (    4) }
                  17 (    4) 
                  18 (    4) program getsource;
                  19 (    4) uses syslib,arglib,disklib;
                  20 ( 1369) 
                  21 ( 1369) const afloppy=$c827; { exdos vector }
                  22 ( 1372) 
                  23 ( 1372) mem filerr=$db: integer&;
                  24 ( 1372) 
                  25 ( 1372) var cyclus,drive,k,dummy: integer;
                  26 ( 1372)     fname,dname: array[15] of char;
                  27 ( 1372)     default,ok: boolean;
                  28 ( 1372) 
                  29 ( 1372) func contains(t:array[7] of char):boolean;
                  30 ( 1372) { check for substring in fname }
                  31 ( 1372) { the substring must end with a blank }
                  32 ( 1372) var i,i1,j:integer;
                  33 ( 1375)     found:boolean;
                  34 ( 1375) begin
                  35 ( 1375)   i:=0; found:=false;
                  36 ( 1385)   repeat
                  37 ( 1389)     j:=0;
                  38 ( 1391)     if fname[i]=t[j] then begin
                  39 ( 1412)       i1:=i;
                  40 ( 1415)       repeat
                  41 ( 1423)         i1:=i1+1;
                  42 ( 1429)         j:=j+1;
                  43 ( 1440)         found:=t[j]=' ';
                  44 ( 1455)       until (i1>14) or (fname[i1]<>t[j])
                  45 ( 1479)                              or found;
                  46 ( 1485)     end;
                  47 ( 1493)     i:=i+1;
                  48 ( 1499)   until found or (i>15);
                  49 ( 1515)   contains:=found;
                  50 ( 1519) end;
                  51 ( 1527) 
                  52 ( 1528) proc runprog
                  53 ( 1528)   (name: array[15] of char;
                  54 ( 1528)    cyc: integer; drv: integer);
                  55 ( 1528) var i: integer;
                  56 ( 1531) begin
                  57 ( 1531)   for i:=0 to 15 do filnm1[i]:=name[i];
                  58 ( 1558)   filcy1:=cyc; fildrv:=drv; filflg:=$40;
                  59 ( 1602)   run

----------------------------------------------------------------------

R65 Pascal program GETSOURCE       7/11/23     page 2

                  60 ( 1606) end;
                  61 ( 1607) 
                  62 ( 1608) proc writename(text: array[15] of char);
                  63 ( 1608) { write name without blanks }
                  64 ( 1608) var i: integer;
                  65 ( 1611) 
                  66 ( 1611) begin
                  67 ( 1611)   for i:=0 to 15 do
                  68 ( 1621)     if text[i]<>' ' then write(text[i]);
                  69 ( 1653) end;
                  70 ( 1667) 
                  71 ( 1668) proc setsubtype(subtype:char);
                  72 ( 1668) var i:integer;
                  73 ( 1671) begin
                  74 ( 1671)   i:=0;
                  75 ( 1675)   repeat
                  76 ( 1679)     i:=i+1;
                  77 ( 1685)   until (fname[i]=':') or
                  78 ( 1701)     (fname[i]=' ') or (i>=14);
                  79 ( 1720)   fname[i]:=':';
                  80 ( 1730)   fname[i+1]:=subtype;
                  81 ( 1741) end;
                  82 ( 1749) 
                  83 ( 1750) func letter(ch:char):boolean;
                  84 ( 1750) begin
                  85 ( 1750)   letter:=(ch>='A') and (ch<='Z');
                  86 ( 1769) end;
                  87 ( 1774) 
                  88 ( 1775) proc setargs(name:array[15] of char;
                  89 ( 1775)   carg,cyc,drv:integer);
                  90 ( 1775) var k:integer;
                  91 ( 1778) begin
                  92 ( 1778)   argtype[carg]:='s';
                  93 ( 1786)     for k:=0 to 7 do
                  94 ( 1800)       arglist[carg+k]:=
                  95 ( 1818)         ord(packed(fname[2*k+1],
                  96 ( 1828)                     fname[2*k]));
                  97 ( 1844)     argtype[carg+8]:='i';
                  98 ( 1875)     arglist[carg+8]:=cyc;
                  99 ( 1888)     argtype[carg+9]:='i';
                 100 ( 1909)     arglist[carg+9]:=drv;
                 101 ( 1922) end;
                 102 ( 1934) 
                 103 ( 1935) begin
                 104 ( 1935)   ok:=true;
                 105 ( 1939)   filerr:=0;
                 106 ( 1945)   { get the argument (file name) }
                 107 ( 1949)   cyclus:=0; drive:=0;
                 108 ( 1957)   agetstring(fname,default,cyclus,drive);
                 109 ( 2001)   if default or not letter(fname[0]) then
                 110 ( 2019)     writeln('Usage: getsource filename')
                 111 ( 2050)   else begin
                 112 ( 2059)     setsubtype('P');
                 113 ( 2067)     dname:='PSOURCE         ';
                 114 ( 2085)     { make sure that WORK is on drive 1 }
                 115 ( 2091)     writeln('Putting disk WORK in drive 1');
                 116 ( 2126)     cyclus:=0; drive:=1;
                 117 ( 2134)     asetfile('WORK            ',cyclus,drive,' ');
                 118 ( 2172)     call(afloppy);
                 119 ( 2176)     if (filerr<>0) then ok:=false;

----------------------------------------------------------------------

R65 Pascal program GETSOURCE       7/11/23     page 3

                 120 ( 2187)     { make sure that dname is on drive 0 }
                 121 ( 2191)     write('Putting disk ');  writename(dname);
                 122 ( 2217)     writeln(' in drive 0');
                 123 ( 2235)     cyclus:=0; drive:=0;
                 124 ( 2243)     asetfile(dname,cyclus,drive,' ');
                 125 ( 2269)     call(afloppy);
                 126 ( 2273)     if (filerr<>0) then ok:=false;
                 127 ( 2284)     { copy the source file }
                 128 ( 2288)     write('Copying ');
                 129 ( 2297)     writename(fname);
                 130 ( 2309)     writeln(',0,1');
                 131 ( 2320)     setargs(fname,0,0,0);
                 132 ( 2338)     argtype[10]:='i';
                 133 ( 2342)     arglist[10]:=1; {copy to drive 1}
                 134 ( 2360)     cyclus:=0; drive:=0;
                 135 ( 2368)     filerr:=0;
                 136 ( 2374)     runprog('COPY:R          ',cyclus,drive);
                 137 ( 2410)     if (filerr<>0) or (runerr<>0) then begin
                 138 ( 2423)       ok:=false;
                 139 ( 2428)       if filerr=6 then writeln(invvid,
                 140 ( 2443)         'Source file not found',norvid)
                 141 ( 2468)       else writeln(invvid,
                 142 ( 2480)         'Copy failed',norvid);
                 143 ( 2502)     end;
                 144 ( 2502)     { make sure that PASCAL is on drive 0 }
                 145 ( 2502)     writeln('Putting disk PASCAL in drive 0');
                 146 ( 2539)     cyclus:=0; drive:=0;
                 147 ( 2547)     asetfile('PASCAL          ',cyclus,drive,' ');
                 148 ( 2585)     call(afloppy);
                 149 ( 2589)     if (filerr<>0) then ok:=false;
                 150 ( 2600)   end;
                 151 ( 2604)   if (not ok) or (runerr<>0) then begin
                 152 ( 2616)     writeln(invvid,'Getsource failed',norvid);
                 153 ( 2648)     filerr:=0; runerr:=0;
                 154 ( 2656)   end;
                 155 ( 2660)   dummy:=freedsk(1,true);
                 156 ( 2672) end.
                 157 ( 2676) 

End compile

Code lenght:          2675
Compiler stack size:  68
Ident stack size:     95
Pascal errors:        0
