
R65 COMPILE 4.3: program BOUNCE           12/2/24 page 1


   1 (    4) {
   2 (    4)         *****************
   3 (    4)         *               *
   4 (    4)         *     BOUNCE    *
   5 (    4)         *               *
   6 (    4)         *****************
   7 (    4) 
   8 (    4) A bouncing ball simulation for the
   9 (    4) R65 Graphics display
  10 (    4) 
  11 (    4)     Original    1979 rricharz
  12 (    4)     New version 2019 rricharz
  13 (    4)                                 }
  14 (    4) 
  15 (    4) program bounce;
  16 (    4) uses syslib,plotlib;
  17 ( 1566) 
  18 ( 1566) const gravity=0.15;
  19 ( 1569)       keyfactor=1.05;
  20 ( 1569)       erase=0; ball=$6ff6;
  21 ( 1569)       autorepeat=false;
  22 ( 1569) 
  23 ( 1569) var x,y,xspeed,yspeed: real;
  24 ( 1569)     xi,yi,xl,yl,keycode: integer;
  25 ( 1569) 
  26 ( 1569) {$I IRANDOM:P}
IRANDOM:P       .02  SP 0000-0200 0006 12/02/24
{I}    1 ( 1569) { irandom: real and integer random functions with limit
{I}    2 ( 1569) }
{I}    3 ( 1569) 
{I}    4 ( 1569) func rrandom(min,max:real):real;
{I}    5 ( 1569) begin
{I}    6 ( 1569)   rrandom := min + (conv(random)/255.0) * (max - min);
{I}    7 ( 1607) end;
{I}    8 ( 1615) 
{I}    9 ( 1616) func irandom(min,max:integer):integer;
{I}   10 ( 1616) begin
{I}   11 ( 1616)   irandom := trunc(rrandom(conv(min),conv(max)));
{I}   12 ( 1639) end;
{I}   13 ( 1644) 
  27 ( 1645) 
  28 ( 1645) func expaint:boolean;
  29 ( 1645) begin
  30 ( 1645)   expaint:=false;
  31 ( 1652)   yspeed:=yspeed-gravity;
  32 ( 1668)   x:=x+xspeed;
  33 ( 1681)   y:=y+yspeed;
  34 ( 1700)   if x<1.5 then begin
  35 ( 1726)     x:=1.5;
  36 ( 1735)     xspeed:=-xspeed;
  37 ( 1741)   end else if x>conv(xsize-4) then begin
  38 ( 1770)     x:=conv(xsize-4);
  39 ( 1778)     xspeed:=-xspeed;
  40 ( 1785)   end;
  41 ( 1798)   if y<1.5 then begin
  42 ( 1811)     y:=1.5;
  43 ( 1820)     yspeed:=-yspeed+0.5*gravity;
  44 ( 1845)   end else if y>conv(ysize-18) then begin
  45 ( 1869)     yspeed:=-0.95*yspeed;
  46 ( 1878)     y:=conv(ysize-18);

----------------------------------------------------------------------

R65 COMPILE 4.3: program BOUNCE           12/2/24 page 2

  47 ( 1897)   end;
  48 ( 1904) 
  49 ( 1904)   xi:=trunc(x);
  50 ( 1910)   yi:=trunc(y);
  51 ( 1921)   plotmap(xl,yl,erase);
  52 ( 1942)   plotmap(xi,yi,ball);
  53 ( 1959)   xl:=xi;
  54 ( 1959)   yl:=yi;
  55 ( 1967) end;
  56 ( 1975) 
  57 ( 1976) func exkey(ch:char):boolean;
  58 ( 1976) begin
  59 ( 1976)   exkey:=false
  60 ( 1981)   case ord(ch) of
  61 ( 1991)     26: yspeed:=yspeed*keyfactor;
  62 ( 2010)     03: xspeed:=xspeed/keyfactor;
  63 ( 2039)     22: xspeed:=xspeed*keyfactor;
  64 ( 2068)     24: yspeed:=yspeed/keyfactor;
  65 ( 2097)     0:  exkey:=true
  66 ( 2114)   end {case};
  67 ( 2122)   if xspeed>4.0 then xspeed:=4.0
  68 ( 2138)   else if xspeed<-4.0 then xspeed:=-4.0;
  69 ( 2176)   if yspeed>6.0 then yspeed:=6.0
  70 ( 2199)   else if yspeed<-6.0 then yspeed:=-6.0;
  71 ( 2237) end;
  72 ( 2244) 
  73 ( 2245) {$I IANIMATE:P}
IANIMATE:P      .0B  SP 0000-0400 0008 12/02/24
{I}    1 ( 2245) { ianimate - run animation in loop
{I}    2 ( 2245)   proc expaint;
{I}    3 ( 2245)     Called to paint one picture and apply motion.
{I}    4 ( 2245)   func exkey(ch:char):boolean;
{I}    5 ( 2245)     Called to check for key and stop loop if true  }
{I}    6 ( 2245) 
{I}    7 ( 2245) proc animate(arepeat:boolean);
{I}    8 ( 2245) { arepeat: auto repeat cursor keys without delay }
{I}    9 ( 2245) const toggle=chr($0c);
{I}   10 ( 2248)       cleft=chr($03); cright=chr($16);
{I}   11 ( 2248)       cup=chr($1a); cdown=chr($18); esc=chr(0);
{I}   12 ( 2248) mem   sflag=$1781:integer&;
{I}   13 ( 2248)       emuflags=$1707:integer&;
{I}   14 ( 2248) var   ch:char;
{I}   15 ( 2248)       dummy:integer;
{I}   16 ( 2248)       stop:boolean;
{I}   17 ( 2248) begin
{I}   18 ( 2248)   repeat
{I}   19 ( 2248)     repeat
{I}   20 ( 2250)       stop:=expaint;
{I}   21 ( 2256)       dummy:=syncscreen; { sleep for up to 30 msec }
{I}   22 ( 2270)       ch:=keypressed; { sleep for 10 msec }
{I}   23 ( 2278)       { sflag bit 8 is escape flag. Pass it through }
{I}   24 ( 2278)     until (ord(ch)<>0) or ((sflag and $80)<>0)
{I}   25 ( 2294)       or stop;
{I}   26 ( 2296)     if not(((ch=cup) or (ch=cdown) or (ch=cleft) or
{I}   27 ( 2326)        (ch=cright)) and
{I}   28 ( 2335)        ((emuflags and 1)<>0) and arepeat) then
{I}   29 ( 2351)        { cursor keys auto repeat without delay }
{I}   30 ( 2352)        keypressed := chr(0);
{I}   31 ( 2357)     sflag:=sflag and $7f; { clear escape flag }
{I}   32 ( 2375)     if ch=toggle then write(toggle);
{I}   33 ( 2388)   until exkey(ch) or stop;

----------------------------------------------------------------------

R65 COMPILE 4.3: program BOUNCE           12/2/24 page 3

{I}   34 ( 2400) end;
  74 ( 2409) 
  75 ( 2409) begin
  76 ( 2409)   grinit;
  77 ( 2415)   cleargr;
  78 ( 2419)   xspeed:=rrandom(0.4,4.0);
  79 ( 2439)   yspeed:=rrandom(0.4,3.0);
  80 ( 2465)   x:=1.5;
  81 ( 2477)   y:=conv(ysize)/2.0;
  82 ( 2492)   xl:=trunc(x);
  83 ( 2505)   yl:=trunc(y);
  84 ( 2516) 
  85 ( 2521)   move(0,ysize);
  86 ( 2531)   draw(0,0,white);
  87 ( 2543)   draw(xsize,0,white);
  88 ( 2555)   draw(xsize,ysize,white);
  89 ( 2567)   draw(0,ysize,white);
  90 ( 2579)   move(0,ysize-14);
  91 ( 2592)   draw(xsize,ysize-14,white);
  92 ( 2607) 
  93 ( 2607)   move(6,ysize-11);
  94 ( 2620)   write(@plotdev,
  95 ( 2622)     'Use arrows to change speed');
  96 ( 2651) 
  97 ( 2651)   animate(autorepeat);
  98 ( 2659)   splitview;
  99 ( 2663) end.
 100 ( 2663) 

End compile

Code lenght:          2662
Compiler stack size:  53
Ident stack size:     109
Pascal errors:        0
