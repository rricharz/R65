
R65 COMPILE 4.3: program BOUNCE           12/2/24 page 1


   1 (    4) {
   2 (    4)         *****************
   3 (    4)         *               *
   4 (    4)         *     BOUNCE    *
   5 (    4)         *               *
   6 (    4)         *****************
   7 (    4) 
   8 (    4) A bouncing ball simulation for the
   9 (    4) R65 Graphics display.
  10 (    4) 
  11 (    4) With circle in the center of the canvas
  12 (    4) 
  13 (    4)     Original    1979 rricharz
  14 (    4)     New version 2024 rricharz
  15 (    4)                                 }
  16 (    4) 
  17 (    4) program bounce;
  18 (    4) uses syslib,plotlib,mathlib;
  19 ( 5287) 
  20 ( 5287) const gravity=0.15;
  21 ( 5290)       keyfactor=1.05;
  22 ( 5290)       erase=0; ball=$6ff6;
  23 ( 5290)       autorepeat=false;
  24 ( 5290) 
  25 ( 5290) var x,y,xspeed,yspeed: real;
  26 ( 5290)     xi,yi,xl,yl,keycode: integer;
  27 ( 5290)     xc,yc,rc: real;
  28 ( 5290) 
  29 ( 5290) {$I IRANDOM:P}
IRANDOM:P       .02  SP 0000-0200 0002 12/02/24
{I}    1 ( 5290) { irandom: real and integer random functions with limit
{I}    2 ( 5290) }
{I}    3 ( 5290) 
{I}    4 ( 5290) func rrandom(min,max:real):real;
{I}    5 ( 5290) begin
{I}    6 ( 5290)   rrandom := min + (conv(random)/255.0) * (max - min);
{I}    7 ( 5328) end;
{I}    8 ( 5336) 
{I}    9 ( 5337) func irandom(min,max:integer):integer;
{I}   10 ( 5337) begin
{I}   11 ( 5337)   irandom := trunc(rrandom(conv(min),conv(max)));
{I}   12 ( 5360) end;
{I}   13 ( 5365) 
  30 ( 5366) 
  31 ( 5366) func expaint:boolean;
  32 ( 5366) var radx,rady,l,sp1,sp2,mx,my,rx,ry:real;
  33 ( 5369) begin
  34 ( 5369)   expaint:=false;
  35 ( 5373)   yspeed:=yspeed-gravity;
  36 ( 5389)   x:=x+xspeed;
  37 ( 5402)   y:=y+yspeed;
  38 ( 5421)   if x<1.5 then begin
  39 ( 5447)     x:=1.5;
  40 ( 5456)     xspeed:=-xspeed;
  41 ( 5462)   end else if x>conv(xsize-4) then begin
  42 ( 5491)     x:=conv(xsize-4);
  43 ( 5499)     xspeed:=-xspeed;
  44 ( 5506)   end;
  45 ( 5519)   if y<1.5 then begin
  46 ( 5532)     y:=1.5;

----------------------------------------------------------------------

R65 COMPILE 4.3: program BOUNCE           12/2/24 page 2

  47 ( 5541)     yspeed:=-yspeed+0.5*gravity;
  48 ( 5566)   end else if y>conv(ysize-18) then begin
  49 ( 5590)     yspeed:=-0.95*yspeed;
  50 ( 5599)     y:=conv(ysize-18);
  51 ( 5618)   end;
  52 ( 5625) 
  53 ( 5625)   { handle circle in center }
  54 ( 5625)   if (xc-x)*(xc-x)+(yc-y)*(yc-y) < (rc+4.0)*(rc+4.0)
  55 ( 5705)   then begin
  56 ( 5708)     { calculate radius vector }
  57 ( 5711)     rx:=xc-x; ry:=yc-y;
  58 ( 5736)     { normalize this vector, make lenght = 1 }
  59 ( 5749)     l:=sqrt(rx*rx+ry*ry);
  60 ( 5784)     rx:=rx/l; ry:=ry/l;
  61 ( 5815)     { calculate dot product of radius and motion }
  62 ( 5828)     sp1:=rx*xspeed+ry*yspeed;
  63 ( 5847)     { calculate dot product of tangent and motion }
  64 ( 5861)     sp2:=ry*xspeed-rx*yspeed;
  65 ( 5880)     { project motion vector on radius and tangent }
  66 ( 5894)     { invert radial component}
  67 ( 5894)     xspeed:=-rx*sp1+ry*sp2; yspeed:=-ry*sp1-rx*sp2;
  68 ( 5948)     { put ball back outside of circle }
  69 ( 5962)     x:=conv(xl); y:=conv(yl);
  70 ( 5977)   end;
  71 ( 5984)   xi:=trunc(x);
  72 ( 5990)   yi:=trunc(y);
  73 ( 6001)   plotmap(xl,yl,erase);
  74 ( 6022)   plotmap(xi,yi,ball);
  75 ( 6039)   xl:=xi;
  76 ( 6039)   yl:=yi;
  77 ( 6047) end;
  78 ( 6055) 
  79 ( 6056) func exkey(ch:char):boolean;
  80 ( 6056) begin
  81 ( 6056)   exkey:=false
  82 ( 6061)   case ord(ch) of
  83 ( 6071)     26: yspeed:=yspeed*keyfactor;
  84 ( 6090)     03: xspeed:=xspeed/keyfactor;
  85 ( 6119)     22: xspeed:=xspeed*keyfactor;
  86 ( 6148)     24: yspeed:=yspeed/keyfactor;
  87 ( 6177)     0:  exkey:=true
  88 ( 6194)   end {case};
  89 ( 6202)   if xspeed>4.0 then xspeed:=4.0
  90 ( 6218)   else if xspeed<-4.0 then xspeed:=-4.0;
  91 ( 6256)   if yspeed>6.0 then yspeed:=6.0
  92 ( 6279)   else if yspeed<-6.0 then yspeed:=-6.0;
  93 ( 6317) end;
  94 ( 6324) 
  95 ( 6325) {$I ICIRCLE:P }
ICIRCLE:P       .04  SP 0000-0200 0000 12/02/24
{I}    1 ( 6325) proc circle(x,y,r,c:integer);
{I}    2 ( 6325) var step,rr,angle:real;
{I}    3 ( 6328) begin
{I}    4 ( 6328)  rr:=conv(r); step:=180.0/rr; angle:=0.0;
{I}    5 ( 6366)  if step>22.5 then step:=22.5;
{I}    6 ( 6394)  move(x+r,y);
{I}    7 ( 6419)  repeat
{I}    8 ( 6419)    angle:=angle+step;
{I}    9 ( 6425)    draw(x+trunc(rr*cos(angle)+0.5),
{I}   10 ( 6470)         y+trunc(rr*sin(angle)+0.5),c);
{I}   11 ( 6516)  until angle>=360.0;

----------------------------------------------------------------------

R65 COMPILE 4.3: program BOUNCE           12/2/24 page 3

{I}   12 ( 6528) end;
  96 ( 6533) {$I IANIMATE:P}
IANIMATE:P      .0C  SP 0000-0400 000E 12/02/24
{I}    1 ( 6533) { ianimate - run animation in loop
{I}    2 ( 6533)   proc expaint;
{I}    3 ( 6533)     Called to paint one picture and apply motion.
{I}    4 ( 6533)   func exkey(ch:char):boolean;
{I}    5 ( 6533)     Called to check for key and stop loop if true  }
{I}    6 ( 6533) 
{I}    7 ( 6533) proc animate(arepeat:boolean);
{I}    8 ( 6533) { arepeat: auto repeat cursor keys without delay }
{I}    9 ( 6533) const toggle=chr($0c);
{I}   10 ( 6536)       cleft=chr($03); cright=chr($16);
{I}   11 ( 6536)       cup=chr($1a); cdown=chr($18); esc=chr(0);
{I}   12 ( 6536) mem   sflag=$1781:integer&;
{I}   13 ( 6536)       emuflags=$1707:integer&;
{I}   14 ( 6536) var   ch:char;
{I}   15 ( 6536)       dummy:integer;
{I}   16 ( 6536)       stop:boolean;
{I}   17 ( 6536) begin
{I}   18 ( 6536)   repeat
{I}   19 ( 6536)     repeat
{I}   20 ( 6538)       stop:=expaint;
{I}   21 ( 6544)       dummy:=syncscreen; { sleep for up to 30 msec }
{I}   22 ( 6558)       ch:=keypressed; { sleep for 10 msec }
{I}   23 ( 6566)       { sflag bit 8 is escape flag. Pass it through }
{I}   24 ( 6566)     until (ord(ch)<>0) or ((sflag and $80)<>0)
{I}   25 ( 6582)       or stop;
{I}   26 ( 6584)     if not(((ch=cup) or (ch=cdown) or (ch=cleft) or
{I}   27 ( 6614)        (ch=cright)) and
{I}   28 ( 6623)        ((emuflags and 1)<>0) and arepeat) then
{I}   29 ( 6639)        { cursor keys auto repeat without delay }
{I}   30 ( 6640)        keypressed := chr(0);
{I}   31 ( 6645)     sflag:=sflag and $7f; { clear escape flag }
{I}   32 ( 6663)     if ch=toggle then write(toggle);
{I}   33 ( 6676)   until exkey(ch) or stop;
{I}   34 ( 6688) end;
  97 ( 6697) 
  98 ( 6697) begin
  99 ( 6697)   grinit;
 100 ( 6703)   cleargr;
 101 ( 6707)   xspeed:=rrandom(0.4,4.0);
 102 ( 6727)   yspeed:=rrandom(0.4,3.0);
 103 ( 6753)   x:=1.5;
 104 ( 6765)   y:=conv(ysize)/2.0;
 105 ( 6780)   xl:=trunc(x);
 106 ( 6793)   yl:=trunc(y);
 107 ( 6804) 
 108 ( 6809)   move(0,ysize);
 109 ( 6819)   draw(0,0,white);
 110 ( 6831)   draw(xsize,0,white);
 111 ( 6843)   draw(xsize,ysize,white);
 112 ( 6855)   draw(0,ysize,white);
 113 ( 6867)   move(0,ysize-14);
 114 ( 6880)   draw(xsize,ysize-14,white);
 115 ( 6895) 
 116 ( 6895)   move(6,ysize-11);
 117 ( 6908)   write(@plotdev,
 118 ( 6910)     'Use arrows to change speed');
 119 ( 6939) 
 120 ( 6939)   xc:=conv(xsize) * 0.5;

----------------------------------------------------------------------

R65 COMPILE 4.3: program BOUNCE           12/2/24 page 4

 121 ( 6948)   yc:=conv(ysize-14) * 0.5;
 122 ( 6967)   rc:=conv(ysize-14) * 0.25;
 123 ( 6986) 
 124 ( 6993)   circle(trunc(xc),trunc(yc),trunc(rc),white);
 125 ( 7022) 
 126 ( 7022)   animate(autorepeat);
 127 ( 7030)   splitview;
 128 ( 7034) end.
 129 ( 7034) 

End compile

Code lenght:          7033
Compiler stack size:  97
Ident stack size:     136
Pascal errors:        0
