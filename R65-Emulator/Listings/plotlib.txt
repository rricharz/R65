
R65 COMPILE 4.2: program PLOTLIB          5/2/24 page 1


   1 (    4) {
   2 (    4)         **************************
   3 (    4)         *                        *
   4 (    4)         *     R65 Tiny Pascal    *
   5 (    4)         *  Plot Library Plotlib  *
   6 (    4)         *                        *
   7 (    4)         **************************
   8 (    4) 
   9 (    4)        Version 16 06/02/80 rricharz
  10 (    4) 
  11 (    4) }
  12 (    4) 
  13 (    4) library plotlib;
  14 (    4) 
  15 (    4) const xsize=223;
  16 (    7)       ysize=117;
  17 (    7)       xwords=28;
  18 (    7)       white=0;
  19 (    7)       inverse=1;
  20 (    7)       black=2;
  21 (    7)       plotdev=@128;
  22 (    7) 
  23 (    7) mem keypressed=$1785: char&;
  24 (    7) 
  25 (    7) var xcursor, ycursor: integer;
  26 (    7) 
  27 (    7) { delay10msec: delay 10 msec }
  28 (    7) { process is suspended during delay }
  29 (    7) 
  30 (    7) proc delay10msec(time:integer);
  31 (    7) mem emucom=$1430: integer&;
  32 (   10) var i:integer;
  33 (   10) begin
  34 (   10)   for i:=1 to time do
  35 (   18)     emucom:=6;
  36 (   33) end;
  37 (   52) 
  38 (   53) func syncscreen;
  39 (   53) { synchronize screen and sleep
  40 (   53)   up to 30 msec since last sync.
  41 (   53)   returns sleep time in msec    }
  42 (   53) mem emucom=$1430: integer&;
  43 (   56)     emures=$1431: integer&;
  44 (   56) begin
  45 (   56)   emucom := 7;
  46 (   60)   syncscreen := emures;
  47 (   69) end;
  48 (   73) 
  49 (   74) { grinit: initialize memory for }
  50 (   74) { alpha/graphics display        }
  51 (   74) 
  52 (   74) proc grinit;
  53 (   74) const igraph=$e01e;
  54 (   77)       icrtgr=$e016;
  55 (   77) begin
  56 (   77)   call(igraph); call(icrtgr);
  57 (   87) end;
  58 (   87) 
  59 (   88) { grend: end of graphics, initialize }

----------------------------------------------------------------------

R65 COMPILE 4.2: library PLOTLIB          5/2/24 page 2

  60 (   88) { memory for alpha display           }
  61 (   88) 
  62 (   88) proc grend;
  63 (   88) const initcr=$e01b;
  64 (   91) mem sflag=$1781: integer&;
  65 (   91) begin
  66 (   91)   call(initcr);
  67 (   97)   sflag:=sflag or 1; {Pascal flag on}
  68 (  109) end;
  69 (  109) 
  70 (  110) { cleargr: clear graphics display }
  71 (  110) 
  72 (  110) proc cleargr;
  73 (  110) const clrgra=$e231; { not a vector! }
  74 (  113) begin
  75 (  113)   call(clrgra);
  76 (  119) end;
  77 (  119) 
  78 (  120) { dgraphics: go to graphics display }
  79 (  120) 
  80 (  120) proc fullgraph;
  81 (  120) const icrtgr=$e016;
  82 (  123) begin
  83 (  123)   call(icrtgr);
  84 (  129) end;
  85 (  129) 
  86 (  130) { dalpha: go to alpha display }
  87 (  130) 
  88 (  130) proc splitgraph;
  89 (  130) const icrtal=$e015;
  90 (  133) begin
  91 (  133)   call(icrtal);
  92 (  139) end;
  93 (  139) 
  94 (  140) { plot(x,y,c)                }
  95 (  140) { plot a dot at x,y, using c }
  96 (  140) 
  97 (  140) proc plot(x,y,c:integer);
  98 (  140) const aplot=$c815;
  99 (  143) mem grx=$03ae: integer&;
 100 (  143)     gry=$03af: integer&;
 101 (  143)     grc=$03b0: integer&;
 102 (  143) begin
 103 (  143)   xcursor:=x;
 104 (  145)   ycursor:=y;
 105 (  153)   if x<0 then xcursor:=0;
 106 (  173)   if x>xsize then xcursor:=xsize;
 107 (  189)   if y<0 then ycursor:=0;
 108 (  205)   if y>ysize then ycursor:=ysize;
 109 (  221)   grx:=x;
 110 (  225)   gry:=y;
 111 (  234)   grc:=c;
 112 (  243)   call(aplot);
 113 (  256) end;
 114 (  256) 
 115 (  257) { move(x,y)            }
 116 (  257) { move graphics cursor }
 117 (  257) 
 118 (  257) proc move(x,y:integer);
 119 (  257) mem grx=$03ae: integer&;

----------------------------------------------------------------------

R65 COMPILE 4.2: library PLOTLIB          5/2/24 page 3

 120 (  260)     gry=$03af: integer&;
 121 (  260) begin
 122 (  260)   xcursor:=x;
 123 (  262)   ycursor:=y;
 124 (  270)   if x<0 then xcursor:=0;
 125 (  290)   if x>xsize then xcursor:=xsize;
 126 (  306)   if y<0 then ycursor:=0;
 127 (  322)   if y>ysize then ycursor:=ysize;
 128 (  338)   grx:=xcursor;
 129 (  342)   gry:=ycursor;
 130 (  351) end;
 131 (  360) 
 132 (  361) { draw(x,y,c)          }
 133 (  361) { draw a straight line }
 134 (  361) { end points are clipped to graphics area }
 135 (  361) 
 136 (  361) proc draw(x,y,c:integer);
 137 (  361) mem grxinc=$03b6: integer;
 138 (  364)     gryinc=$03ba: integer;
 139 (  364)     grx=$03ae: integer&;
 140 (  364)     gry=$03af: integer&;
 141 (  364)     grc=$03b0: integer&;
 142 (  364)     grn=$03b1: integer;
 143 (  364) var xnew,ynew,xstep,ystep,xl,yl,i,cnt:integer;
 144 (  364) 
 145 (  364)   proc drawx(x,y,c,n:integer);
 146 (  364)   const adrawx=$c81e;
 147 (  367)   begin
 148 (  367)     grx:=x;
 149 (  369)     gry:=y;
 150 (  378)     grc:=c;
 151 (  387)     grn:=n;
 152 (  396)     call(adrawx);
 153 (  408)   end;
 154 (  408) 
 155 (  409)   proc drawy(x,y,c,n:integer);
 156 (  409)   const adrawy=$c821;
 157 (  412)   begin
 158 (  412)     grx:=x;
 159 (  414)     gry:=y;
 160 (  423)     grc:=c;
 161 (  432)     grn:=n;
 162 (  441)     call(adrawy);
 163 (  453)   end;
 164 (  453) 
 165 (  454)   proc drawxy(x,y,c,n,xi,yi:integer);
 166 (  454)   const adrawxy=$c824;
 167 (  457)   begin
 168 (  457)     grx:=x;
 169 (  459)     gry:=y;
 170 (  468)     grc:=c;
 171 (  477)     grn:=n;
 172 (  486)     grxinc:=xi;
 173 (  494)     gryinc:=yi
 174 (  502)     call(adrawxy);
 175 (  514)   end;
 176 (  514) 
 177 (  515) begin
 178 (  515)   xnew:=x;
 179 (  517)   ynew:=y;

----------------------------------------------------------------------

R65 COMPILE 4.2: library PLOTLIB          5/2/24 page 4

 180 (  525)   if xnew<0 then xnew:=0;
 181 (  545)   if xnew>xsize then xnew:=xsize;
 182 (  561)   if ynew<0 then ynew:=0;
 183 (  577)   if ynew>ysize then ynew:=ysize;
 184 (  593)   { fast horizontal and vertical draw }
 185 (  597)   if ynew=ycursor then begin
 186 (  606)     if xnew > xcursor then
 187 (  613)       drawx(xcursor,ynew,c,xnew-xcursor+1)
 188 (  644)     else
 189 (  651)       drawx(xnew,ynew,c,xcursor-xnew+1)
 190 (  677)   end else if xnew=xcursor then begin
 191 (  696)     if ynew > ycursor then
 192 (  703)       drawy(xnew,ycursor,c,ynew-ycursor+1)
 193 (  734)     else
 194 (  741)       drawy(xnew,ynew,c,ycursor-ynew+1)
 195 (  767)   end else begin
 196 (  777)     {compute abs lenght of longer axis}
 197 (  777)     xl:=xnew-xcursor; if xl<0 then xl:=-xl;
 198 (  800)     yl:=ynew-ycursor; if yl<0 then yl:=-yl;
 199 (  832)     if xl>yl then cnt:=xl
 200 (  853)     else cnt:=yl;
 201 (  864)     if (cnt>0) then begin
 202 (  879)       xstep:=((xnew-xcursor)*128) div cnt;
 203 (  894)       ystep:=((ynew-ycursor)*128) div cnt;
 204 (  915)       drawxy(xcursor,ycursor,c,
 205 (  932)           cnt+1,xstep shl 1,ystep shl 1)
 206 (  956)     end
 207 (  963)   end;
 208 (  963)   xcursor:=xnew; ycursor:=ynew;
 209 (  971) end;
 210 (  979) 
 211 (  980) { plotmap(x,y,map)              }
 212 (  980) { plot 4x4 bitmap               }
 213 (  980) { the top left corner is bit 15 }
 214 (  980) 
 215 (  980) proc plotmap(x,y,m:integer);
 216 (  980) const abitmap=$c81b;
 217 (  983) mem grmap=$03b6: integer;
 218 (  983)     grx=$03ae: integer&;
 219 (  983)     gry=$03af: integer&;
 220 (  983) begin
 221 (  983)   grx:=x;
 222 (  985)   gry:=y;
 223 (  994)   if x<0 then grx:=0;
 224 ( 1015)   if x>(xsize-4) then grx:=xsize-4;
 225 ( 1037)   if y<0 then gry:=0;
 226 ( 1055)   if y>(ysize-4) then gry:=ysize-4;
 227 ( 1077)   grmap:=m;
 228 ( 1083)   call(abitmap);
 229 ( 1095) end;
 230 ( 1095) 
 231 ( 1096) { waitforkey                    }
 232 ( 1096) { wait for a key to be typed    }
 233 ( 1096) 
 234 ( 1096) proc waitforkey;
 235 ( 1096) const key=@1;
 236 ( 1099)       toggle=chr($0c);
 237 ( 1099) var ch:char;
 238 ( 1099) begin
 239 ( 1099)   repeat

----------------------------------------------------------------------

R65 COMPILE 4.2: library PLOTLIB          5/2/24 page 5

 240 ( 1099)     read(@key,ch);
 241 ( 1109)     if ch=toggle then write(ch);
 242 ( 1125)   until ch<>toggle;
 243 ( 1131) end;
 244 ( 1135) 
 245 ( 1136) begin {initialization}
 246 ( 1136)   grinit;
 247 ( 1142) end.
 248 ( 1142) 

End compile

Code lenght:          1141
Compiler stack size:  30
Ident stack size:     48
Pascal errors:        0
