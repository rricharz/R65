
R65 COMPILE 4.2: program CHKDSK           28/1/24 page 1


   1 (    4) { ***************************************
   2 (    4)   * chkdsk: check and fix a floppy disk *
   3 (    4)   ***************************************
   4 (    4) 
   5 (    4)   usage: chkdsk [d]      check drive d
   6 (    4)          chkdsk [d] /f   check and fix drive d
   7 (    4) 
   8 (    4)          Default for d is disk 1
   9 (    4) 
  10 (    4)   2024   rricharz                        }
  11 (    4) 
  12 (    4) program chkdsk;
  13 (    4) uses syslib,arglib;
  14 ( 1093) 
  15 ( 1093) const aprepdo  = $f4a7;
  16 ( 1096)       aenddo   = $f625;
  17 ( 1096)       agetentx = $f63a;
  18 ( 1096)       maxent   = 255;
  19 ( 1096)       tsectors = 2560;
  20 ( 1096) 
  21 ( 1096) mem   filerr   = $00db:integer&;
  22 ( 1096)       filtyp   = $0300:char&;
  23 ( 1096)       filcyc   = $0311:integer&;
  24 ( 1096)       filloc   = $0313:integer;
  25 ( 1096)       filsiz   = $0315:integer;
  26 ( 1096)       fillnk   = $031e:integer;
  27 ( 1096)       scyfc    = $037c:integer&;
  28 ( 1096) 
  29 ( 1096) var entry, sector,drive: integer;
  30 ( 1096)     done,fixit,default,notok: boolean;
  31 ( 1096) 
  32 ( 1096) proc checkfilerr;
  33 ( 1096) begin
  34 ( 1096)   if filerr<>0 then begin
  35 ( 1107)     call(aenddo);
  36 ( 1114)     writeln('Cannot read directory');
  37 ( 1142)     abort;
  38 ( 1146)   end;
  39 ( 1146) end;
  40 ( 1146) 
  41 ( 1147) func hex(d:integer):char;
  42 ( 1147) { convert hex digit to hex char }
  43 ( 1147) begin
  44 ( 1147)   if (d>=0) and (d<10) then
  45 ( 1166)     hex:=chr(d+ord('0'))
  46 ( 1176)   else if (d>=10) and (d<16) then
  47 ( 1199)     hex:=chr(d+ord('A')-10)
  48 ( 1212)   else hex:='?';
  49 ( 1223) end;
  50 ( 1227) 
  51 ( 1228) proc getdrive;
  52 ( 1228) var i:integer;
  53 ( 1231) { get drive number, default drive 1 }
  54 ( 1231) begin
  55 ( 1231)   drive:=1; {default drive}
  56 ( 1239)   filerr:=0;
  57 ( 1241)   if argtype[carg]='i' then agetval(drive,default);
  58 ( 1279)   if (drive<0) or (drive>1) then begin
  59 ( 1294)     writeln('Drive must be 0 or 1');

----------------------------------------------------------------------

R65 COMPILE 4.2: program CHKDSK           28/1/24 page 2

  60 ( 1324)     abort
  61 ( 1324)   end;
  62 ( 1328)   fildrv:=drive;
  63 ( 1328)   write('Checking drive ',drive,': ');
  64 ( 1360)   call(aprepdo);
  65 ( 1364)   checkfilerr;
  66 ( 1368)   scyfc:=255; { disk name }
  67 ( 1375)   call(agetentx);
  68 ( 1379)   checkfilerr;
  69 ( 1383)   for i:=0 to 15 do
  70 ( 1391)     write(filnam[i]);
  71 ( 1410)   writeln;
  72 ( 1424) end;
  73 ( 1430) 
  74 ( 1431) proc getoptions;
  75 ( 1431) var i,dummy:integer;
  76 ( 1434)     options:array[15] of char;
  77 ( 1434) begin
  78 ( 1434)   agetstring(options,default,dummy,dummy);
  79 ( 1476)   fixit:=false;
  80 ( 1478)   if not default then begin
  81 ( 1487)     if options[0]<>'/' then argerror(103);
  82 ( 1510)     for i:=1 to 15 do
  83 ( 1518)       case options[i] of
  84 ( 1531)         'F': fixit:=true;
  85 ( 1544)         ' ': begin end
  86 ( 1558)         else argerror(104)
  87 ( 1563)       end; {case}
  88 ( 1585)   end;
  89 ( 1585) end;
  90 ( 1585) 
  91 ( 1586) proc check;
  92 ( 1586) { check one entry }
  93 ( 1586) var i:integer;
  94 ( 1589)     ok:boolean;
  95 ( 1589) begin
  96 ( 1589)   scyfc:=entry;
  97 ( 1591)   call(agetentx);
  98 ( 1604)     checkfilerr;
  99 ( 1608)   write(entry+1,' ');
 100 ( 1618)   if (fillnk and 255) >= 128 then
 101 ( 1627)     write('DELETED SPACE       ')
 102 ( 1652)   else begin
 103 ( 1655)     for i:=0 to 15 do
 104 ( 1663)       write(filnam[i]);
 105 ( 1682)     write('.',hex(filcyc shr 4),
 106 ( 1713)       hex(filcyc and 15),' ');
 107 ( 1732)   end;
 108 ( 1732)   ok:=(sector=filloc);
 109 ( 1741)   sector:=sector+(filsiz shr 8);
 110 ( 1756)   if sector>tsectors then begin
 111 ( 1769)     writeln(invvid,'FILE SIZE TOO LONG',norvid);
 112 ( 1803)     notok:=true;
 113 ( 1805)   end else if (ok) then writeln('OK')
 114 ( 1822)   else begin
 115 ( 1831)     writeln(invvid,'SECTOR START INCONSISTENT',norvid);
 116 ( 1869)     notok:=true;
 117 ( 1871)   end;
 118 ( 1875) end;
 119 ( 1875) 

----------------------------------------------------------------------

R65 COMPILE 4.2: program CHKDSK           28/1/24 page 3

 120 ( 1876) begin
 121 ( 1876)   done:=false;
 122 ( 1880)   sector:=0;
 123 ( 1886)   entry:=0;
 124 ( 1892)   getdrive;
 125 ( 1900)   getoptions;
 126 ( 1904)   if fixit then begin
 127 ( 1908)     writeln('Fix errors not yet implemented');
 128 ( 1948)     call(aenddo);
 129 ( 1952)     abort;
 130 ( 1956)   end;
 131 ( 1956)   notok:=false;
 132 ( 1958)   repeat
 133 ( 1962)     check;
 134 ( 1966)     entry:=entry+1;
 135 ( 1972)   until (filtyp=chr(0)) or (entry>maxent);
 136 ( 1992)   if notok then
 137 ( 1996)     writeln(invvid,'INCONSISTENCY FOUND',norvid);
 138 ( 2035)   call(aenddo);
 139 ( 2039) end.

End compile

Code lenght:          2038
Compiler stack size:  46
Ident stack size:     96
Pascal errors:        0
