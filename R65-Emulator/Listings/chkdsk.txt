
R65 COMPILE 4.2: program CHKDSK           29/1/24 page 1


   1 (    4) { ***************************************
   2 (    4)   * chkdsk: check and fix a floppy disk *
   3 (    4)   ***************************************
   4 (    4) 
   5 (    4)   usage: chkdsk [d]      check drive d
   6 (    4)          chkdsk [d] /f   check and fix drive d
   7 (    4) 
   8 (    4)          Default for d is disk 1
   9 (    4) 
  10 (    4)   2024   rricharz                        }
  11 (    4) 
  12 (    4) program chkdsk;
  13 (    4) uses syslib,arglib;
  14 ( 1093) 
  15 ( 1093) const aprepdo  = $f4a7;
  16 ( 1096)       aenddo   = $f625;
  17 ( 1096)       agetentx = $f63a;
  18 ( 1096)       maxent   = 255;
  19 ( 1096)       tsectors = 2560;
  20 ( 1096) 
  21 ( 1096) mem   filerr   = $00db:integer&;
  22 ( 1096)       filtyp   = $0300:char&;
  23 ( 1096)       filcyc   = $0311:integer&;
  24 ( 1096)       filloc   = $0313:integer;
  25 ( 1096)       filsiz   = $0315:integer;
  26 ( 1096)       fillnk   = $031e:integer;
  27 ( 1096)       scyfc    = $037c:integer&;
  28 ( 1096) 
  29 ( 1096) var entry, sector,drive: integer;
  30 ( 1096)     done,fixit,default,notok: boolean;
  31 ( 1096) 
  32 ( 1096) proc checkfilerr;
  33 ( 1096) begin
  34 ( 1096)   if filerr<>0 then begin
  35 ( 1107)     call(aenddo);
  36 ( 1114)     writeln('Cannot read directory');
  37 ( 1142)     abort;
  38 ( 1146)   end;
  39 ( 1146) end;
  40 ( 1146) 
  41 ( 1147) func hex(d:integer):char;
  42 ( 1147) { convert hex digit to hex char }
  43 ( 1147) begin
  44 ( 1147)   if (d>=0) and (d<10) then
  45 ( 1166)     hex:=chr(d+ord('0'))
  46 ( 1176)   else if (d>=10) and (d<16) then
  47 ( 1199)     hex:=chr(d+ord('A')-10)
  48 ( 1212)   else hex:='?';
  49 ( 1223) end;
  50 ( 1227) 
  51 ( 1228) proc getdrive;
  52 ( 1228) var i:integer;
  53 ( 1231) { get drive number, default drive 1 }
  54 ( 1231) begin
  55 ( 1231)   drive:=1; {default drive}
  56 ( 1239)   filerr:=0;
  57 ( 1241)   if argtype[carg]='i' then agetval(drive,default);
  58 ( 1279)   if (drive<0) or (drive>1) then begin
  59 ( 1294)     writeln('Drive must be 0 or 1');

----------------------------------------------------------------------

R65 COMPILE 4.2: program CHKDSK           29/1/24 page 2

  60 ( 1324)     abort
  61 ( 1324)   end;
  62 ( 1328)   fildrv:=drive;
  63 ( 1328)   write('Checking drive ',drive,': ');
  64 ( 1360)   call(aprepdo);
  65 ( 1364)   checkfilerr;
  66 ( 1368)   scyfc:=255; { disk name }
  67 ( 1375)   call(agetentx);
  68 ( 1379)   checkfilerr;
  69 ( 1383)   for i:=0 to 15 do
  70 ( 1391)     write(filnam[i]);
  71 ( 1410)   writeln;
  72 ( 1424) end;
  73 ( 1430) 
  74 ( 1431) proc getoptions;
  75 ( 1431) var i,dummy:integer;
  76 ( 1434)     options:array[15] of char;
  77 ( 1434) begin
  78 ( 1434)   agetstring(options,default,dummy,dummy);
  79 ( 1476)   fixit:=false;
  80 ( 1478)   if not default then begin
  81 ( 1487)     if options[0]<>'/' then argerror(103);
  82 ( 1510)     for i:=1 to 15 do
  83 ( 1518)       case options[i] of
  84 ( 1531)         'F': fixit:=true;
  85 ( 1544)         ' ': begin end
  86 ( 1558)         else argerror(104)
  87 ( 1563)       end; {case}
  88 ( 1585)   end;
  89 ( 1585) end;
  90 ( 1585) 
  91 ( 1586) proc check;
  92 ( 1586) { check one entry }
  93 ( 1586) var i:integer;
  94 ( 1589)     ok:boolean;
  95 ( 1589) begin
  96 ( 1589)   write(entry+1,' ');
  97 ( 1601)   if (fillnk and 255) >= 128 then
  98 ( 1610)     write('DELETED SPACE       ')
  99 ( 1635)   else begin
 100 ( 1638)     for i:=0 to 15 do
 101 ( 1646)       write(filnam[i]);
 102 ( 1665)     write('.',hex(filcyc shr 4),
 103 ( 1696)       hex(filcyc and 15),' ');
 104 ( 1715)   end;
 105 ( 1715)   ok:=(sector=filloc);
 106 ( 1724)   sector:=sector+(filsiz shr 8);
 107 ( 1739)   if sector>tsectors then begin
 108 ( 1752)     writeln(invvid,'FILE SIZE TOO LONG',norvid);
 109 ( 1786)     notok:=true;
 110 ( 1788)   end else if (ok) then writeln('OK')
 111 ( 1805)   else begin
 112 ( 1814)     writeln(invvid,'SECTOR START INCONSISTENT',norvid);
 113 ( 1852)     notok:=true;
 114 ( 1854)   end;
 115 ( 1858) end;
 116 ( 1858) 
 117 ( 1859) begin
 118 ( 1859)   done:=false;
 119 ( 1863)   sector:=0;

----------------------------------------------------------------------

R65 COMPILE 4.2: program CHKDSK           29/1/24 page 3

 120 ( 1869)   entry:=0;
 121 ( 1875)   getdrive;
 122 ( 1883)   getoptions;
 123 ( 1887)   if fixit then begin
 124 ( 1891)     writeln('Fix errors not yet implemented');
 125 ( 1931)     call(aenddo);
 126 ( 1935)     abort;
 127 ( 1939)   end;
 128 ( 1939)   notok:=false;
 129 ( 1941)   scyfc:=entry;
 130 ( 1945)   call(agetentx);
 131 ( 1958)   checkfilerr;
 132 ( 1962)   repeat
 133 ( 1962)     check;
 134 ( 1966)     entry:=entry+1;
 135 ( 1972)     scyfc:=entry;
 136 ( 1977)     call(agetentx);
 137 ( 1990)     checkfilerr;
 138 ( 1994)     until (filtyp=chr(0)) or (entry>maxent);
 139 ( 2009)   if notok then
 140 ( 2013)     writeln(invvid,'INCONSISTENCY FOUND',norvid);
 141 ( 2052)   call(aenddo);
 142 ( 2056) end.

End compile

Code lenght:          2055
Compiler stack size:  46
Ident stack size:     96
Pascal errors:        0
