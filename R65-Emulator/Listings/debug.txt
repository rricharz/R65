
R65 COMPILE 4.2: program DEBUG            18/11/23 page 1


   1 (    4) program debug;
   2 (    4) uses syslib,arglib,strlib,ralib,mathlib;
   3 ( 6641) 
   4 ( 6641) const npcodes=$59;
   5 ( 6647) 
   6 ( 6647) var codename: array[npcodes] of cpnt;
   7 ( 6650)     codebytes: array[npcodes] of integer;
   8 ( 6653)     fcode,scode: file;
   9 ( 6656)     cdsize,i,code,line: integer;
  10 ( 6659)     name: array[15] of char;
  11 ( 6662)     cyclus,drive:integer;
  12 ( 6665)     default: boolean;
  13 ( 6668)     linestr:cpnt;
  14 ( 6671) 
  15 ( 6671) func readline(f: file; pnt: cpnt): boolean;
  16 ( 6674) {#########################################}
  17 ( 6677) const alteof=chr(127);
  18 ( 6683) var ch1: char;
  19 ( 6686)     pos: integer;
  20 ( 6689) begin
  21 ( 6692)   pos := 0; read(@f,ch1);
  22 ( 6713)   while (ch1>=' ') and (ch1<>alteof) and
  23 ( 6731)       (pos<strsize-1) do begin
  24 ( 6749)     pnt[pos]:=ch1; pos:=pos+1; read(@f,ch1);
  25 ( 6785)     end;
  26 ( 6789)   pnt[pos]:=endmark;
  27 ( 6801)   readline:=(ch1=eof) or (ch1=alteof);
  28 ( 6822) end;
  29 ( 6830) 
  30 ( 6831) proc setsubtype(var nm:array[15] of char;subtype:char);
  31 ( 6834) {#####################################################}
  32 ( 6837) var i:integer;
  33 ( 6843) begin
  34 ( 6846)   i:=0;
  35 ( 6853)   repeat
  36 ( 6860)     i:=i+1;
  37 ( 6869)   until (nm[i]=':') or
  38 ( 6888)     (nm[i]=' ') or (i>=14);
  39 ( 6910)   nm[i]:=':';
  40 ( 6923)   nm[i+1]:=subtype;
  41 ( 6937) end;
  42 ( 6948) 
  43 ( 6949) proc writehex(a:integer);
  44 ( 6952) {#######################}
  45 ( 6955) var h:integer;
  46 ( 6961)   func hexdigit(c:char):char;
  47 ( 6964)   var d:integer;
  48 ( 6970)   begin
  49 ( 6973)     d:=ord(c) and 15;
  50 ( 6984)     if d>9 then hexdigit:=chr(d-10+ord('A'))
  51 ( 7011)     else hexdigit:=chr(d+ord('0'));
  52 ( 7030)   end;
  53 ( 7038) begin
  54 ( 7042)   h:=a and 255;
  55 ( 7053)   write(hexdigit(chr(h shr 4)));
  56 ( 7078)   write(hexdigit(chr(h and 15)));
  57 ( 7098) end;
  58 ( 7101) 
  59 ( 7102) proc writeui(n:integer);

----------------------------------------------------------------------

R65 COMPILE 4.2: program DEBUG            18/11/23 page 2

  60 ( 7105) {######################}
  61 ( 7108) var limit:integer;
  62 ( 7114) begin
  63 ( 7117)   limit:=10000;
  64 ( 7125)   while (limit>n) and (limit>0) do begin
  65 ( 7152)     limit:=limit div 10; write(' ');
  66 ( 7168)   end;
  67 ( 7171)   write(n);
  68 ( 7182) end;
  69 ( 7185) 
  70 ( 7186) proc showprog;
  71 ( 7189) {############}
  72 ( 7192) var pc,a,b,c,codesize:integer;
  73 ( 7198)     r:real;
  74 ( 7201)     done:boolean;
  75 ( 7204) 
  76 ( 7204)   proc packreal(i1,i2:%integer;
  77 ( 7207)     var r:array[1] of %integer);
  78 ( 7210)   begin
  79 ( 7213)     r[0]:=i1; r[1]:=i2;
  80 ( 7233)   end;
  81 ( 7244) 
  82 ( 7245) begin
  83 ( 7248)   line:=1;
  84 ( 7255)   getbyte(fcode,0,a);
  85 ( 7274)   getbyte(fcode,1,b);
  86 ( 7289)   codesize:=a+(b shl 8);
  87 ( 7303)   writeln('Program size: ', codesize,' bytes, ',
  88 ( 7340)     b+1,' sectors');
  89 ( 7366)   writeln;
  90 ( 7369)   pc:=2;
  91 ( 7380)   repeat
  92 ( 7387)     getbyte(fcode,pc,code);
  93 ( 7404)     if code<0 then begin
  94 ( 7414)       writeln('Negative code');
  95 ( 7440)       exit;
  96 ( 7444)     end;
  97 ( 7447)     write('  '); writeui(pc);
  98 ( 7463)     write(' '), writehex(code);
  99 ( 7478)     write(' ',codebytes[code],' ');
 100 ( 7494)     if (code<=npcodes) and (code>=0) then
 101 ( 7511)       write(codename[code])
 102 ( 7522)     else begin
 103 ( 7533)       writeln('pcode not known');
 104 ( 7558)       exit;
 105 ( 7562)     end;
 106 ( 7565)     c:=0;
 107 ( 7570)     case codebytes[code] of
 108 ( 7581)       2: begin
 109 ( 7595)              getbyte(fcode,pc+1,a);
 110 ( 7615)              write(' ',a);
 111 ( 7625)            end;
 112 ( 7628)       3: begin
 113 ( 7641)              getbyte(fcode,pc+1,a);
 114 ( 7661)              getbyte(fcode,pc+2,b);
 115 ( 7681)              c:=a+(b shl 8);
 116 ( 7695)              { exception for JUMP }
 117 ( 7703)              if code=$24 then write(' ',c+pc+1)
 118 ( 7729)              else write(' ',c);
 119 ( 7744)            end;

----------------------------------------------------------------------

R65 COMPILE 4.2: program DEBUG            18/11/23 page 3

 120 ( 7747)       4: begin
 121 ( 7760)              getbyte(fcode,pc+1,a);
 122 ( 7780)              write(' ',a,',');
 123 ( 7792)              getbyte(fcode,pc+2,a);
 124 ( 7812)              getbyte(fcode,pc+3,b);
 125 ( 7832)              write(' ',a+(b shl 8));
 126 ( 7850)            end;
 127 ( 7853)       5: begin
 128 ( 7866)              getbyte(fcode,pc+1,a);
 129 ( 7886)              getbyte(fcode,pc+2,b);
 130 ( 7906)              write(' ',a+(b shl 8),' ');
 131 ( 7926)              getbyte(fcode,pc+3,a);
 132 ( 7946)              getbyte(fcode,pc+4,b);
 133 ( 7966)              write(' ',a+(b shl 8));
 134 ( 7984)          end;
 135 ( 7987)       6: begin
 136 ( 8000)              getbyte(fcode,pc+1,a);
 137 ( 8020)              write(' ',a,',');
 138 ( 8032)              getbyte(fcode,pc+2,a);
 139 ( 8052)              getbyte(fcode,pc+3,b);
 140 ( 8072)              c:=a+(b shl 8); ;
 141 ( 8091)              getbyte(fcode,pc+4,a);
 142 ( 8111)              getbyte(fcode,pc+5,b);
 143 ( 8131)              if code=$3a then begin
 144 ( 8141)                packreal(c, a+(b shl 8),r);
 145 ( 8181)                write(' '); writeflo(output,r);
 146 ( 8200)              end else begin
 147 ( 8206)                write(' ',c,' ');
 148 ( 8218)                write(' ',a+(b shl 8));
 149 ( 8236)              end;
 150 ( 8239)          end
 151 ( 8242)       end; {case}
 152 ( 8247)     writeln;
 153 ( 8250)     if (code=$59) then begin
 154 ( 8266)       { LINE }
 155 ( 8272)       done:=false;
 156 ( 8277)       while (line<=c) and not done do begin
 157 ( 8302)         done:=readline(scode,linestr);
 158 ( 8321)         writeln(line, ' ',linestr);
 159 ( 8346)         line:=line+1;
 160 ( 8355)       end;
 161 ( 8363)     end;
 162 ( 8369)     {if (pc=2) and (code=$24) then begin
 163 ( 8372)       if c>8 then writeln('Skipping libraries');
 164 ( 8372)       pc:=pc+c;
 165 ( 8372)     end;}
 166 ( 8372)     if codebytes[code]<>0 then
 167 ( 8385)       pc:=pc+codebytes[code]
 168 ( 8396)     else writeln('codebytes not known');
 169 ( 8441)     until (pc>=codesize) or (codebytes[code]=0) or
 170 ( 8464)       (line>10);
 171 ( 8475) end;
 172 ( 8482) 
 173 ( 8483) proc init;
 174 ( 8486) {########}
 175 ( 8489) var i:integer;
 176 ( 8495)   proc set(p:integer;n:cpnt;b:integer);
 177 ( 8498)   begin
 178 ( 8501)     codename[p]:=n; codebytes[p]:=b;
 179 ( 8525)   end;

----------------------------------------------------------------------

R65 COMPILE 4.2: program DEBUG            18/11/23 page 4

 180 ( 8536) begin
 181 ( 8540)   for i:=0 to npcodes+1 do begin
 182 ( 8565)     codename[i]:=nil; codebytes[i]:=0;
 183 ( 8584)   end;
 184 ( 8591)   set($00,'STOP',1);
 185 ( 8625)   set($01,'RETN',1);
 186 ( 8645)   set($02,'NEGA',1);
 187 ( 8665)   set($03,'ADDA',1);
 188 ( 8685)   set($04,'SUBA',1);
 189 ( 8705)   set($05,'MULA',1);
 190 ( 8725)   set($06,'DIVA',1);
 191 ( 8745)   set($07,'LOWB',1);
 192 ( 8765)   set($08,'TEQU',1);
 193 ( 8785)   set($09,'TNEQ',1);
 194 ( 8805)   set($0a,'TLES',1);
 195 ( 8825)   set($0b,'TGRE',1);
 196 ( 8845)   set($0c,'TGRT',1);
 197 ( 8865)   set($0d,'TLEE',1);
 198 ( 8885)   set($0e,'ORAC',1);
 199 ( 8905)   set($0f,'ANDA',1);
 200 ( 8925)   set($10,'EORA',1);
 201 ( 8945)   set($11,'NOTA',1);
 202 ( 8965)   set($12,'LEFT',3);
 203 ( 8985)   set($13,'RIGH',3);
 204 ( 9005)   set($14,'INCA',1);
 205 ( 9025)   set($15,'DECA',1);
 206 ( 9045)   set($16,'COPY',1);
 207 ( 9065)   set($17,'PEEK',1);
 208 ( 9085)   set($18,'POKE',1);
 209 ( 9105)   set($19,'CALA',1);
 210 ( 9125)   set($1a,'RLIN',0);
 211 ( 9145)   set($1b,'GETC',1);
 212 ( 9165)   set($1c,'GETN',1);
 213 ( 9185)   set($1d,'PRTC',1);
 214 ( 9205)   set($1e,'PRTN',1);
 215 ( 9225)   set($1f,'PRTS',0);
 216 ( 9245)   set($20,'LITB',2);
 217 ( 9265)   set($21,'INCB',2);
 218 ( 9285)   set($22,'LITW',3);
 219 ( 9305)   set($23,'INCW',3);
 220 ( 9325)   set($24,'JUMP',3);
 221 ( 9345)   set($25,'JMPZ',1);
 222 ( 9365)   set($26,'JMPO',1);
 223 ( 9385)   set($27,'LOAD',4);
 224 ( 9405)   set($28,'LODX',4);
 225 ( 9425)   set($29,'STOR',4);
 226 ( 9445)   set($2a,'STOX',4);
 227 ( 9465)   set($2b,'CALL',4);
 228 ( 9485)   set($2c,'SDEV',1);
 229 ( 9505)   set($2d,'RDEV',1);
 230 ( 9525)   set($2e,'FNAM',1);
 231 ( 9545)   set($2f,'OPNR',1);
 232 ( 9565)   set($30,'OPNW',1);
 233 ( 9585)   set($31,'CLOS',1);
 234 ( 9605)   set($32,'PRTI',2);
 235 ( 9625)   set($33,'GHGH',1);
 236 ( 9645)   set($34,'GLOW',1);
 237 ( 9665)   set($35,'PHGH',1);
 238 ( 9685)   set($36,'PLOW',1);
 239 ( 9705)   set($37,'GSEQ',1);

----------------------------------------------------------------------

R65 COMPILE 4.2: program DEBUG            18/11/23 page 5

 240 ( 9725)   set($38,'PSEQ',1);
 241 ( 9745)   set($39,'NBYT',0);
 242 ( 9765)   set($3a,'NWRD',6);
 243 ( 9785)   set($3b,'LODN',2);
 244 ( 9805)   set($3c,'STON',2);
 245 ( 9825)   set($3d,'LODI',1);
 246 ( 9845)   set($3e,'STOI',1);
 247 ( 9865)   set($3f,'EXST',1);
 248 ( 9885)   set($40,'TIND',5);
 249 ( 9905)   set($41,'RUNP',1);
 250 ( 9925)   set($42,'ADDF',1);
 251 ( 9945)   set($43,'SUBF',1);
 252 ( 9965)   set($44,'MULF',1);
 253 ( 9985)   set($45,'DIVF',1);
 254 (10005)   set($46,'FLOF',1);
 255 (10025)   set($47,'FIXF',1);
 256 (10045)   set($48,'FEQU',1);
 257 (10065)   set($49,'FNEQ',1);
 258 (10085)   set($4a,'FLES',1);
 259 (10105)   set($4b,'FGRE',1);
 260 (10125)   set($4c,'FGRT',1);
 261 (10145)   set($4d,'FLEE',1);
 262 (10165)   set($4e,'FCOM',1);
 263 (10185)   set($4f,'TFER',1);
 264 (10205)   set($50,'OPRA',1);
 265 (10225)   set($51,'GTRA',1);
 266 (10245)   set($52,'PTRA',1);
 267 (10265)   set($53,'SWA2',1);
 268 (10285)   set($54,'LDXI',1);
 269 (10305)   set($55,'STXI',3);
 270 (10325)   set($56,'CPNT',0);
 271 (10345)   set($57,'WRCP',1);
 272 (10365)   set($58,'ADPS',1);
 273 (10385)   set($59,'LINE',3);
 274 (10405) end;
 275 (10408) 
 276 (10409) begin {main}
 277 (10412)   init;
 278 (10422)   linestr:=strnew;
 279 (10431)   cyclus:=0; drive:=1;
 280 (10446)   agetstring(name,default,cyclus,drive);
 281 (10493)   setsubtype(name,'R');
 282 (10516)   writeln('Opening object file ');
 283 (10546)   fcode:=attach(name,0,1,fread,0,0,'R');
 284 (10575)   cdsize:=getsize;
 285 (10588)   writeln;
 286 (10595)   writeln('Object file opened, file size ',
 287 (10635)     cdsize div 256,' sectors');
 288 (10662)   setsubtype(name,'P');
 289 (10685)   asetfile(name,cyclus,drive,'P');
 290 (10710)   writeln('Opening source file ');
 291 (10740)   openr(scode);
 292 (10749)   writeln; writeln('Source file opened');
 293 (10783)   showprog;
 294 (10790)   close(fcode);
 295 (10799)   close(scode);
 296 (10808) end.

End compile

Code lenght:          10810
Compiler stack size:  165
Ident stack size:     154
Pascal errors:        0
