
R65 COMPILE 4.2: program PUTSOURCE        11/2/24 page 1


   1 (    4)  {
   2 (    4)          *****************
   3 (    4)          *               *
   4 (    4)          *   putsource   *
   5 (    4)          *               *
   6 (    4)          *****************
   7 (    4) 
   8 (    4)     move the source file from the WORK disk
   9 (    4)     on the disk SOURCEPASCAL or SOURCECOMPIL
  10 (    4) 
  11 (    4)     usage: putsource filename
  12 (    4) 
  13 (    4)     2019 rricharz (r77@bluewin.ch)
  14 (    4) }
  15 (    4) 
  16 (    4) program putsource;
  17 (    4) uses syslib,arglib,disklib;
  18 ( 1369) 
  19 ( 1369) const afloppy=$c827; { exdos vector }
  20 ( 1372)       aexport=$c82a; { exdos vector }
  21 ( 1372) 
  22 ( 1372) mem filerr=$db: integer&;
  23 ( 1372) 
  24 ( 1372) var cyclus,drive,k,dummy: integer;
  25 ( 1372)     fname,dname: array[15] of char;
  26 ( 1372)     default,ok: boolean;
  27 ( 1372) 
  28 ( 1372) {$I IFILE:P}
IFILE:P         .07  SP 0000-0600 00A1 11/02/24
{I}    1 ( 1372) { IFILE:P - common file handling procedures }
{I}    2 ( 1372) 
{I}    3 ( 1372) proc runprog
{I}    4 ( 1372)   (name: array[15] of char;
{I}    5 ( 1372)    cyc: integer; drv: integer);
{I}    6 ( 1372) var i: integer;
{I}    7 ( 1375) begin
{I}    8 ( 1375)   for i:=0 to 15 do filnm1[i]:=name[i];
{I}    9 ( 1402)   filcy1:=cyc; fildrv:=drv; filflg:=$40;
{I}   10 ( 1446)   run
{I}   11 ( 1450) end;
{I}   12 ( 1451) 
{I}   13 ( 1452) proc writename(text: array[15] of char);
{I}   14 ( 1452) { write name without blanks }
{I}   15 ( 1452) var i: integer;
{I}   16 ( 1455) 
{I}   17 ( 1455) begin
{I}   18 ( 1455)   for i:=0 to 15 do
{I}   19 ( 1465)     if text[i]<>' ' then write(text[i]);
{I}   20 ( 1497) end;
{I}   21 ( 1511) 
{I}   22 ( 1512) proc setsubtype(subtype:char);
{I}   23 ( 1512) var i:integer;
{I}   24 ( 1515) begin
{I}   25 ( 1515)   i:=0;
{I}   26 ( 1519)   repeat
{I}   27 ( 1523)     i:=i+1;
{I}   28 ( 1529)   until (fname[i]=':') or
{I}   29 ( 1545)     (fname[i]=' ') or (i>=14);
{I}   30 ( 1564)   fname[i]:=':';
{I}   31 ( 1574)   fname[i+1]:=subtype;
{I}   32 ( 1585) end;
{I}   33 ( 1593) 
{I}   34 ( 1594) func contains(t:array[7] of char):boolean;
{I}   35 ( 1594) { check for substring in fname }
{I}   36 ( 1594) { the substring must end with a blank }
{I}   37 ( 1594) var i,i1,j:integer;
{I}   38 ( 1597)     found:boolean;
{I}   39 ( 1597) begin
{I}   40 ( 1597)   i:=0; found:=false;
{I}   41 ( 1607)   repeat
{I}   42 ( 1611)     j:=0;
{I}   43 ( 1613)     if fname[i]=t[j] then begin
{I}   44 ( 1634)       i1:=i;
{I}   45 ( 1637)       repeat
{I}   46 ( 1645)         i1:=i1+1;
{I}   47 ( 1651)         j:=j+1;
{I}   48 ( 1662)         found:=t[j]=' ';
{I}   49 ( 1677)       until (i1>14) or (fname[i1]<>t[j])
{I}   50 ( 1701)                              or found;
{I}   51 ( 1707)     end;
{I}   52 ( 1715)     i:=i+1;
{I}   53 ( 1721)   until found or (i>15);
{I}   54 ( 1737)   contains:=found;
{I}   55 ( 1741) end;
{I}   56 ( 1749) 
{I}   57 ( 1750) 
{I}   58 ( 1750) func letter(ch:char):boolean;
{I}   59 ( 1750) begin
{I}   60 ( 1750)   letter:=(ch>='A') and (ch<='Z');
{I}   61 ( 1769) end;
{I}   62 ( 1774) 
{I}   63 ( 1775) proc setargs(name:array[15] of char;
{I}   64 ( 1775)   carg,cyc,drv:integer);
{I}   65 ( 1775) var k:integer;
{I}   66 ( 1778) begin
{I}   67 ( 1778)   argtype[carg]:='s';
{I}   68 ( 1786)     for k:=0 to 7 do
{I}   69 ( 1800)       arglist[carg+k]:=
{I}   70 ( 1818)         ord(packed(fname[2*k+1],
{I}   71 ( 1828)                     fname[2*k]));
{I}   72 ( 1844)     argtype[carg+8]:='i';
{I}   73 ( 1875)     arglist[carg+8]:=cyc;
{I}   74 ( 1888)     argtype[carg+9]:='i';
{I}   75 ( 1909)     arglist[carg+9]:=drv;
{I}   76 ( 1922) end;
{I}   77 ( 1934) 
{I}   78 ( 1935) proc setargi(val,carg:integer);
{I}   79 ( 1935) begin
{I}   80 ( 1935)   argtype[carg]:='i';
{I}   81 ( 1946)   arglist[carg]:=val;
{I}   82 ( 1956) end;
  29 ( 1969) 
  30 ( 1969) begin
  31 ( 1969)   ok:=true;
  32 ( 1973)   filerr:=0;
  33 ( 1979)   { get the argument (file name) }
  34 ( 1983)   cyclus:=0; drive:=0;
  35 ( 1991)   agetstring(fname,default,cyclus,drive);
  36 ( 2035)   if default or not letter(fname[0]) then
  37 ( 2053)     writeln('Usage: putsource filename')
  38 ( 2084)   else begin
  39 ( 2093)     setsubtype('P');
  40 ( 2101)       dname:='PSOURCE         ';
  41 ( 2119)     { make sure that WORK is on drive 1 }
  42 ( 2125)     writeln('Putting disk WORK in drive 1');
  43 ( 2160)     cyclus:=0; drive:=1;
  44 ( 2168)     asetfile('WORK            ',cyclus,drive,' ');
  45 ( 2206)     call(afloppy);
  46 ( 2210)     if (filerr<>0) then ok:=false;
  47 ( 2221)     { make sure that dname is on drive 0 }
  48 ( 2225)     write('Putting disk ');  writename(dname);
  49 ( 2251)     writeln(' in drive 0');
  50 ( 2269)     cyclus:=0; drive:=0;
  51 ( 2277)     asetfile(dname,cyclus,drive,' ');
  52 ( 2303)     call(afloppy);
  53 ( 2307)     if (filerr<>0) then ok:=false;
  54 ( 2318)     { copy the source file }
  55 ( 2322)     if ok then begin
  56 ( 2326)       write('Copying the source file ');
  57 ( 2354)       writename(fname);
  58 ( 2366)       writeln;
  59 ( 2366)       setargs(fname,0,0,1);
  60 ( 2390)       argtype[10]:='i';
  61 ( 2394)       arglist[10]:=0; {copy to drive 0}
  62 ( 2412)       argtype[11]:=chr(0);
  63 ( 2416)       cyclus:=0; drive:=0; filerr:=0;
  64 ( 2437)       runprog('COPY:R          ',cyclus,drive);
  65 ( 2473)     end;
  66 ( 2473)     if (filerr<>0) or (runerr<>0) then begin
  67 ( 2486)       ok:=false;
  68 ( 2491)       if filerr=6 then
  69 ( 2500)         writeln(invvid,
  70 ( 2506)           'Source file not found',norvid)
  71 ( 2531)       else
  72 ( 2538)         writeln(invvid,'Copy failed',norvid);
  73 ( 2565)     end else begin {if successfull}
  74 ( 2568)       setargi(filcyc,8);
  75 ( 2580)       { export the source file }
  76 ( 2580)       write('Exporting the source file');
  77 ( 2606)       fildrv:=1;
  78 ( 2608)       call(aexport);
  79 ( 2616)       writeln;
  80 ( 2616) 
  81 ( 2622)       { delete the source file }
  82 ( 2622)       writeln('Deleting the source file');
  83 ( 2653)       drive:=0; filerr:=0;
  84 ( 2661)       setargi(0,8);
  85 ( 2675)       runprog('DELETE:R        ',cyclus,drive);
  86 ( 2707)       if (filerr<>0) or (runerr<>0) then  begin
  87 ( 2720)         ok:=false;
  88 ( 2725)         writeln(invvid,
  89 ( 2731)           'Deleting original failed',norvid);
  90 ( 2766)       end;
  91 ( 2766) 
  92 ( 2766)       { clean the destination drive }
  93 ( 2766)       setargi(0,0);
  94 ( 2776)       argtype[1]:=chr(0);
  95 ( 2780)       cyclus:=0; drive:=0; filerr:=0;
  96 ( 2801)       runprog('CLEAN:R         ',cyclus,drive);
  97 ( 2837)       if (filerr<>0) or (runerr<>0) then
  98 ( 2849)          ok:=false;
  99 ( 2855) 
 100 ( 2859)       { pack the destination drive }
 101 ( 2859)       writeln('Packing PSOURCE');
 102 ( 2881)       setargi(0,0);
 103 ( 2891)       argtype[1]:=chr(0);
 104 ( 2895)       cyclus:=0; drive:=0; filerr:=0;
 105 ( 2916)       runprog('PACK:R          ',cyclus,drive);
 106 ( 2952)       if (filerr<>0) or (runerr<>0) then
 107 ( 2964)          ok:=false;
 108 ( 2970)       dummy:=freedsk(0,true);
 109 ( 2986)     end;
 110 ( 2990) 
 111 ( 2990)     { make sure that PASCAL is on drive 0 }
 112 ( 2990)     writeln('Putting disk PASCAL in drive 0');
 113 ( 3027)     cyclus:=0; drive:=0;
 114 ( 3035)     asetfile('PASCAL          ',cyclus,drive,' ');
 115 ( 3073)     call(afloppy);
 116 ( 3077)     if (filerr<>0) then ok:=false;
 117 ( 3088)   end;
 118 ( 3092)   if not ok then begin
 119 ( 3097)     writeln(invvid,'Putsource failed',norvid);
 120 ( 3129)     filerr:=0; runerr:=0;
 121 ( 3137)   end
 122 ( 3141) end.
 123 ( 3141) 

End compile

Code lenght:          3140
Compiler stack size:  71
Ident stack size:     96
Pascal errors:        0
