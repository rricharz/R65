
R65 COMPILE 4.2: program MATHLIB          14/11/23 page 1


   1 (    4) { ***************
   2 (    4)   * mathlib.pas *
   3 (    4)   ***************
   4 (    4) 
   5 (    4) Pascal math library
   6 (    4) 
   7 (    4) Version 1.1 RR 2019
   8 (    4) 
   9 (    4) Math real functions:
  10 (    4)   fabs(r)
  11 (    4)   sqrt(r)
  12 (    4)   sin(r)        r in deg
  13 (    4)   cos(r)        r in deg
  14 (    4)   tan(r)        r in deg
  15 (    4)   ln(r),log(r)
  16 (    4)   exp(r)
  17 (    4) 
  18 (    4) Real output functions:
  19 (    4)   writeflo(f,r)         exponential format
  20 (    4)   writefix(f,d,r)       fix point format
  21 (    4)   f     file to write to
  22 (    4)   d     digits after decimal point
  23 (    4)   r     real number to write             }
  24 (    4) 
  25 (    4) library mathlib;
  26 (    4) 
  27 (    4) const pi = 3.14159;
  28 (    7)       e  = 2.71828;
  29 (    7) 
  30 (    7) func fabs(x:real):real;
  31 (    7) {*********************}
  32 (    7) begin
  33 (    7)   if x<0. then fabs:=-x else fabs:=x;
  34 (   44) end;
  35 (   56) 
  36 (   57) func sqrt(n:real):real;
  37 (   57) {*********************}
  38 (   57) { using Newton's approximation }
  39 (   57) const accuracy = 0.0001; {rel accuracy }
  40 (   60) var lower,upper,guess:real;
  41 (   60) begin
  42 (   60)   if n=0.0 then begin sqrt:=0.0; exit end;
  43 (   91)   if n<0.0 then begin
  44 (  104)     writeln('sqrt(x) for x<0 called');
  45 (  136)     sqrt:=0.0; exit;
  46 (  149)     end;
  47 (  149)   if n<1.0 then begin
  48 (  162)     lower:=n; upper:=1.0
  49 (  177)   end else begin
  50 (  192)     lower:=1.0; upper:=n
  51 (  204)   end;
  52 (  216)   guess:=1.0;
  53 (  222)   while (upper-lower)>(accuracy*guess) do begin
  54 (  258)     guess:=(upper+lower)/2.0;
  55 (  277)     if (guess*guess)>n then upper:=guess
  56 (  307)     else lower:=guess
  57 (  322)   end;
  58 (  334)   sqrt:=(upper+lower)/2.0;
  59 (  356) end;

----------------------------------------------------------------------

R65 COMPILE 4.2: library MATHLIB          14/11/23 page 2

  60 (  363) 
  61 (  364) func cos(x:real):real;
  62 (  364) {********************}
  63 (  364) { argument x in degree }
  64 (  364) 
  65 (  364) var m:real;
  66 (  367) 
  67 (  367)   func cos0(x:real):real;
  68 (  367)   var t,s:real;
  69 (  370)     i, p:integer;
  70 (  370)   begin
  71 (  370)     p:=0; s:=1.; t:=1.;
  72 (  396)     while fabs(t/s) > 0.00001 do begin
  73 (  433)       p:=p+1;
  74 (  439)       t:=(-t*x*x)/(conv(2*p-1)*conv(2*p));
  75 (  485)       s:=s+t;
  76 (  498)     end;
  77 (  511)     cos0:=s;
  78 (  514)   end;
  79 (  526) 
  80 (  527) begin
  81 (  527)   if x<0. then m:=-x else m:=x;
  82 (  561)   while m>=(360.) do m:=m-360.;
  83 (  601)   if m=0. then cos:=1.
  84 (  627)   else if m=90. then cos:=0.
  85 (  658)   else if m=180. then cos:=-1.
  86 (  689)   else if m > 180. then begin
  87 (  718)     m:=m-180.;
  88 (  733)     if m>90. then cos:=cos0((180.-m)*pi/180.)
  89 (  784)     else cos:=-cos0(m*pi/180.);
  90 (  828)   end
  91 (  835)   else begin
  92 (  838)     if m>90. then cos:=-cos0((180.-m)*pi/180.)
  93 (  882)     else cos:=cos0(m*pi/180.);
  94 (  927)   end;
  95 (  933) end;
  96 (  933) 
  97 (  934) func sin(x:real):real;
  98 (  934) {********************}
  99 (  934) { argument x in degree }
 100 (  934) begin
 101 (  934)   sin:=cos(x-90.);
 102 (  960) end;
 103 (  966) 
 104 (  967) func tan(x:real):real;
 105 (  967) {********************}
 106 (  967) { argument x in degree }
 107 (  967) begin
 108 (  967)   if cos(x)=0.0 then begin
 109 (  993)     writeln('tan(90) undefined');
 110 ( 1020)     if sin(x)>0.0 then tan:=1.0e+38
 111 ( 1044)     else tan:=-1.0e+38
 112 ( 1059)   end else tan:=sin(x)/cos(x);
 113 ( 1103) end;
 114 ( 1110) 
 115 ( 1111) proc writeflo(f:file;r:real);
 116 ( 1111) {***************************}
 117 ( 1111) { write real in floating point format  }
 118 ( 1111) { right justified in field of 11 chars }
 119 ( 1111) { 3 digits after decimal point         }

----------------------------------------------------------------------

R65 COMPILE 4.2: library MATHLIB          14/11/23 page 3

 120 ( 1111) 
 121 ( 1111) var m: real;
 122 ( 1114)     e,i: integer;
 123 ( 1114)     sign: char;
 124 ( 1114) begin
 125 ( 1114)   e:=0; m:=r; sign:=' ';
 126 ( 1136)   if m<0. then begin sign:='-'; m:=-m; end;
 127 ( 1175)   while m>=10. do begin e:=e+1; m:=m/10.; end;
 128 ( 1221)   if m>0. then
 129 ( 1236)     while m<1. do begin e:=e-1; m:=10.*m; end;
 130 ( 1286)   m:=m+0.0005; { round }
 131 ( 1308)   if m>=10. then begin e:=e+1; m:=m/10.; end;
 132 ( 1354)   write(@f,' ',sign,trunc(m),'.');
 133 ( 1377)   for i:=1 to 3 do begin
 134 ( 1394)     m:=10.*(m-conv(trunc(m))); write(@f,trunc(m));
 135 ( 1436)   end;
 136 ( 1436)   if e<0 then begin write(@f,'e-'); e:=-e end
 137 ( 1469)   else write(@f,'e+');
 138 ( 1490)   if e>=10 then write(@f,e)
 139 ( 1505)   else if e>=1 then write(@f,'0',e)
 140 ( 1531)   else write(@f,'00');
 141 ( 1549) end;
 142 ( 1549) 
 143 ( 1550) proc writef0(f:file;d:integer;
 144 ( 1550)     r:real;fl:integer;centered:boolean);
 145 ( 1550) {**************************************}
 146 ( 1550) { write real in fixed point format     }
 147 ( 1550) { right justified or centered in field }
 148 ( 1550) { of fl chars (more if necessary)      }
 149 ( 1550) { d digits after decimal point         }
 150 ( 1550) { Warning! The floating point accuracy }
 151 ( 1550) { is only approximately 5 digits!      }
 152 ( 1550) 
 153 ( 1550) var m,rnd: real;
 154 ( 1553)     d1,i1,m1,n,n1:integer;
 155 ( 1553)     sign: char;
 156 ( 1553) begin
 157 ( 1553)   d1:=d;
 158 ( 1555)   if d1<0 then d1:=0;
 159 ( 1575)   if d1>3 then d1:=3;
 160 ( 1591)   case d1 of
 161 ( 1595)     0: rnd:=0.5;
 162 ( 1612)     1: rnd:=0.05;
 163 ( 1634)     2: rnd:=0.005;
 164 ( 1656)     3: rnd:=0.0005
 165 ( 1672)   end {case};
 166 ( 1686)   sign:=' '; m:=r;
 167 ( 1692)   if m<0. then begin sign:='-'; m:=-m; end;
 168 ( 1739)   m:=m+rnd; { round }
 169 ( 1758)   if m>32767. then writeflo(f,r)
 170 ( 1778)   else begin
 171 ( 1793)     { if m<2.*rnd then sign:=' ';}
 172 ( 1793)     m1:=trunc(m);
 173 ( 1799)     if m1<10 then n:=fl-3-d
 174 ( 1821)     else if m1<100 then n:=fl-4-d
 175 ( 1850)     else if m1<1000 then n:=fl-5-d
 176 ( 1880)     else if m1<10000 then n:=fl-6-d
 177 ( 1910)     else n:=fl-7-d;
 178 ( 1929)     if d=0 then n:=n+1;
 179 ( 1954)     n1:=n;

----------------------------------------------------------------------

R65 COMPILE 4.2: library MATHLIB          14/11/23 page 4

 180 ( 1959)     if centered then n:=n div 2;
 181 ( 1980)     for i1:=1 to n do write(@f,' ');
 182 ( 2012)     write(@f,sign,m1);
 183 ( 2042)     m:=m-conv(m1);
 184 ( 2052)     if d1>0 then write(@f,'.');
 185 ( 2078)     for i1:=1 to d1 do begin
 186 ( 2097)       m:=10.*m; write(@f,trunc(m));
 187 ( 2130)       m:=m-conv(trunc(m));
 188 ( 2143)     end;
 189 ( 2151)     for i1:=1 to n1-n do write(@f,' ');
 190 ( 2197)   end;
 191 ( 2211) end;
 192 ( 2211) 
 193 ( 2212) proc writefix(f:file;d:integer;r:real);
 194 ( 2212) {*************************************}
 195 ( 2212) { write real in fixed point format     }
 196 ( 2212) { right justified in field of 11 chars }
 197 ( 2212) { d digits after decimal point         }
 198 ( 2212) { Warning! The floating point accuracy }
 199 ( 2212) { is only approximately 5 digits!      }
 200 ( 2212) begin
 201 ( 2212)   writef0(f,d,r,11,false);
 202 ( 2241) end;
 203 ( 2241) 
 204 ( 2242) func readflo(f:file):real;
 205 ( 2242) {************************}
 206 ( 2242) { read real number                    }
 207 ( 2242) 
 208 ( 2242) var r: real;
 209 ( 2245)     n,n1: integer;
 210 ( 2245)     neg,ems: boolean;
 211 ( 2245)     ch: char;
 212 ( 2245) 
 213 ( 2245) begin
 214 ( 2245)   r:=0.0; neg:=false; read(@f,ch);
 215 ( 2275)   if (ch='+') then read(@f,ch)
 216 ( 2291)   else if (ch='-') then begin
 217 ( 2307)     neg:=true; read(@f,ch);
 218 ( 2326)   end;
 219 ( 2327)   while (ch<='9') and (ch>='0') do begin
 220 ( 2345)     r:=10.*r+conv(ord(ch)-ord('0')); read(@f,ch);
 221 ( 2383)   end;
 222 ( 2384)   if (ch<>'.') and (ch<>'E') and (ch<>'e') then
 223 ( 2409)   begin {numeric integer}
 224 ( 2413)     if neg then r:=-r; readflo:=r
 225 ( 2433)   end else begin {numeric real}
 226 ( 2448)     n:=0;
 227 ( 2450)     if (ch<>'E') and (ch<>'e') then read(@f,ch);
 228 ( 2482)     while (ch<='9') and (ch>='0') do begin
 229 ( 2501)       r:=10.*r+conv(ord(ch)-ord('0'));
 230 ( 2521)       n:=prec(n); read(@f,ch)
 231 ( 2543)     end;
 232 ( 2549)     if (ch='E') or (ch='e') then begin
 233 ( 2567)       ems:=false; read(@f,ch);
 234 ( 2586)       case ch of
 235 ( 2587)         '+': read(@f,ch);
 236 ( 2608)         '-': begin ems:=true; read(@f,ch) end
 237 ( 2635)       end;
 238 ( 2638)       n1:=0;
 239 ( 2640)       if (ch<='9') or (ch>='0') then begin

----------------------------------------------------------------------

R65 COMPILE 4.2: library MATHLIB          14/11/23 page 5

 240 ( 2659)         n1:=ord(ch)-ord('0'); read(@f,ch);
 241 ( 2683)         if (ch<='9') and (ch>='0') then begin
 242 ( 2699)           n1:=10*n1+ord(ch)-ord('0'); read(@f,ch);
 243 ( 2731)         end;
 244 ( 2732)         if ems then n:=n-n1 else n:=n+n1
 245 ( 2759)       end
 246 ( 2759)     end;
 247 ( 2768)     while n>0 do begin
 248 ( 2778)       n:=prec(n); r:=10.*r;
 249 ( 2793)     end;
 250 ( 2806)     while n<0 do begin n:=succ(n); r:=0.1*r; end;
 251 ( 2847)     if neg then r:=-r;
 252 ( 2857)     readflo:=r;
 253 ( 2870)   end
 254 ( 2882) end;
 255 ( 2882) 
 256 ( 2883) func ln(r:real):real;
 257 ( 2883) {*******************}
 258 ( 2883) { compute natural logarithm ln }
 259 ( 2883) var r0,rm1,rp1,a,b,res,d,q: real;
 260 ( 2886)     e1:integer;
 261 ( 2886) 
 262 ( 2886)   proc getexp(var r1:array[1] of %integer;
 263 ( 2886)     var e2: integer);
 264 ( 2886)   { extract exponent and set it to 0 }
 265 ( 2886)   begin
 266 ( 2886)     e2:=(r1[1] and $ff)-$7f;
 267 ( 2902)     r1[1]:=(r1[1] and $ff00) or $7f;
 268 ( 2921)   end;
 269 ( 2926) 
 270 ( 2927) begin
 271 ( 2927)   if fabs(r-1.0)<0.0001 then begin ln:=0.0; exit end;
 272 ( 2973)   if r<=0.0 then begin
 273 ( 2986)     writeln('ln(x) for x<=0 called');
 274 ( 3017)     ln:=-1.0e-38
 275 ( 3017)   end else begin
 276 ( 3033)     r0:=r;
 277 ( 3033)     { for faster calculation, extract exp }
 278 ( 3045)     getexp(r0,e1);
 279 ( 3069)     rm1:=r0-1.0; rp1:=r0+1.0; d:=1.0;
 280 ( 3113)     a:=rm1; b:=rp1; res:=0.0;
 281 ( 3149)     rm1:=rm1*rm1; rp1:=rp1*rp1;
 282 ( 3180)     repeat
 283 ( 3193)       q:=a/(d*b); res:=res+q;
 284 ( 3225)       a:=a*rm1; b:=b*rp1;
 285 ( 3263)       d:=d+2.0;
 286 ( 3288)     until (q<0.0001)and(q>-0.0001);
 287 ( 3322)     ln:=2.0*res+conv(e1)*0.69315;
 288 ( 3350)   end
 289 ( 3358) end;
 290 ( 3358) 
 291 ( 3359) func exp(x:real):real;
 292 ( 3359) {********************}
 293 ( 3359) { compute exponential function }
 294 ( 3359) const ln2=0.69315;
 295 ( 3362) var x0,f,res:real;
 296 ( 3362)     n,e2:integer;
 297 ( 3362) 
 298 ( 3362)   proc addpof2(var r1:array[1] of %integer;
 299 ( 3362)     e1: integer);

----------------------------------------------------------------------

R65 COMPILE 4.2: library MATHLIB          14/11/23 page 6

 300 ( 3362)   { add power of two }
 301 ( 3362)   begin
 302 ( 3362)     e2:=e1+(r1[1] and $ff);
 303 ( 3380)     r1[1]:=(r1[1] and $ff00)+e2;
 304 ( 3397)   end;
 305 ( 3406) 
 306 ( 3407) begin
 307 ( 3407)   { reduce to range -ln2 .. +ln2 }
 308 ( 3407)   x0:=fabs(x)/ln2;
 309 ( 3429)   e2:=trunc(x0);
 310 ( 3442)   x0:=(x0-conv(e2))*ln2;
 311 ( 3465)   { compute e-function }
 312 ( 3472)   res:=1.0; f:=1.0;
 313 ( 3490)   for n:=1 to 7 do begin
 314 ( 3513)     f:=f*x0/conv(n); res:=res+f;
 315 ( 3544)   end;
 316 ( 3557)   { add e2 back into result }
 317 ( 3571)   addpof2(res,e2);
 318 ( 3593)   if x<0.0 then res:=1.0/res;
 319 ( 3615)   exp:=res;
 320 ( 3628) end;
 321 ( 3640) 
 322 ( 3641) func log(x:real):real;
 323 ( 3641) begin
 324 ( 3641)   if fabs(x-10.0)<0.0001 then begin
 325 ( 3674)     log:=1.0; exit end;
 326 ( 3690)   log:=ln(x)*0.434294;
 327 ( 3710) end;
 328 ( 3717) 
 329 ( 3718) begin
 330 ( 3718) end.
 331 ( 3720) 

End compile

Code lenght:          3719
Compiler stack size:  44
Ident stack size:     32
Pascal errors:        0
