
R65 COMPILE 4.3: program NROFF            26/2/26 page 1


   1 (    4) program nroff;
   2 (    4) 
   3 (    4) { mininroff            }
   4 (    4) { Witten March 2026    }
   5 (    4) { R. Richarz / ChatGPT }
   6 (    4) 
   7 (    4) uses syslib, arglib;
   8 ( 1093) 
   9 ( 1093) const
  10 ( 1093)   maxline = 40;
  11 ( 1096)   maxout  = 200;
  12 ( 1096)   indstep = 4;
  13 ( 1096) 
  14 ( 1096) var
  15 ( 1096)   src      : file;
  16 ( 1096)   name     : array[15] of char;
  17 ( 1096)   default  : boolean;
  18 ( 1096)   cyclus, drive : integer;
  19 ( 1096) 
  20 ( 1096)   ch       : char;
  21 ( 1096)   line     : array[maxline] of char;
  22 ( 1096)   llen     : integer;
  23 ( 1096) 
  24 ( 1096)   outbuf   : array[maxout] of char;
  25 ( 1096)   outlen   : integer;
  26 ( 1096) 
  27 ( 1096)   fillmode : boolean;
  28 ( 1096)   indent   : integer;
  29 ( 1096)   linewidth: integer;
  30 ( 1096)   linecount: integer; { added by RR }
  31 ( 1096) 
  32 ( 1096) { --- helpers --- }
  33 ( 1096) 
  34 ( 1096) proc underline(n: integer; c: char);
  35 ( 1096) var m,i: integer;
  36 ( 1099) begin
  37 ( 1099)   m := n;
  38 ( 1101)   if m>linewidth then m := linewidth;
  39 ( 1121)   for i:=1 to m do write(c);
  40 ( 1153)   writeln;
  41 ( 1167) end;
  42 ( 1173) 
  43 ( 1174) func mod(k,m:integer):integer;
  44 ( 1174) begin
  45 ( 1174)   mod := k-((k div m)*m);
  46 ( 1197) end;
  47 ( 1202) 
  48 ( 1203) func upc(c: char): char;
  49 ( 1203) begin
  50 ( 1203)   if (c>='a') and (c<='z') then upc := chr(ord(c)-32)
  51 ( 1232)   else upc := c;
  52 ( 1241) end;
  53 ( 1249) 
  54 ( 1250) proc putspaces(n: integer);
  55 ( 1250) var i: integer;
  56 ( 1253) begin
  57 ( 1253)   for i:=1 to n do write(' ');
  58 ( 1276) end;
  59 ( 1290) 

----------------------------------------------------------------------

R65 COMPILE 4.3: program NROFF            26/2/26 page 2

  60 ( 1291) proc flushline;
  61 ( 1291) var i: integer;
  62 ( 1294) begin
  63 ( 1294)   if outlen>0 then begin
  64 ( 1303)     putspaces(indent);
  65 ( 1316)     for i:=0 to outlen-1 do write(outbuf[i]);
  66 ( 1347)     writeln;
  67 ( 1361)     outlen := 0;
  68 ( 1369)   end;
  69 ( 1373) end;
  70 ( 1373) 
  71 ( 1374) proc emitblank;
  72 ( 1374) begin
  73 ( 1374)   flushline;
  74 ( 1383)   writeln;
  75 ( 1383) end;
  76 ( 1389) 
  77 ( 1390) proc emittextnofill;
  78 ( 1390) var i: integer;
  79 ( 1393) begin
  80 ( 1393)   flushline;
  81 ( 1399)   putspaces(indent);
  82 ( 1409)   for i:=0 to llen-1 do write(line[i]);
  83 ( 1440)   writeln;
  84 ( 1454) end;
  85 ( 1460) 
  86 ( 1461) func isspace(c: char): boolean;
  87 ( 1461) begin
  88 ( 1461)   isspace := (c=' ') or (c=tab8);
  89 ( 1480) end;
  90 ( 1485) 
  91 ( 1486) { tab expansion to spaces (tab stops 8) }
  92 ( 1486) { into the current input line buffer }
  93 ( 1486) proc addchartoline(c: char);
  94 ( 1486) var k,spaces: integer;
  95 ( 1489) begin
  96 ( 1489)   if llen>=maxline then exit;
  97 ( 1502) 
  98 ( 1502)   if c=tab8 then begin
  99 ( 1509)     k := llen; { 0-based }
 100 ( 1520)     spaces := 8 - (mod(k,8));
 101 ( 1536)     while (spaces>0) and (llen<maxline) do begin
 102 ( 1559)       line[llen] := ' ';
 103 ( 1565)       llen := succ(llen);
 104 ( 1573)       spaces := prec(spaces);
 105 ( 1582)     end;
 106 ( 1587)   end else begin
 107 ( 1593)     line[llen] := c;
 108 ( 1597)     llen := succ(llen);
 109 ( 1609)   end;
 110 ( 1614) end;
 111 ( 1614) 
 112 ( 1615) { parse integer from line starting at pos (0-based), }
 113 ( 1615) { returns 0 if none }
 114 ( 1615) func parseintfrom(p: integer): integer;
 115 ( 1615) var v,pos: integer;
 116 ( 1618) begin
 117 ( 1618)   v := 0;
 118 ( 1622)   pos:=p;
 119 ( 1626)   while (pos<llen) and (line[pos]>='0')

----------------------------------------------------------------------

R65 COMPILE 4.3: program NROFF            26/2/26 page 3

 120 ( 1653)     and (line[pos]<='9')
 121 ( 1665)   do begin
 122 ( 1670)     v := v*10 + (ord(line[pos]) - ord('0'));
 123 ( 1688)     pos := succ(pos);
 124 ( 1697)   end;
 125 ( 1702)   parseintfrom := v;
 126 ( 1705) end;
 127 ( 1713) 
 128 ( 1714) { formatter: add a word to outbuf with wrapping }
 129 ( 1714) 
 130 ( 1714) proc addword(start, wlen: integer);
 131 ( 1714) var need, i: integer;
 132 ( 1717) begin
 133 ( 1717)   { space before word if not first }
 134 ( 1717)   need := wlen;
 135 ( 1719)   if outlen>0 then need := need + 1;
 136 ( 1743) 
 137 ( 1748)   if (indent + outlen + need) > linewidth then begin
 138 ( 1767)     flushline;
 139 ( 1774)   end;
 140 ( 1774) 
 141 ( 1774)   if outlen>0 then begin
 142 ( 1781)     outbuf[outlen] := ' ';
 143 ( 1790)     outlen := succ(outlen);
 144 ( 1798)   end;
 145 ( 1803) 
 146 ( 1803)   for i:=0 to wlen-1 do begin
 147 ( 1825)     if outlen<maxout then begin
 148 ( 1832)       outbuf[outlen] := line[start+i];
 149 ( 1848)       outlen := succ(outlen);
 150 ( 1860)     end;
 151 ( 1865)   end;
 152 ( 1865) end;
 153 ( 1879) 
 154 ( 1880) proc formatfillfromline;
 155 ( 1880) var i, wstart, wlen: integer;
 156 ( 1883) begin
 157 ( 1883)   i := 0;
 158 ( 1887)   while i<llen do begin
 159 ( 1903)     while (i<llen) and isspace(line[i]) do i:=succ(i);
 160 ( 1936) 
 161 ( 1944)     if i>=llen then exit;
 162 ( 1957)     wstart := i;
 163 ( 1957)     wlen := 0;
 164 ( 1967)     while (i<llen) and (not isspace(line[i])) do begin
 165 ( 2001)       i := succ(i);
 166 ( 2005)       wlen := succ(wlen);
 167 ( 2014)     end;
 168 ( 2019)     addword(wstart, wlen);
 169 ( 2036)   end;
 170 ( 2036) end;
 171 ( 2039) 
 172 ( 2040) { --- command handlers --- }
 173 ( 2040) 
 174 ( 2040) proc doSH;
 175 ( 2040) var i, pos: integer;
 176 ( 2043) begin
 177 ( 2043)   flushline;
 178 ( 2049)   writeln;
 179 ( 2049) 

----------------------------------------------------------------------

R65 COMPILE 4.3: program NROFF            26/2/26 page 4

 180 ( 2055)   { print rest of line after ".SH " in uppercase }
 181 ( 2055)   pos := 4; { expects: . S H space ... }
 182 ( 2061)   putspaces(indent);
 183 ( 2071)   i := pos;
 184 ( 2071)   while i<llen do begin
 185 ( 2091)     write(upc(line[i]));
 186 ( 2108)     i := succ(i);
 187 ( 2112)   end;
 188 ( 2117)   writeln;
 189 ( 2120) 
 190 ( 2126)   putspaces(indent);
 191 ( 2136)   underline(llen - 4,'=');
 192 ( 2151)   writeln;
 193 ( 2151)   writeln;
 194 ( 2157) end;
 195 ( 2163) 
 196 ( 2164) proc doSS;
 197 ( 2164) var i, pos: integer;
 198 ( 2167) begin
 199 ( 2167)   flushline;
 200 ( 2173)   writeln;
 201 ( 2173) 
 202 ( 2179)   { print rest of line after ".SH " in uppercase }
 203 ( 2179)   pos := 4; { expects: . S H space ... }
 204 ( 2185)   putspaces(indent);
 205 ( 2195)   i := pos;
 206 ( 2195)   while i<llen do begin
 207 ( 2215)     write(upc(line[i]));
 208 ( 2232)     i := succ(i);
 209 ( 2236)   end;
 210 ( 2241)   writeln;
 211 ( 2244)   putspaces(indent);
 212 ( 2260)   underline(llen - 4,'-');
 213 ( 2275)   writeln;
 214 ( 2275)   writeln;
 215 ( 2281) end;
 216 ( 2287) 
 217 ( 2288) proc doPP;
 218 ( 2288) begin
 219 ( 2288)   emitblank;
 220 ( 2297) end;
 221 ( 2297) 
 222 ( 2298) proc doBR;
 223 ( 2298) begin
 224 ( 2298)   flushline;
 225 ( 2307) end;
 226 ( 2307) 
 227 ( 2308) proc doNF;
 228 ( 2308) begin
 229 ( 2308)   flushline;
 230 ( 2317)   fillmode := false;
 231 ( 2319) end;
 232 ( 2323) 
 233 ( 2324) proc doFI;
 234 ( 2324) begin
 235 ( 2324)   flushline;
 236 ( 2333)   fillmode := true;
 237 ( 2335) end;
 238 ( 2339) 
 239 ( 2340) proc doRS;

----------------------------------------------------------------------

R65 COMPILE 4.3: program NROFF            26/2/26 page 5

 240 ( 2340) begin
 241 ( 2340)   flushline;
 242 ( 2349)   indent := indent + indstep;
 243 ( 2355) end;
 244 ( 2360) 
 245 ( 2361) proc doRE;
 246 ( 2361) begin
 247 ( 2361)   flushline;
 248 ( 2370)   if indent>=indstep then
 249 ( 2376)     indent := indent - indstep;
 250 ( 2386) end;
 251 ( 2391) 
 252 ( 2392) proc doSP;
 253 ( 2392) var n, j, s: integer;
 254 ( 2395) begin
 255 ( 2395)   flushline;
 256 ( 2401)   { syntax: ".sp" or ".sp n" }
 257 ( 2401)   s := 3;
 258 ( 2403)   while (s<llen) and (line[s]=' ') do
 259 ( 2427)     s:=succ(s);
 260 ( 2435)   if llen>3 then n := parseintfrom(s) else n := 1;
 261 ( 2474)   if n<=0 then n := 1;
 262 ( 2490)   for j:=1 to n do writeln;
 263 ( 2513) end;
 264 ( 2533) 
 265 ( 2534) proc doB;
 266 ( 2534) var i: integer;
 267 ( 2537) begin
 268 ( 2537)   flushline;
 269 ( 2543)   putspaces(indent);
 270 ( 2553)   write(invvid); { inverse video as "bold" }
 271 ( 2556) 
 272 ( 2556)   i := 3; { ".B " }
 273 ( 2562)   while i<llen do begin
 274 ( 2574)     write(line[i]);
 275 ( 2583)     i := succ(i);
 276 ( 2587)   end;
 277 ( 2592)   write(norvid);
 278 ( 2598)   writeln;
 279 ( 2598) end;
 280 ( 2604) 
 281 ( 2605) proc doI;
 282 ( 2605) var i: integer;
 283 ( 2608) begin
 284 ( 2608)   flushline;
 285 ( 2614)   putspaces(indent);
 286 ( 2624)   i := 3; { ".I " }
 287 ( 2630)   while i<llen do begin
 288 ( 2642)     write(line[i]);
 289 ( 2651)     i := succ(i);
 290 ( 2655)   end;
 291 ( 2660)   writeln;
 292 ( 2663) end;
 293 ( 2669) 
 294 ( 2670) { --- line reader: reads CR-terminated lines; }
 295 ( 2670) {     returns false on EOF }
 296 ( 2670) 
 297 ( 2670) func readline: boolean;
 298 ( 2670) begin
 299 ( 2670)   llen := 0;

----------------------------------------------------------------------

R65 COMPILE 4.3: program NROFF            26/2/26 page 6

 300 ( 2677) 
 301 ( 2681)   repeat
 302 ( 2681)     read(@src, ch);
 303 ( 2691)     if ch=eof then begin
 304 ( 2699)       readline := false;
 305 ( 2704)       exit;
 306 ( 2709)     end;
 307 ( 2709) 
 308 ( 2709)     if ch=lf then begin
 309 ( 2716)     end else if ch=cr then begin
 310 ( 2729)       readline := true;
 311 ( 2734)       exit;
 312 ( 2739)     end else begin
 313 ( 2742)       addchartoline(ch);
 314 ( 2752)     end;
 315 ( 2752)   until false;
 316 ( 2754) end;
 317 ( 2757) 
 318 ( 2758) { --- dispatcher --- }
 319 ( 2758) 
 320 ( 2758) proc handleline;
 321 ( 2758) begin
 322 ( 2758)   if (llen>=1) and (line[0]='.') then begin
 323 ( 2780)     { recognize 2-letter commands }
 324 ( 2783)     if (llen>=3) and (line[1]='S') and (line[2]='H')
 325 ( 2808)       then doSH
 326 ( 2810)     else if (llen>=3) and (line[1]='S')
 327 ( 2835)       and (line[2]='S') then doSS
 328 ( 2847)     else if (llen>=3) and (line[1]='P')
 329 ( 2872)       and (line[2]='P') then doPP
 330 ( 2884)     else if (llen>=3) and (line[1]='b')
 331 ( 2909)       and (line[2]='r') then doBR
 332 ( 2921)     else if (llen>=3) and (line[1]='n')
 333 ( 2946)        and (line[2]='f') then doNF
 334 ( 2958)     else if (llen>=3) and (line[1]='f')
 335 ( 2983)        and (line[2]='i') then doFI
 336 ( 2995)     else if (llen>=3) and (line[1]='R')
 337 ( 3020)        and (line[2]='S') then doRS
 338 ( 3032)     else if (llen>=3) and (line[1]='R')
 339 ( 3057)        and (line[2]='E') then doRE
 340 ( 3069)     else if (llen>=3) and (line[1]='s')
 341 ( 3094)        and (line[2]='p') then doSP
 342 ( 3106)     else if (llen>=2) and (line[1]='B') then doB
 343 ( 3133)     else if (llen>=2) and (line[1]='I') then doI
 344 ( 3160)     else begin
 345 ( 3170)       { unknown request: ignore }
 346 ( 3170)     end;
 347 ( 3170)   end else begin
 348 ( 3173)     { plain text }
 349 ( 3173)     if fillmode then formatfillfromline
 350 ( 3177)     else emittextnofill;
 351 ( 3191)   end;
 352 ( 3191) end;
 353 ( 3191) 
 354 ( 3192) { --- main --- }
 355 ( 3192) 
 356 ( 3192) begin
 357 ( 3192)   { defaults }
 358 ( 3192)   fillmode := true;
 359 ( 3197)   indent := 0;

----------------------------------------------------------------------

R65 COMPILE 4.3: program NROFF            26/2/26 page 7

 360 ( 3203)   linewidth := 40; { printed output line width }
 361 ( 3213)   linecount := 0;  { added by RR }
 362 ( 3219) 
 363 ( 3219)   { get filename from arguments }
 364 ( 3219)   { same pattern as compile }
 365 ( 3219)   cyclus := 0; drive := 1;
 366 ( 3227)   agetstring(name, default, cyclus, drive);
 367 ( 3271)   if default then begin
 368 ( 3275)     writeln('usage: nroff name[.cy[,drv]]');
 369 ( 3313)     abort;
 370 ( 3317)   end;
 371 ( 3317) 
 372 ( 3317)   asetfile(name, cyclus, drive, 'B'); { 'B' = text }
 373 ( 3339)   openr(src);
 374 ( 3345) 
 375 ( 3345)   agetval(linewidth,default); {max chars/line}
 376 ( 3365)   if (linewidth<20) then linewidth := 20;
 377 ( 3377)   if (linewidth>128) then linewidth :=128;
 378 ( 3393)   writeln;
 379 ( 3397)   write(prton);
 380 ( 3406) 
 381 ( 3406)   outlen := 0;
 382 ( 3408) 
 383 ( 3412)   while readline { and (linecount<20)} do begin
 384 ( 3421)     linecount := succ(linecount);
 385 ( 3425)     { writeln('line ', linecount); }
 386 ( 3430)     handleline;
 387 ( 3434)   end;
 388 ( 3434)   handleline;
 389 ( 3441)   flushline;
 390 ( 3445)   write(prtoff);
 391 ( 3448) 
 392 ( 3448)  end.
 393 ( 3448) 

End compile

Code lenght:          3447
Compiler stack size:  63
Ident stack size:     116
Pascal errors:        0
