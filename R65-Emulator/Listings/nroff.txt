
R65 COMPILE 4.3: program NROFF            27/2/26 page 1


   1 (    4) program nroff;
   2 (    4) 
   3 (    4) { mininroff            }
   4 (    4) { Witten March 2026    }
   5 (    4) { R. Richarz / ChatGPT }
   6 (    4) 
   7 (    4) uses syslib, arglib;
   8 ( 1093) 
   9 ( 1093) const
  10 ( 1093)   maxline = 40;
  11 ( 1096)   maxout  = 200;
  12 ( 1096)   indstep = 4;
  13 ( 1096)   maxtabs = 16;
  14 ( 1096)   debug   = false;
  15 ( 1096) 
  16 ( 1096) var
  17 ( 1096)   src      : file;
  18 ( 1096)   name     : array[15] of char;
  19 ( 1096)   default  : boolean;
  20 ( 1096)   cyclus, drive : integer;
  21 ( 1096) 
  22 ( 1096)   ch       : char;
  23 ( 1096)   line     : array[maxline] of char;
  24 ( 1096)   llen     : integer;
  25 ( 1096) 
  26 ( 1096)   outbuf   : array[maxout] of char;
  27 ( 1096)   outlen   : integer;
  28 ( 1096) 
  29 ( 1096)   fillmode : boolean;
  30 ( 1096)   indent   : integer;
  31 ( 1096)   linewidth: integer;
  32 ( 1096)   titlemode: boolean;
  33 ( 1096)   linecount: integer;
  34 ( 1096) 
  35 ( 1096)   tabstops : array[maxtabs] of integer;
  36 ( 1096)   ntab     : integer;
  37 ( 1096)   ipmode   : boolean;
  38 ( 1096)   ipindent : integer;
  39 ( 1096)   iphang   : integer;
  40 ( 1096)   preindent: boolean;
  41 ( 1096) 
  42 ( 1096)   thname : array[40] of char;
  43 ( 1096)   thlen  : integer;
  44 ( 1096) 
  45 ( 1096) { --- helpers --- }
  46 ( 1096) 
  47 ( 1096) func nexttab(col: integer): integer;
  48 ( 1096) var i: integer;
  49 ( 1099) begin
  50 ( 1099)   if ntab>0 then begin
  51 ( 1108)     for i:=0 to ntab-1 do
  52 ( 1123)       if tabstops[i]>col then begin
  53 ( 1146)         nexttab := tabstops[i];
  54 ( 1153)         exit;
  55 ( 1162)       end;
  56 ( 1162) 
  57 ( 1176)     { falls rechts von letztem tab }
  58 ( 1176)     nexttab := col + 8;
  59 ( 1182)   end

----------------------------------------------------------------------

R65 COMPILE 4.3: program NROFF            27/2/26 page 2

  60 ( 1187)   else begin
  61 ( 1190)     { default unix style }
  62 ( 1190)     nexttab := ((col div 8)+1)*8;
  63 ( 1202)   end;
  64 ( 1207) end;
  65 ( 1207) 
  66 ( 1208) proc underline(n: integer; c: char);
  67 ( 1208) var m,i: integer;
  68 ( 1211) begin
  69 ( 1211)   m := n;
  70 ( 1213)   if m>linewidth then m := linewidth;
  71 ( 1233)   for i:=1 to m do write(c);
  72 ( 1265)   writeln;
  73 ( 1279) end;
  74 ( 1285) 
  75 ( 1286) func upc(c: char): char;
  76 ( 1286) begin
  77 ( 1286)   if (c>='a') and (c<='z') then upc
  78 ( 1306)     := chr(ord(c)-32)
  79 ( 1315)   else upc := c;
  80 ( 1324) end;
  81 ( 1332) 
  82 ( 1333) proc putspaces(n: integer);
  83 ( 1333) var i: integer;
  84 ( 1336) begin
  85 ( 1336)   for i:=1 to n do write(' ');
  86 ( 1359) end;
  87 ( 1373) 
  88 ( 1374) proc writewithtabs;
  89 ( 1374) var i,col,target: integer;
  90 ( 1377) begin
  91 ( 1377)   col := indent;
  92 ( 1379) 
  93 ( 1387)   for i:=0 to outlen-1 do begin
  94 ( 1409) 
  95 ( 1409)     if outbuf[i]=tab8 then begin
  96 ( 1420)       target := nexttab(col);
  97 ( 1435)       while col<target do begin
  98 ( 1451)         write(' ');
  99 ( 1453)         col := succ(col);
 100 ( 1457)       end;
 101 ( 1462)     end
 102 ( 1465)     else begin
 103 ( 1468)       write(outbuf[i]);
 104 ( 1477)       col := succ(col);
 105 ( 1481)     end;
 106 ( 1486) 
 107 ( 1486)   end;
 108 ( 1486) end;
 109 ( 1500) 
 110 ( 1501) proc flushline;
 111 ( 1501) var i: integer;
 112 ( 1504) begin
 113 ( 1504)   if outlen>0 then begin
 114 ( 1513)     if not preindent then
 115 ( 1516)       putspaces(indent);
 116 ( 1534)     writewithtabs;
 117 ( 1538)     writeln;
 118 ( 1538)     outlen := 0;
 119 ( 1546)     preindent := false;

----------------------------------------------------------------------

R65 COMPILE 4.3: program NROFF            27/2/26 page 3

 120 ( 1552)   end;
 121 ( 1556) end;
 122 ( 1556) 
 123 ( 1557) proc emitblank;
 124 ( 1557) begin
 125 ( 1557)   flushline;
 126 ( 1566)  if linewidth>47 then writeln;
 127 ( 1576) end;
 128 ( 1582) 
 129 ( 1583) proc emittextnofill;
 130 ( 1583) var i: integer;
 131 ( 1586) begin
 132 ( 1586)   flushline;
 133 ( 1592)   putspaces(indent);
 134 ( 1602)   for i:=0 to llen-1 do write(line[i]);
 135 ( 1633)   writeln;
 136 ( 1647) end;
 137 ( 1653) 
 138 ( 1654) func isspace(c: char): boolean;
 139 ( 1654) begin
 140 ( 1654)   isspace := (c=' ') or (c=tab8);
 141 ( 1673) end;
 142 ( 1678) 
 143 ( 1679) { tab expansion to spaces (tab stops 8) }
 144 ( 1679) { into the current input line buffer }
 145 ( 1679) 
 146 ( 1679) proc addchartoline(c: char);
 147 ( 1679) var k,spaces: integer;
 148 ( 1682) begin
 149 ( 1682)   if llen>=maxline then exit;
 150 ( 1695)   line[llen] := c;
 151 ( 1699)   llen := succ(llen);
 152 ( 1711) end;
 153 ( 1716) 
 154 ( 1717) { parse integer from line starting at pos }
 155 ( 1717) { returns 0 if none }
 156 ( 1717) func parseintfrom(p: integer): integer;
 157 ( 1717) var v,pos: integer;
 158 ( 1720) begin
 159 ( 1720)   v := 0;
 160 ( 1724)   pos:=p;
 161 ( 1728)   while (pos<llen) and (line[pos]>='0')
 162 ( 1755)     and (line[pos]<='9')
 163 ( 1767)   do begin
 164 ( 1772)     v := v*10 + (ord(line[pos]) - ord('0'));
 165 ( 1790)     pos := succ(pos);
 166 ( 1799)   end;
 167 ( 1804)   parseintfrom := v;
 168 ( 1807) end;
 169 ( 1815) 
 170 ( 1816) {formatter: add word to outbuf with wrapping}
 171 ( 1816) 
 172 ( 1816) proc addword(start, wlen: integer);
 173 ( 1816) var need, i: integer;
 174 ( 1819) begin
 175 ( 1819)   { space before word if not first }
 176 ( 1819)   need := wlen;
 177 ( 1821)   if outlen>0 then need := need + 1;
 178 ( 1845) 
 179 ( 1850)   if (indent + outlen + need) > linewidth

----------------------------------------------------------------------

R65 COMPILE 4.3: program NROFF            27/2/26 page 4

 180 ( 1864)   then begin
 181 ( 1869)     flushline;
 182 ( 1876)   end;
 183 ( 1876) 
 184 ( 1876)   if outlen>0 then begin
 185 ( 1883)     outbuf[outlen] := ' ';
 186 ( 1892)     outlen := succ(outlen);
 187 ( 1900)   end;
 188 ( 1905) 
 189 ( 1905)   for i:=0 to wlen-1 do begin
 190 ( 1927)     if outlen<maxout then begin
 191 ( 1934)       outbuf[outlen] := line[start+i];
 192 ( 1950)       outlen := succ(outlen);
 193 ( 1962)     end;
 194 ( 1967)   end;
 195 ( 1967) end;
 196 ( 1981) 
 197 ( 1982) proc formatfillfromline;
 198 ( 1982) var i, wstart, wlen: integer;
 199 ( 1985) begin
 200 ( 1985)   i := 0;
 201 ( 1989) 
 202 ( 1993)   { NEW: ignore leading whitespace }
 203 ( 1993)   while (i < llen) and isspace(line[i]) do
 204 ( 2018)     i := succ(i);
 205 ( 2026) 
 206 ( 2034)   while i<llen do begin
 207 ( 2046)     while (i<llen) and isspace(line[i]) do
 208 ( 2071)       i:=succ(i);
 209 ( 2079) 
 210 ( 2087)     if i>=llen then exit;
 211 ( 2100)     wstart := i;
 212 ( 2100)     wlen := 0;
 213 ( 2110)     while (i<llen) and (not isspace(line[i]))
 214 ( 2139)     do begin
 215 ( 2144)       i := succ(i);
 216 ( 2148)       wlen := succ(wlen);
 217 ( 2157)     end;
 218 ( 2162)     addword(wstart, wlen);
 219 ( 2179)   end;
 220 ( 2179) end;
 221 ( 2182) 
 222 ( 2183) proc saveth(startpos: integer);
 223 ( 2183) var pos: integer;
 224 ( 2186) begin
 225 ( 2186)   pos:=startpos;
 226 ( 2188)   thlen := 0;
 227 ( 2198) 
 228 ( 2202)   while (pos<llen) and (line[pos]=' ') do
 229 ( 2222)     pos := succ(pos);
 230 ( 2230) 
 231 ( 2238)   while (pos<llen) and (line[pos]<>' ') do
 232 ( 2258)   begin
 233 ( 2262)     thname[thlen] := line[pos];
 234 ( 2270)     thlen := succ(thlen);
 235 ( 2282)     pos := succ(pos);
 236 ( 2291)   end;
 237 ( 2296) 
 238 ( 2299)   { section "(x)" anhC$ngen falls vorhanden }
 239 ( 2299)   while (pos<llen) and (line[pos]=' ') do

----------------------------------------------------------------------

R65 COMPILE 4.3: program NROFF            27/2/26 page 5

 240 ( 2319)     pos := succ(pos);
 241 ( 2327) 
 242 ( 2335)   if pos<llen then begin
 243 ( 2344)     thname[thlen] := '(';
 244 ( 2353)     thlen := succ(thlen);
 245 ( 2361) 
 246 ( 2366)     thname[thlen] := line[pos];
 247 ( 2374)     thlen := succ(thlen);
 248 ( 2386)     pos := succ(pos);
 249 ( 2395) 
 250 ( 2400)     thname[thlen] := ')'; thlen := succ(thlen);
 251 ( 2414)   end;
 252 ( 2419) end;
 253 ( 2419) 
 254 ( 2420) proc printTH;
 255 ( 2420) var i,spaces: integer;
 256 ( 2423) begin
 257 ( 2423)   flushline;
 258 ( 2429)   writeln;
 259 ( 2429)   putspaces(indent);
 260 ( 2445) 
 261 ( 2445)   { links }
 262 ( 2445)   for i:=0 to thlen-1 do
 263 ( 2457)     write(thname[i]);
 264 ( 2476) 
 265 ( 2490)   if linewidth>47 then begin
 266 ( 2497)     spaces := linewidth - (2*thlen) - indent;
 267 ( 2512)     if spaces<1 then spaces := 1;
 268 ( 2533)     while spaces>0 do begin
 269 ( 2547)       write(' ');
 270 ( 2549)       spaces := prec(spaces);
 271 ( 2553)     end;
 272 ( 2558) 
 273 ( 2561)     { rechts }
 274 ( 2561)     for i:=0 to thlen-1 do
 275 ( 2573)       write(thname[i]);
 276 ( 2592)   end;
 277 ( 2606) 
 278 ( 2606)   writeln;
 279 ( 2606)   writeln;
 280 ( 2612) end;
 281 ( 2618) 
 282 ( 2619) proc endip;
 283 ( 2619) begin
 284 ( 2619)   if ipmode then begin
 285 ( 2628)     indent := indent - iphang;
 286 ( 2635)     ipmode := false;
 287 ( 2646)     preindent := false;
 288 ( 2652)   end;
 289 ( 2656) end;
 290 ( 2656) 
 291 ( 2657) { --- command handlers --- }
 292 ( 2657) 
 293 ( 2657) proc doTH;
 294 ( 2657) begin
 295 ( 2657)   endip;
 296 ( 2666)   saveth(3);   { nach ".TH" }
 297 ( 2674)   printTH;
 298 ( 2678) end;
 299 ( 2678) 

----------------------------------------------------------------------

R65 COMPILE 4.3: program NROFF            27/2/26 page 6

 300 ( 2679) proc doTA;
 301 ( 2679) var p,v: integer;
 302 ( 2682) begin
 303 ( 2682)   if debug then writeln('< DOING ta >');
 304 ( 2708)   ntab := 0;
 305 ( 2710)   p := 3;   { nach ".ta" }
 306 ( 2720) 
 307 ( 2720)   while p<llen do begin
 308 ( 2732) 
 309 ( 2732)     while (p<llen) and (line[p]=' ') do
 310 ( 2752)       p := succ(p);
 311 ( 2760) 
 312 ( 2768)     if p>=llen then exit;
 313 ( 2781) 
 314 ( 2781)     v := parseintfrom(p);
 315 ( 2793) 
 316 ( 2797)     if (v>0) and (ntab<maxtabs) then begin
 317 ( 2812)       if debug then
 318 ( 2817)         writeln('< Setting tabstop ', ntab,
 319 ( 2839)         ' at ', v, '>');
 320 ( 2862)       tabstops[ntab] := v;
 321 ( 2866)       ntab := succ(ntab);
 322 ( 2878)     end;
 323 ( 2883) 
 324 ( 2883)     while (p<llen) and (line[p]<>' ') do
 325 ( 2903)       p := succ(p);
 326 ( 2911)   end;
 327 ( 2919) end;
 328 ( 2922) 
 329 ( 2923) proc doSH;
 330 ( 2923) var i, pos: integer;
 331 ( 2926) begin
 332 ( 2926)   endip;
 333 ( 2932)   flushline;
 334 ( 2936)   writeln;
 335 ( 2936) 
 336 ( 2942)   { print rest of line after ".SH " }
 337 ( 2942)   { in uppercase }
 338 ( 2942)   pos := 4; { expects: . S H space ... }
 339 ( 2948)   putspaces(indent);
 340 ( 2958)   i := pos;
 341 ( 2958)   while i<llen do begin
 342 ( 2978)     write(upc(line[i]));
 343 ( 2995)     i := succ(i);
 344 ( 2999)   end;
 345 ( 3004)   writeln;
 346 ( 3007) 
 347 ( 3013)   putspaces(indent);
 348 ( 3023)   underline(llen - 4,'=');
 349 ( 3038) end;
 350 ( 3038) 
 351 ( 3039) proc doSS;
 352 ( 3039) var i, pos: integer;
 353 ( 3042) begin
 354 ( 3042)   endip;
 355 ( 3048)   flushline;
 356 ( 3052)   writeln;
 357 ( 3052) 
 358 ( 3058)   { print rest of line after ".SH " }
 359 ( 3058)   { in uppercase }

----------------------------------------------------------------------

R65 COMPILE 4.3: program NROFF            27/2/26 page 7

 360 ( 3058)   pos := 4; { expects: . S H space ... }
 361 ( 3064)   putspaces(indent);
 362 ( 3074)   i := pos;
 363 ( 3074)   while i<llen do begin
 364 ( 3094)     write(upc(line[i]));
 365 ( 3111)     i := succ(i);
 366 ( 3115)   end;
 367 ( 3120)   writeln;
 368 ( 3123)   putspaces(indent);
 369 ( 3139)   underline(llen - 4,'-');
 370 ( 3154) end;
 371 ( 3154) 
 372 ( 3155) proc doPP;
 373 ( 3155) begin
 374 ( 3155)   endip;
 375 ( 3164)   emitblank;
 376 ( 3168) end;
 377 ( 3168) 
 378 ( 3169) proc doBR;
 379 ( 3169) begin
 380 ( 3169)   flushline;
 381 ( 3178) end;
 382 ( 3178) 
 383 ( 3179) proc doNF;
 384 ( 3179) begin
 385 ( 3179)   if debug then writeln('< doing nf >');
 386 ( 3208)   endip;
 387 ( 3212)   flushline;
 388 ( 3216)   fillmode := false;
 389 ( 3218) end;
 390 ( 3222) 
 391 ( 3223) proc doFI;
 392 ( 3223) begin
 393 ( 3223)   if debug then writeln('< DOING fi >');
 394 ( 3252)   endip;
 395 ( 3256)   flushline;
 396 ( 3260)   fillmode := true;
 397 ( 3262) end;
 398 ( 3266) 
 399 ( 3267) proc doRS;
 400 ( 3267) begin
 401 ( 3267)   endip;
 402 ( 3276)   flushline;
 403 ( 3280)   indent := indent + indstep;
 404 ( 3286) end;
 405 ( 3291) 
 406 ( 3292) proc doRE;
 407 ( 3292) begin
 408 ( 3292)   endip;
 409 ( 3301)   flushline;
 410 ( 3305)   if indent>=indstep then
 411 ( 3311)     indent := indent - indstep;
 412 ( 3321) end;
 413 ( 3326) 
 414 ( 3327) proc doSP;
 415 ( 3327) var n, j, s: integer;
 416 ( 3330) begin
 417 ( 3330)   flushline;
 418 ( 3336)   { syntax: ".sp" or ".sp n" }
 419 ( 3336)   s := 3;

----------------------------------------------------------------------

R65 COMPILE 4.3: program NROFF            27/2/26 page 8

 420 ( 3338)   while (s<llen) and (line[s]=' ') do
 421 ( 3362)     s:=succ(s);
 422 ( 3370)   if llen>3 then
 423 ( 3384)     n := parseintfrom(s)
 424 ( 3390)   else n := 1;
 425 ( 3409)   if n<=0 then n := 1;
 426 ( 3425)   for j:=1 to n do writeln;
 427 ( 3448) end;
 428 ( 3468) 
 429 ( 3469) proc doB;
 430 ( 3469) var i: integer;
 431 ( 3472) begin
 432 ( 3472)   flushline;
 433 ( 3478)   putspaces(indent);
 434 ( 3488)   write(invvid); { inverse video as "bold" }
 435 ( 3491) 
 436 ( 3491)   i := 3; { ".B " }
 437 ( 3497)   while i<llen do begin
 438 ( 3509)     write(line[i]);
 439 ( 3518)     i := succ(i);
 440 ( 3522)   end;
 441 ( 3527)   write(norvid);
 442 ( 3533)   writeln;
 443 ( 3533) end;
 444 ( 3539) 
 445 ( 3540) proc doI;
 446 ( 3540) var i: integer;
 447 ( 3543) begin
 448 ( 3543)   flushline;
 449 ( 3549)   putspaces(indent);
 450 ( 3559)   i := 3; { ".I " }
 451 ( 3565)   while i<llen do begin
 452 ( 3577)     write(line[i]);
 453 ( 3586)     i := succ(i);
 454 ( 3590)   end;
 455 ( 3595)   writeln;
 456 ( 3598) end;
 457 ( 3604) 
 458 ( 3605) proc doIP;
 459 ( 3605) var pos,col: integer;
 460 ( 3608) begin
 461 ( 3608)   if ipmode then begin
 462 ( 3614)     indent := indent - iphang;
 463 ( 3621)     ipmode := false;
 464 ( 3632)   end;
 465 ( 3636)   flushline;
 466 ( 3640)   pos := 3;   { nach ".IP" }
 467 ( 3646)   while (pos<llen) and (line[pos]=' ') do
 468 ( 3666)     pos := succ(pos);
 469 ( 3674) 
 470 ( 3682)   { label ausgeben }
 471 ( 3682)   putspaces(indent);
 472 ( 3692)   col := indent;
 473 ( 3692) 
 474 ( 3700)   while pos<llen do begin
 475 ( 3712)     write(line[pos]);
 476 ( 3721)     pos := succ(pos);
 477 ( 3725)     col := succ(col);
 478 ( 3734)   end;
 479 ( 3739) 

----------------------------------------------------------------------

R65 COMPILE 4.3: program NROFF            27/2/26 page 9

 480 ( 3742)   { bis zum haenging indent ausfuellen }
 481 ( 3742)   while col < (indent + iphang) do begin
 482 ( 3759)     write (' ');
 483 ( 3761)     col := succ(col);
 484 ( 3765)   end;
 485 ( 3770) 
 486 ( 3773)   { jetzt folgt text gleich }
 487 ( 3773) 
 488 ( 3773)   preindent := true;
 489 ( 3775)   indent := indent + iphang;
 490 ( 3783)   ipmode := true;
 491 ( 3794) end;
 492 ( 3798) 
 493 ( 3799) { --- line reader: reads CR-terminated lines; }
 494 ( 3799) {     returns false on EOF }
 495 ( 3799) 
 496 ( 3799) func readline: boolean;
 497 ( 3799) begin
 498 ( 3799)   llen := 0;
 499 ( 3806) 
 500 ( 3810)   repeat
 501 ( 3810)     read(@src, ch);
 502 ( 3820)     if ch=eof then begin
 503 ( 3828)       readline := false;
 504 ( 3833)       exit;
 505 ( 3838)     end;
 506 ( 3838) 
 507 ( 3838)     if ch=lf then begin
 508 ( 3845)     end else if ch=cr then begin
 509 ( 3858)       readline := true;
 510 ( 3863)       exit;
 511 ( 3868)     end else begin
 512 ( 3871)       addchartoline(ch);
 513 ( 3881)     end;
 514 ( 3881)   until false;
 515 ( 3883) end;
 516 ( 3886) 
 517 ( 3887) { --- dispatcher --- }
 518 ( 3887) 
 519 ( 3887) proc handleline;
 520 ( 3887) begin
 521 ( 3887)   if (llen>=1) and (line[0]='.') then begin
 522 ( 3909)     { recognize 2-letter commands }
 523 ( 3912)     if (llen>=3) and (line[1]='S')
 524 ( 3927)       and (line[2]='H') then doSH
 525 ( 3939)     else if (llen>=3) and (line[1]='S')
 526 ( 3964)       and (line[2]='S') then doSS
 527 ( 3976)     else if (llen>=3) and (line[1]='P')
 528 ( 4001)       and (line[2]='P') then doPP
 529 ( 4013)     else if (llen>=3) and (line[1]='b')
 530 ( 4038)       and (line[2]='r') then doBR
 531 ( 4050)     else if (llen>=3) and (line[1]='n')
 532 ( 4075)        and (line[2]='f') then doNF
 533 ( 4087)     else if (llen>=3) and (line[1]='f')
 534 ( 4112)        and (line[2]='i') then doFI
 535 ( 4124)     else if (llen>=3) and (line[1]='R')
 536 ( 4149)        and (line[2]='S') then doRS
 537 ( 4161)     else if (llen>=3) and (line[1]='R')
 538 ( 4186)        and (line[2]='E') then doRE
 539 ( 4198)     else if (llen>=3) and (line[1]='s')

----------------------------------------------------------------------

R65 COMPILE 4.3: program NROFF            27/2/26 page 10

 540 ( 4223)        and (line[2]='p') then doSP
 541 ( 4235)     else if (line[1]='t') and
 542 ( 4254)         (line[2]='a') then doTA
 543 ( 4264)     else if (line[1]='I') and
 544 ( 4283)         (line[2]='P') then doIP
 545 ( 4293)     else if (line[1]='T') and (line[2]='H')
 546 ( 4320)       then doTH
 547 ( 4322)     else if (llen>=2) and (line[1]='B')
 548 ( 4347)       then doB
 549 ( 4349)     else if (llen>=2) and (line[1]='I')
 550 ( 4374)       then doI
 551 ( 4376)     else begin
 552 ( 4386)       { unknown request: ignore }
 553 ( 4386)     end;
 554 ( 4386)   end else begin
 555 ( 4389)     { plain text }
 556 ( 4389)     if fillmode then formatfillfromline
 557 ( 4393)     else emittextnofill;
 558 ( 4407)   end;
 559 ( 4407) end;
 560 ( 4407) 
 561 ( 4408) { --- main --- }
 562 ( 4408) 
 563 ( 4408) begin
 564 ( 4408)   { defaults }
 565 ( 4408)   fillmode := true;
 566 ( 4413)   indent := 0;
 567 ( 4419)   linewidth := 47; { printed line width }
 568 ( 4429)   ntab := 0;
 569 ( 4431)   ipmode := false;
 570 ( 4437)   ipindent := 4;
 571 ( 4443)   iphang := 8;
 572 ( 4449)   preindent := false;
 573 ( 4455)   linecount := 0;  { added by RR }
 574 ( 4465) 
 575 ( 4465)   { get filename from arguments }
 576 ( 4465)   { same pattern as compile }
 577 ( 4465)   cyclus := 0; drive := 1;
 578 ( 4473)   agetstring(name, default, cyclus, drive);
 579 ( 4517)   if default then begin
 580 ( 4521)     writeln('usage: nroff name[.cy[,drv]]');
 581 ( 4559)     abort;
 582 ( 4563)   end;
 583 ( 4563) 
 584 ( 4563)   asetfile(name, cyclus, drive, 'B');
 585 ( 4585)   { 'B' = text }
 586 ( 4585)   openr(src);
 587 ( 4591) 
 588 ( 4591)   agetval(linewidth,default); {max chars/line}
 589 ( 4611)   if (linewidth<20) then linewidth := 20;
 590 ( 4623)   if (linewidth>128) then linewidth :=128;
 591 ( 4639)   writeln;
 592 ( 4643)   write(prton);
 593 ( 4652) 
 594 ( 4652)   outlen := 0;
 595 ( 4654) 
 596 ( 4658)   while readline { and (linecount<20)} do begin
 597 ( 4667)     linecount := succ(linecount);
 598 ( 4671)     { writeln('line ', linecount); }
 599 ( 4676)     handleline;

----------------------------------------------------------------------

R65 COMPILE 4.3: program NROFF            27/2/26 page 11

 600 ( 4680)   end;
 601 ( 4680)   handleline;
 602 ( 4687)   flushline;
 603 ( 4691)   write(prtoff);
 604 ( 4694) 
 605 ( 4694)  end.
 606 ( 4694) 

End compile

Code lenght:          4693
Compiler stack size:  64
Ident stack size:     134
Pascal errors:        0
