
R65 COMPILE 4.2: program DIR              12/11/23 page 1


   1 (    4) {
   2 (    4)          *******************
   3 (    4)          *                 *
   4 (    4)          *   dir <drive>   *
   5 (    4)          *                 *
   6 (    4)          *******************
   7 (    4) 
   8 (    4)     2018,2019 rricharz (r77@bluewin.ch)
   9 (    4)     2023 removed inverse video display
  10 (    4)     2023 default drive 1
  11 (    4) 
  12 (    4) Display the directory of a disk drive.
  13 (    4) Uses EPROM (disk.asm) calls to get info
  14 (    4) from disk directory.
  15 (    4) 
  16 (    4) Written 2018 to test the R65 emulator and
  17 (    4) to demonstrate the power of Tiny Pascal.
  18 (    4) 
  19 (    4) Makes a table to find out how long the
  20 (    4) longest name is. Then computes the number
  21 (    4) of columns which can be displayed and
  22 (    4) displays the directory.
  23 (    4) 
  24 (    4) Usage:  dir drive                   }
  25 (    4) 
  26 (    4) program dir;
  27 (    4) uses syslib,arglib,strlib;
  28 ( 2379) 
  29 ( 2379) {R65 disk eprom calls and params: }
  30 ( 2379) const aprepdo =$f4a7;
  31 ( 2382)       agetentx=$f63a;
  32 ( 2382)       aenddo  =$f625;
  33 ( 2382)       tsectors = 2560;
  34 ( 2382)       maxent  = 255;
  35 ( 2382) 
  36 ( 2382) mem   filtyp  =$0300: char&;
  37 ( 2382)       filcyc  =$0311: integer&;
  38 ( 2382)       filstp  =$0312: char&;
  39 ( 2382)       filloc  =$0313: integer;
  40 ( 2382)       filsiz  =$0315: integer;
  41 ( 2382)       fillnk  =$031e: integer;
  42 ( 2382)       scyfc   =$037c: integer&;
  43 ( 2382)       filerr  =$00db: integer&;
  44 ( 2382) 
  45 ( 2382) var default,sortit: boolean;
  46 ( 2382)     drive,index,i,ti,maxlen,nument,col,
  47 ( 2382)     ncol,row,nspaces,sfree,sdel,
  48 ( 2382)     lines        : integer;
  49 ( 2382)     ffree,fdel   : real;
  50 ( 2382)     filstptab    : array[80] of char;
  51 ( 2382)     s            : cpnt;
  52 ( 2382)     entry        : array[maxent] of cpnt;
  53 ( 2382) 
  54 ( 2382) func hex(d:integer):char;
  55 ( 2382) { convert hex digit to hex char }
  56 ( 2382) begin
  57 ( 2382)   if (d>=0) and (d<10) then
  58 ( 2401)     hex:=chr(d+ord('0'))
  59 ( 2411)   else if (d>=10) and (d<16) then

----------------------------------------------------------------------

R65 COMPILE 4.2: program DIR              12/11/23 page 2

  60 ( 2434)     hex:=chr(d+ord('A')-10)
  61 ( 2447)   else hex:='?';
  62 ( 2458) end;
  63 ( 2462) 
  64 ( 2463) proc checkfilerr;
  65 ( 2463) begin
  66 ( 2463)   if filerr<>0 then begin
  67 ( 2474)     writeln('Cannot read directory');
  68 ( 2505)     abort;
  69 ( 2509)   end;
  70 ( 2509) end;
  71 ( 2509) 
  72 ( 2510) func smaller(pnt1,pnt2:cpnt):boolean;
  73 ( 2510) var k:integer;
  74 ( 2513) begin
  75 ( 2513)   k:=0;
  76 ( 2517)   while (pnt2[k]=pnt1[k]) and (k<15) do
  77 ( 2549)     k:=k+1;
  78 ( 2559)   smaller:=(pnt2[k]<pnt1[k]);
  79 ( 2588) end;
  80 ( 2592) 
  81 ( 2593) proc sort;
  82 ( 2593) var i,j:integer;
  83 ( 2596)     savepnt:cpnt;
  84 ( 2596) begin
  85 ( 2596)   for i:=0 to nument-1 do
  86 ( 2610)      for j:=nument-1 downto i do
  87 ( 2631)        if smaller(entry[j],entry[j+1]) then begin
  88 ( 2671)           savepnt:=entry[j];
  89 ( 2678)           entry[j]:=entry[j+1];
  90 ( 2697)           entry[j+1]:=savepnt;
  91 ( 2712)        end;
  92 ( 2720) end;
  93 ( 2748) 
  94 ( 2749) proc getoptions;
  95 ( 2749) var dummy:integer;
  96 ( 2752)     options:array[15] of char;
  97 ( 2752) begin
  98 ( 2752)   agetstring(options,default,dummy,dummy);
  99 ( 2794)   sortit:=false;
 100 ( 2796)   if not default then begin
 101 ( 2805)     if options[0]<>'/' then argerror(103);
 102 ( 2828)     for i:=1 to 15 do
 103 ( 2836)       case options[i] of
 104 ( 2849)         'S': sortit:=true;
 105 ( 2862)         ' ': begin end
 106 ( 2876)         else argerror(104)
 107 ( 2881)       end; {case}
 108 ( 2903)   end;
 109 ( 2903) end;
 110 ( 2903) 
 111 ( 2904) begin {main}
 112 ( 2904)   drive:=1; {default drive}
 113 ( 2913)   filerr:=0;
 114 ( 2915)   if argtype[carg]='i' then agetval(drive,default);
 115 ( 2953)   if (drive<0) or (drive>1) then begin
 116 ( 2968)     writeln('Drive must be 0 or 1');
 117 ( 2998)     abort
 118 ( 2998)   end;
 119 ( 3002)   getoptions;

----------------------------------------------------------------------

R65 COMPILE 4.2: program DIR              12/11/23 page 3

 120 ( 3006)   fildrv:=drive;
 121 ( 3006)   call(aprepdo);
 122 ( 3018)   checkfilerr;
 123 ( 3022) 
 124 ( 3022)   scyfc:=255; { write disk name }
 125 ( 3029)   call(agetentx);
 126 ( 3033)   checkfilerr;
 127 ( 3037) 
 128 ( 3037)   write(invvid,'Directory drive ',drive,': ');
 129 ( 3065)   for i:=0 to 15 do
 130 ( 3073)     write(filnam[i]);
 131 ( 3092)   writeln(norvid);
 132 ( 3115) 
 133 ( 3115)   index:=0; ti:=0; maxlen:=0;
 134 ( 3129)   sdel:=0;
 135 ( 3135)   repeat
 136 ( 3139)     scyfc:=index;
 137 ( 3139)     call(agetentx);
 138 ( 3152)     checkfilerr;
 139 ( 3156)     { check for end mark }
 140 ( 3156)     if filtyp<>chr(0) then begin
 141 ( 3164)       { check for deleted flag }
 142 ( 3167)       if (fillnk and 255)<128 then begin
 143 ( 3177)         entry[ti]:=strnew;
 144 ( 3190)         s:=entry[ti];
 145 ( 3198)         for i:=0 to 15 do s[i]:=filnam[i];
 146 ( 3234)         for i:=16 to 20 do s[i]:=' ';
 147 ( 3277)         i:=20;
 148 ( 3297)         repeat
 149 ( 3301)           i:=i-1;
 150 ( 3307)         until (i=0) or
 151 ( 3319)           (s[i]<>' ');
 152 ( 3332)         s[i+1]:='.';
 153 ( 3345)         s[i+2]:=hex(filcyc shr 4);
 154 ( 3371)         s[i+3]:=hex(filcyc and 15);
 155 ( 3397)         if maxlen<i+3 then maxlen:=i+3;
 156 ( 3422)         filstptab[ti]:=filstp;
 157 ( 3435)         ti:=ti+1
 158 ( 3443)       end else {deleted}
 159 ( 3453)         sdel:=sdel+(filsiz shr 8);
 160 ( 3464)     end else {end mark}
 161 ( 3472)       sfree:=tsectors-filloc;
 162 ( 3479)     index:=index+1
 163 ( 3488)   until (index>=255) or (filtyp=chr(0));
 164 ( 3510)   call(aenddo);
 165 ( 3518) 
 166 ( 3518)   nument:=ti-1;
 167 ( 3524)   if sortit then sort;
 168 ( 3540)   ncol:=48 div (maxlen+2);
 169 ( 3549)   if nument<8 then ncol:=2
 170 ( 3564)   else if nument<8 then ncol:=1;
 171 ( 3585)   nspaces:=(48 div ncol)-maxlen-1;
 172 ( 3603)   lines:=nument div ncol;
 173 ( 3612) 
 174 ( 3621)   for col:=0 to lines do
 175 ( 3627)   begin
 176 ( 3640)     for row:=0 to ncol-1 do begin
 177 ( 3662)       ti:=col+(lines+1)*row;
 178 ( 3673)       s:=entry[ti];
 179 ( 3687)       if (ti<=nument) then begin

----------------------------------------------------------------------

R65 COMPILE 4.2: program DIR              12/11/23 page 4

 180 ( 3704)         for i:=0 to maxlen do
 181 ( 3713)           write(s[i]);
 182 ( 3737)         if row<(ncol-1) then
 183 ( 3762)           for i:=1 to nspaces do write(' ')
 184 ( 3787)       end
 185 ( 3787)     end;
 186 ( 3801)     writeln
 187 ( 3815)   end;
 188 ( 3821)   ffree:=conv(sfree)/conv(tsectors);
 189 ( 3843)   fdel:=conv(sdel)/conv(tsectors);
 190 ( 3859)   writeln('Free:',sfree,'(',
 191 ( 3880)     trunc(100.0*ffree+0.5),
 192 ( 3900)     '%),deleted:',sdel,'(',
 193 ( 3921)     trunc(100.0*fdel+0.5),'%),',
 194 ( 3947)     'files:',index-1);
 195 ( 3968) end.
 196 ( 3968) 

End compile

Code lenght:          3967
Compiler stack size:  78
Ident stack size:     128
Pascal errors:        0
