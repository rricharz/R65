
R65 COMPILE 4.2: program DIR              15/11/23 page 1


   1 (    4) {
   2 (    4)          *******************
   3 (    4)          *                 *
   4 (    4)          *   dir <drive>   *
   5 (    4)          *                 *
   6 (    4)          *******************
   7 (    4) 
   8 (    4)     2018,2019 rricharz (r77@bluewin.ch)
   9 (    4)     2023 removed inverse video display
  10 (    4)     2023 default drive 1
  11 (    4) 
  12 (    4) Display the directory of a disk drive.
  13 (    4) Uses EPROM (disk.asm) calls to get info
  14 (    4) from disk directory.
  15 (    4) 
  16 (    4) Written 2018 to test the R65 emulator and
  17 (    4) to demonstrate the power of Tiny Pascal.
  18 (    4) 
  19 (    4) Makes a table to find out how long the
  20 (    4) longest name is. Then computes the number
  21 (    4) of columns which can be displayed and
  22 (    4) displays the directory.
  23 (    4) 
  24 (    4) Usage:  dir drive                   }
  25 (    4) 
  26 (    4) program dir;
  27 (    4) uses syslib,arglib,strlib;
  28 ( 2460) 
  29 ( 2460) {R65 disk eprom calls and params: }
  30 ( 2460) const aprepdo =$f4a7;
  31 ( 2463)       agetentx=$f63a;
  32 ( 2463)       aenddo  =$f625;
  33 ( 2463)       tsectors = 2560;
  34 ( 2463)       maxent  = 255;
  35 ( 2463) 
  36 ( 2463) mem   filtyp  =$0300: char&;
  37 ( 2463)       filcyc  =$0311: integer&;
  38 ( 2463)       filstp  =$0312: char&;
  39 ( 2463)       filloc  =$0313: integer;
  40 ( 2463)       filsiz  =$0315: integer;
  41 ( 2463)       fillnk  =$031e: integer;
  42 ( 2463)       scyfc   =$037c: integer&;
  43 ( 2463)       filerr  =$00db: integer&;
  44 ( 2463) 
  45 ( 2463) var default,sortit: boolean;
  46 ( 2463)     drive,index,i,ti,maxlen,nument,col,
  47 ( 2463)     ncol,row,nspaces,sfree,sdel,
  48 ( 2463)     lines        : integer;
  49 ( 2463)     ffree,fdel   : real;
  50 ( 2463)     filstptab    : array[80] of char;
  51 ( 2463)     s            : cpnt;
  52 ( 2463)     entry        : array[maxent] of cpnt;
  53 ( 2463) 
  54 ( 2463) func hex(d:integer):char;
  55 ( 2463) { convert hex digit to hex char }
  56 ( 2463) begin
  57 ( 2463)   if (d>=0) and (d<10) then
  58 ( 2482)     hex:=chr(d+ord('0'))
  59 ( 2492)   else if (d>=10) and (d<16) then

----------------------------------------------------------------------

R65 COMPILE 4.2: program DIR              15/11/23 page 2

  60 ( 2515)     hex:=chr(d+ord('A')-10)
  61 ( 2528)   else hex:='?';
  62 ( 2539) end;
  63 ( 2543) 
  64 ( 2544) proc checkfilerr;
  65 ( 2544) begin
  66 ( 2544)   if filerr<>0 then begin
  67 ( 2555)     writeln('Cannot read directory');
  68 ( 2586)     abort;
  69 ( 2590)   end;
  70 ( 2590) end;
  71 ( 2590) 
  72 ( 2591) func smaller(pnt1,pnt2:cpnt):boolean;
  73 ( 2591) var k:integer;
  74 ( 2594) begin
  75 ( 2594)   k:=0;
  76 ( 2598)   while (pnt2[k]=pnt1[k]) and (k<15) do
  77 ( 2630)     k:=k+1;
  78 ( 2640)   smaller:=(pnt2[k]<pnt1[k]);
  79 ( 2669) end;
  80 ( 2673) 
  81 ( 2674) proc sort;
  82 ( 2674) var i,j:integer;
  83 ( 2677)     savepnt:cpnt;
  84 ( 2677) begin
  85 ( 2677)   for i:=0 to nument-1 do
  86 ( 2691)      for j:=nument-1 downto i do
  87 ( 2712)        if smaller(entry[j],entry[j+1]) then begin
  88 ( 2752)           savepnt:=entry[j];
  89 ( 2759)           entry[j]:=entry[j+1];
  90 ( 2778)           entry[j+1]:=savepnt;
  91 ( 2793)        end;
  92 ( 2801) end;
  93 ( 2829) 
  94 ( 2830) proc getoptions;
  95 ( 2830) var dummy:integer;
  96 ( 2833)     options:array[15] of char;
  97 ( 2833) begin
  98 ( 2833)   agetstring(options,default,dummy,dummy);
  99 ( 2875)   sortit:=false;
 100 ( 2877)   if not default then begin
 101 ( 2886)     if options[0]<>'/' then argerror(103);
 102 ( 2909)     for i:=1 to 15 do
 103 ( 2917)       case options[i] of
 104 ( 2930)         'S': sortit:=true;
 105 ( 2943)         ' ': begin end
 106 ( 2957)         else argerror(104)
 107 ( 2962)       end; {case}
 108 ( 2984)   end;
 109 ( 2984) end;
 110 ( 2984) 
 111 ( 2985) begin {main}
 112 ( 2985)   drive:=1; {default drive}
 113 ( 2994)   filerr:=0;
 114 ( 2996)   if argtype[carg]='i' then agetval(drive,default);
 115 ( 3034)   if (drive<0) or (drive>1) then begin
 116 ( 3049)     writeln('Drive must be 0 or 1');
 117 ( 3079)     abort
 118 ( 3079)   end;
 119 ( 3083)   getoptions;

----------------------------------------------------------------------

R65 COMPILE 4.2: program DIR              15/11/23 page 3

 120 ( 3087)   fildrv:=drive;
 121 ( 3087)   call(aprepdo);
 122 ( 3099)   checkfilerr;
 123 ( 3103) 
 124 ( 3103)   scyfc:=255; { write disk name }
 125 ( 3110)   call(agetentx);
 126 ( 3114)   checkfilerr;
 127 ( 3118) 
 128 ( 3118)   write(invvid,'Directory drive ',drive,': ');
 129 ( 3146)   for i:=0 to 15 do
 130 ( 3154)     write(filnam[i]);
 131 ( 3173)   writeln(norvid);
 132 ( 3196) 
 133 ( 3196)   index:=0; ti:=0; maxlen:=0;
 134 ( 3210)   sdel:=0;
 135 ( 3216)   repeat
 136 ( 3220)     scyfc:=index;
 137 ( 3220)     call(agetentx);
 138 ( 3233)     checkfilerr;
 139 ( 3237)     { check for end mark }
 140 ( 3237)     if filtyp<>chr(0) then begin
 141 ( 3245)       { check for deleted flag }
 142 ( 3248)       if (fillnk and 255)<128 then begin
 143 ( 3258)         entry[ti]:=strnew;
 144 ( 3271)         s:=entry[ti];
 145 ( 3279)         for i:=0 to 15 do s[i]:=filnam[i];
 146 ( 3315)         for i:=16 to 20 do s[i]:=' ';
 147 ( 3358)         i:=20;
 148 ( 3378)         repeat
 149 ( 3382)           i:=i-1;
 150 ( 3388)         until (i=0) or
 151 ( 3400)           (s[i]<>' ');
 152 ( 3413)         s[i+1]:='.';
 153 ( 3426)         s[i+2]:=hex(filcyc shr 4);
 154 ( 3452)         s[i+3]:=hex(filcyc and 15);
 155 ( 3478)         if maxlen<i+3 then maxlen:=i+3;
 156 ( 3503)         filstptab[ti]:=filstp;
 157 ( 3516)         ti:=ti+1
 158 ( 3524)       end else {deleted}
 159 ( 3534)         sdel:=sdel+(filsiz shr 8);
 160 ( 3545)     end else {end mark}
 161 ( 3553)       sfree:=tsectors-filloc;
 162 ( 3560)     index:=index+1
 163 ( 3569)   until (index>=255) or (filtyp=chr(0));
 164 ( 3591)   call(aenddo);
 165 ( 3599) 
 166 ( 3599)   nument:=ti-1;
 167 ( 3605)   if sortit then sort;
 168 ( 3621)   ncol:=48 div (maxlen+2);
 169 ( 3630)   if nument<8 then ncol:=2
 170 ( 3645)   else if nument<8 then ncol:=1;
 171 ( 3666)   nspaces:=(48 div ncol)-maxlen-1;
 172 ( 3684)   lines:=nument div ncol;
 173 ( 3693) 
 174 ( 3702)   for col:=0 to lines do
 175 ( 3708)   begin
 176 ( 3721)     for row:=0 to ncol-1 do begin
 177 ( 3743)       ti:=col+(lines+1)*row;
 178 ( 3754)       s:=entry[ti];
 179 ( 3768)       if (ti<=nument) then begin

----------------------------------------------------------------------

R65 COMPILE 4.2: program DIR              15/11/23 page 4

 180 ( 3785)         for i:=0 to maxlen do
 181 ( 3794)           write(s[i]);
 182 ( 3818)         if row<(ncol-1) then
 183 ( 3843)           for i:=1 to nspaces do write(' ')
 184 ( 3868)       end
 185 ( 3868)     end;
 186 ( 3882)     writeln
 187 ( 3896)   end;
 188 ( 3902)   ffree:=conv(sfree)/conv(tsectors);
 189 ( 3924)   fdel:=conv(sdel)/conv(tsectors);
 190 ( 3940)   writeln('Free:',sfree,'(',
 191 ( 3961)     trunc(100.0*ffree+0.5),
 192 ( 3981)     '%),deleted:',sdel,'(',
 193 ( 4002)     trunc(100.0*fdel+0.5),'%),',
 194 ( 4028)     'files:',index-1);
 195 ( 4049) end.
 196 ( 4049) 

End compile

Code lenght:          4048
Compiler stack size:  81
Ident stack size:     129
Pascal errors:        0
