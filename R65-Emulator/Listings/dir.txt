
R65 COMPILE 4.3: program DIR              28/2/26 page 1


   1 (    4) {
   2 (    4)          *******************
   3 (    4)          *                 *
   4 (    4)          *   dir <drive>   *
   5 (    4)          *                 *
   6 (    4)          *******************
   7 (    4) 
   8 (    4)     2018,2019 rricharz (r77@bluewin.ch)
   9 (    4)     2023 removed inverse video display
  10 (    4)     2023 default drive 1
  11 (    4) 
  12 (    4) Display the directory of a disk drive.
  13 (    4) Uses EPROM (disk.asm) calls to get info
  14 (    4) from disk directory.
  15 (    4) 
  16 (    4) Written 2018 to test the R65 emulator and
  17 (    4) to demonstrate the power of Tiny Pascal.
  18 (    4) 
  19 (    4) Makes a table to find out how long the
  20 (    4) longest name is. Then computes the number
  21 (    4) of columns which can be displayed and
  22 (    4) displays the directory.
  23 (    4) 
  24 (    4) option /S sorts the directory
  25 (    4) 
  26 (    4) Usage:  dir drive [/s]                   }
  27 (    4) 
  28 (    4) program dir;
  29 (    4) uses syslib,arglib,strlib;
  30 ( 2170) 
  31 ( 2170) {R65 disk eprom calls and params: }
  32 ( 2170) const aprepdo =$f4a7;
  33 ( 2173)       agetentx=$f63a;
  34 ( 2173)       aenddo  =$f625;
  35 ( 2173)       tsectors = 2560;
  36 ( 2173)       maxent  = 255;
  37 ( 2173) 
  38 ( 2173) mem   filtyp  =$0300: char&;
  39 ( 2173)       filcyc  =$0311: integer&;
  40 ( 2173)       filloc  =$0313: integer;
  41 ( 2173)       filsiz  =$0315: integer;
  42 ( 2173)       fillnk  =$031e: integer;
  43 ( 2173)       scyfc   =$037c: integer&;
  44 ( 2173)       filerr  =$00db: integer&;
  45 ( 2173) 
  46 ( 2173) var default,sortit: boolean;
  47 ( 2173)     drive,index,i,ti,maxlen,nument,col,
  48 ( 2173)     ncol,row,nspaces,sfree,sdel,
  49 ( 2173)     lines        : integer;
  50 ( 2173)     ffree,fdel   : real;
  51 ( 2173)     s            : cpnt;
  52 ( 2173)     entry        : array[maxent] of cpnt;
  53 ( 2173) 
  54 ( 2173) {$I IOPTION:P}
IOPTION:P       .02  SP 0000-0200 001A 28/02/26
{I}    1 ( 2173) { ioption - check and set option }
{I}    2 ( 2173) 
{I}    3 ( 2173) func option(opt:char):boolean;
{I}    4 ( 2173) var i,dummy,savecarg:integer;
{I}    5 ( 2176)     options:array[15] of char;

----------------------------------------------------------------------

R65 COMPILE 4.3: program DIR              28/2/26 page 2

{I}    6 ( 2176)     default:boolean;
{I}    7 ( 2176) begin
{I}    8 ( 2176)   savecarg:=carg; { save for next call to option }
{I}    9 ( 2186)   agetstring(options,default,dummy,dummy);
{I}   10 ( 2226)   option:=false;
{I}   11 ( 2228)   if not default then begin
{I}   12 ( 2237)     if options[0]<>'/' then argerror(103);
{I}   13 ( 2260)     for i:=1 to 15 do
{I}   14 ( 2268)       if options[i]=opt then option:=true;
{I}   15 ( 2295)   end;
{I}   16 ( 2313)   carg:=savecarg;
{I}   17 ( 2313) end;
  55 ( 2322) 
  56 ( 2322) func hex(d:integer):char;
  57 ( 2322) { convert hex digit to hex char }
  58 ( 2322) begin
  59 ( 2322)   if (d>=0) and (d<10) then
  60 ( 2341)     hex:=chr(d+ord('0'))
  61 ( 2351)   else if (d>=10) and (d<16) then
  62 ( 2374)     hex:=chr(d+ord('A')-10)
  63 ( 2387)   else hex:='?';
  64 ( 2398) end;
  65 ( 2402) 
  66 ( 2403) proc checkfilerr;
  67 ( 2403) begin
  68 ( 2403)   if filerr<>0 then begin
  69 ( 2414)     writeln('Cannot read directory');
  70 ( 2445)     abort;
  71 ( 2449)   end;
  72 ( 2449) end;
  73 ( 2449) 
  74 ( 2450) func smaller(pnt1,pnt2:cpnt):boolean;
  75 ( 2450) var k:integer;
  76 ( 2453) begin
  77 ( 2453)   k:=0;
  78 ( 2457)   while (pnt2[k]=pnt1[k]) and (k<15) do
  79 ( 2489)     k:=k+1;
  80 ( 2499)   smaller:=(pnt2[k]<pnt1[k]);
  81 ( 2528) end;
  82 ( 2532) 
  83 ( 2533) proc sort;
  84 ( 2533) var i,j:integer;
  85 ( 2536)     savepnt:cpnt;
  86 ( 2536) begin
  87 ( 2536)   for i:=0 to nument-1 do
  88 ( 2550)      for j:=nument-1 downto i do
  89 ( 2571)        if smaller(entry[j],entry[j+1]) then begin
  90 ( 2611)           savepnt:=entry[j];
  91 ( 2618)           entry[j]:=entry[j+1];
  92 ( 2637)           entry[j+1]:=savepnt;
  93 ( 2652)        end;
  94 ( 2660) end;
  95 ( 2688) 
  96 ( 2689) begin {main}
  97 ( 2689)   drive:=1; {default drive}
  98 ( 2698)   filerr:=0;
  99 ( 2700)   if argtype[carg]='i' then agetval(drive,default);
 100 ( 2738)   if (drive<0) or (drive>1) then begin
 101 ( 2753)     writeln('Drive must be 0 or 1');
 102 ( 2783)     abort

----------------------------------------------------------------------

R65 COMPILE 4.3: program DIR              28/2/26 page 3

 103 ( 2783)   end;
 104 ( 2787)   if option('H') then begin
 105 ( 2797)     writeln('/S   sort directory');
 106 ( 2826)     exit;
 107 ( 2827)   end;
 108 ( 2827)   sortit:=option('S');
 109 ( 2837)   fildrv:=drive;
 110 ( 2841)   call(aprepdo);
 111 ( 2853)   checkfilerr;
 112 ( 2857) 
 113 ( 2857)   scyfc:=255; { write disk name }
 114 ( 2864)   call(agetentx);
 115 ( 2868)   checkfilerr;
 116 ( 2872) 
 117 ( 2872)   write(invvid,'Directory drive ',drive,': ');
 118 ( 2900)   for i:=0 to 15 do
 119 ( 2908)     write(filnam[i]);
 120 ( 2927)   writeln(norvid);
 121 ( 2950) 
 122 ( 2950)   index:=0; ti:=0; maxlen:=0;
 123 ( 2964)   sdel:=0;
 124 ( 2970)   repeat
 125 ( 2974)     scyfc:=index;
 126 ( 2974)     call(agetentx);
 127 ( 2987)     checkfilerr;
 128 ( 2991)     { check for end mark }
 129 ( 2991)     if filtyp<>chr(0) then begin
 130 ( 2999)       { check for deleted flag }
 131 ( 3002)       if (fillnk and 255)<128 then begin
 132 ( 3012)         entry[ti]:=new;
 133 ( 3025)         s:=entry[ti];
 134 ( 3033)         for i:=0 to 15 do s[i]:=filnam[i];
 135 ( 3069)         for i:=16 to 20 do s[i]:=' ';
 136 ( 3112)         i:=20;
 137 ( 3132)         repeat
 138 ( 3136)           i:=i-1;
 139 ( 3142)         until (i=0) or
 140 ( 3154)           (s[i]<>' ');
 141 ( 3167)         s[i+1]:='.';
 142 ( 3180)         s[i+2]:=hex(filcyc shr 4);
 143 ( 3206)         s[i+3]:=hex(filcyc and 15);
 144 ( 3232)         if maxlen<i+3 then maxlen:=i+3;
 145 ( 3257)         ti:=ti+1
 146 ( 3266)       end else {deleted}
 147 ( 3276)         sdel:=sdel+(filsiz shr 8);
 148 ( 3287)     end else {end mark}
 149 ( 3295)       sfree:=tsectors-filloc;
 150 ( 3302)     index:=index+1
 151 ( 3311)   until (index>=255) or (filtyp=chr(0));
 152 ( 3333)   call(aenddo);
 153 ( 3341) 
 154 ( 3341)   nument:=ti-1;
 155 ( 3347)   if sortit then sort;
 156 ( 3363)   ncol:=48 div (maxlen+2);
 157 ( 3372)   if nument<8 then ncol:=2
 158 ( 3387)   else if nument<8 then ncol:=1;
 159 ( 3408)   nspaces:=(48 div ncol)-maxlen-1;
 160 ( 3426)   lines:=nument div ncol;
 161 ( 3435) 
 162 ( 3444)   for col:=0 to lines do

----------------------------------------------------------------------

R65 COMPILE 4.3: program DIR              28/2/26 page 4

 163 ( 3450)   begin
 164 ( 3463)     for row:=0 to ncol-1 do begin
 165 ( 3485)       ti:=col+(lines+1)*row;
 166 ( 3496)       s:=entry[ti];
 167 ( 3510)       if (ti<=nument) then begin
 168 ( 3527)         for i:=0 to maxlen do
 169 ( 3536)           write(s[i]);
 170 ( 3560)         if row<(ncol-1) then
 171 ( 3585)           for i:=1 to nspaces do write(' ')
 172 ( 3610)       end
 173 ( 3610)     end;
 174 ( 3624)     writeln
 175 ( 3638)   end;
 176 ( 3644)   ffree:=conv(sfree)/conv(tsectors);
 177 ( 3666)   fdel:=conv(sdel)/conv(tsectors);
 178 ( 3682)   writeln('Free:',sfree,'(',
 179 ( 3703)     trunc(100.0*ffree+0.5),
 180 ( 3723)     '%),deleted:',sdel,'(',
 181 ( 3744)     trunc(100.0*fdel+0.5),'%),',
 182 ( 3770)     'files:',index-1);
 183 ( 3791) end.
 184 ( 3791) 

End compile

Code lenght:          3790
Compiler stack size:  85
Ident stack size:     131
Pascal errors:        0
