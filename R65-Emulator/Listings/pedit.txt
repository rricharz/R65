
R65 Pascal program PEDIT           9/11/23     page 1


                   1 (    4) program pedit;
                   2 (    4) 
                   3 (    4) { Pascal editor, original 1980 RR
                   4 (    4)   rewritten 2023 RR for R65 system }
                   5 (    4) 
                   6 (    4) uses syslib, arglib, strlib,disklib;
                   7 ( 2655) 
                   8 ( 2655) const
                   9 ( 2655)     maxlines= 360;      xmax   = 56;
                  10 ( 2658)     scrlins = 16;       mlenght= 19;
                  11 ( 2658)     inpx    = 37;
                  12 ( 2658)     eol     = chr($00); esc    = chr($00);
                  13 ( 2658)     rdown   = chr($02); rup    = chr($08);
                  14 ( 2658)     pgdown  = chr($26); pgup   = chr($24);
                  15 ( 2658)     pgend   = chr($10); clrscr = chr($11);
                  16 ( 2658)     clrlin  = chr($17); cdown  = chr($18);
                  17 ( 2658)     cup     = chr($1a); cleft  = chr($03);
                  18 ( 2658)     inschr  = chr($15); delchr = chr($19);
                  19 ( 2658)     rubout  = chr($5f); cright = chr($16);
                  20 ( 2658) 
                  21 ( 2658) mem curlin  = $ed: integer&;
                  22 ( 2658)     curpos  = $ee: integer&;
                  23 ( 2658)     filcyc  = $311: integer&;
                  24 ( 2658)     video   = $400: array[900] of char&;
                  25 ( 2658)     topi    = $400: array[xmax] of integer&;
                  26 ( 2658)     topc    = $400: array[xmax] of char&;
                  27 ( 2658) 
                  28 ( 2658) 
                  29 ( 2658) var line,nlines,topline,i,dummy,debug: integer;
                  30 ( 2658)     name: array[15] of char;
                  31 ( 2658)     fno: file;
                  32 ( 2658)     chi : char;
                  33 ( 2658)     cyclus,drive,mark,nmark,savecx: integer;
                  34 ( 2658)     default, iseof, exit: boolean;
                  35 ( 2658)     fs: cpnt;
                  36 ( 2658)     linepnt: array[maxlines] of cpnt;
                  37 ( 2658)     relpnt:  integer;
                  38 ( 2658)     stemp,stemp2: cpnt;
                  39 ( 2658) 
                  40 ( 2658) proc putontop(s:cpnt;pos:integer;inv:boolean);
                  41 ( 2658) var i:integer;
                  42 ( 2661) begin
                  43 ( 2661)   i:=0; { faster version: if not in loop }
                  44 ( 2669)   if inv then while s[i]<>endmark do begin
                  45 ( 2692)     topi[i+pos]:=ord(s[i]) or 128; i:=i+1;
                  46 ( 2727)   end else while s[i]<>endmark do begin
                  47 ( 2754)     topc[i+pos]:=s[i]; i:=i+1;
                  48 ( 2786)   end;
                  49 ( 2791) end;
                  50 ( 2794) 
                  51 ( 2795) proc release(p:cpnt);
                  52 ( 2795) begin
                  53 ( 2795)   linepnt[relpnt]:=p; relpnt:=relpnt-1;
                  54 ( 2818) end;
                  55 ( 2823) 
                  56 ( 2824) proc setnumlin(l,c:integer);
                  57 ( 2824) mem numlin=$1789: integer&;
                  58 ( 2827)     numchr=$178a: integer&;
                  59 ( 2827) begin

----------------------------------------------------------------------

R65 Pascal program PEDIT           9/11/23     page 2

                  60 ( 2827)   numlin:=l; numchr:=c;
                  61 ( 2838) end;
                  62 ( 2847) 
                  63 ( 2848) func column:integer;
                  64 ( 2848) begin
                  65 ( 2848)   column:=line-topline+1;
                  66 ( 2864) end;
                  67 ( 2869) 
                  68 ( 2870) proc goto(xpos, ypos: integer);
                  69 ( 2870) begin
                  70 ( 2870)   curlin:=ypos; { top on line 2 }
                  71 ( 2883)   if curlin>15 then curlin:=15;
                  72 ( 2894)   curpos:=xpos-1;
                  73 ( 2904) end;
                  74 ( 2909) 
                  75 ( 2910) proc clrmessage;
                  76 ( 2910) var i:integer;
                  77 ( 2913) begin
                  78 ( 2913)   for i:=inpx-1 to xmax-1 do topi[i]:=128;
                  79 ( 2944) end;
                  80 ( 2965) 
                  81 ( 2966) proc showerror(s:cpnt);
                  82 ( 2966) var i: integer;
                  83 ( 2969)     ch: char;
                  84 ( 2969) begin
                  85 ( 2969)   clrmessage;
                  86 ( 2975)   putontop(s,36,true);
                  87 ( 2989)   read(@key,ch);
                  88 ( 2997)   clrmessage;
                  89 ( 3002) end;
                  90 ( 3002) 
                  91 ( 3003) func new:cpnt;
                  92 ( 3003) var i:integer;
                  93 ( 3006)     s:cpnt;
                  94 ( 3006) begin
                  95 ( 3006)   if relpnt<maxlines-1 then begin
                  96 ( 3019)     relpnt:=relpnt+1; new:=linepnt[relpnt];
                  97 ( 3037)   end else begin
                  98 ( 3048)     if nlines<maxlines-1 then begin
                  99 ( 3059)       s:=strnew;
                 100 ( 3068)       for i:=0 to xmax-1 do s[i]:=' ';
                 101 ( 3098)       s[xmax]:=endmark;
                 102 ( 3120)       new:=s;
                 103 ( 3124)     end else new:=nil;
                 104 ( 3137)     if nlines>maxlines-5 then
                 105 ( 3150)       showerror('Warning: Low memory');
                 106 ( 3183)   end;
                 107 ( 3183) end;
                 108 ( 3183) 
                 109 ( 3184) proc newline;
                 110 ( 3184) begin
                 111 ( 3184)   linepnt[nlines]:=new;
                 112 ( 3199)   nlines:=nlines+1;
                 113 ( 3209) end;
                 114 ( 3214) 
                 115 ( 3215) proc getinput(var n:integer; s:cpnt);
                 116 ( 3215) var i,j,stop:integer; ch: char;
                 117 ( 3218) begin
                 118 ( 3218)   goto(inpx,0); write(chr(ord(':') or 128));
                 119 ( 3237)   read(@key,ch); i:=0;

----------------------------------------------------------------------

R65 Pascal program PEDIT           9/11/23     page 3

                 120 ( 3248)   while (ch<>chr(13)) and (ch<>esc) do begin
                 121 ( 3271)     if (ch=rubout) then begin
                 122 ( 3278)       if i>0 then i:=i-1; goto(i+inpx+1,0);
                 123 ( 3320)       write(chr(ord(' ') or 128),cleft);
                 124 ( 3330)     end else if (ch>=' ') and (ch<=chr($7d)) and
                 125 ( 3348)       (inpx+i<xmax-1) then begin
                 126 ( 3363)       goto(i+inpx+1,0);
                 127 ( 3384)       write(chr(ord(ch) or 128)); i:=i+1;
                 128 ( 3399)     end;
                 129 ( 3404)     read(@key,ch);
                 130 ( 3412)   end;
                 131 ( 3413)   stop:=i+inpx;
                 132 ( 3422)   i:=inpx; n:=0;
                 133 ( 3435)   while ((topi[i] and 127)>=ord('0')) and
                 134 ( 3454)     ((topi[i] and 127)<=ord('9')) and
                 135 ( 3469)     (i<stop) do begin
                 136 ( 3483)     n:=10*n+(topi[i] and 127)-ord('0');
                 137 ( 3505)     i:=i+1;
                 138 ( 3516)   end;
                 139 ( 3521)   j:=0;
                 140 ( 3526)   while i<stop do begin
                 141 ( 3542)     s[j]:=chr(topi[i] and 127); i:=i+1; j:=j+1;
                 142 ( 3580)   end;
                 143 ( 3585)   s[j]:=endmark;
                 144 ( 3594) end;
                 145 ( 3598) 
                 146 ( 3599) func readline(input: file; pnt: cpnt): boolean;
                 147 ( 3599) const alteof=chr(127);
                 148 ( 3602) var ch1: char;
                 149 ( 3602)     pos: integer;
                 150 ( 3602) begin
                 151 ( 3602)   pos := 0; read(@fno,ch1);
                 152 ( 3620)   while (ch1>=' ') and (ch1<>alteof) and
                 153 ( 3635)       (pos<xmax-1) do begin
                 154 ( 3650)     pnt[pos]:=ch1; pos:=pos+1; read(@fno,ch1);
                 155 ( 3683)     end;
                 156 ( 3684)   while pos<xmax do begin
                 157 ( 3697)     pnt[pos]:=' '; pos:=pos+1;
                 158 ( 3713)   end;
                 159 ( 3718)   readline:=(ch1=eof) or (ch1=alteof);
                 160 ( 3735) end;
                 161 ( 3740) 
                 162 ( 3741) proc showline(pnt:cpnt; y: integer);
                 163 ( 3741) var lstart,pos: integer;
                 164 ( 3744) begin
                 165 ( 3744)   lstart:=y*xmax;
                 166 ( 3752)   if (pnt=nil) then
                 167 ( 3764)    for pos:=0 to xmax-1 do
                 168 ( 3777)     video[lstart+pos]:=' '
                 169 ( 3796)   else begin
                 170 ( 3822)     pos:=0;
                 171 ( 3824)     while (pos<xmax) and (pnt[pos]<>endmark) do begin
                 172 ( 3852)       video[lstart+pos]:=pnt[pos]; pos:=pos+1
                 173 ( 3882)     end;
                 174 ( 3889)     while pos<xmax do begin
                 175 ( 3902)       video[lstart+pos]:=' '; pos:=pos+1
                 176 ( 3924)     end
                 177 ( 3926)   end;
                 178 ( 3934) end;
                 179 ( 3934) 

----------------------------------------------------------------------

R65 Pascal program PEDIT           9/11/23     page 4

                 180 ( 3935) proc showtop;
                 181 ( 3935) begin
                 182 ( 3935)   intstr(line,stemp,3); putontop(stemp,5,true);
                 183 ( 3970)   intstr(nlines-1,stemp,3); putontop(stemp,12,true);
                 184 ( 4003) end;
                 185 ( 4003) 
                 186 ( 4004) proc showall;
                 187 ( 4004) var lstart,y,i,l,lstart: integer;
                 188 ( 4007) begin
                 189 ( 4007)   showtop;
                 190 ( 4013)   for y:=1 to scrlins-1 do begin
                 191 ( 4033)     l:=topline-1+y; lstart:=y*xmax;
                 192 ( 4055)     if l<nlines then
                 193 ( 4064)       showline(linepnt[l],y)
                 194 ( 4080)     else
                 195 ( 4090)       for i:=0 to xmax-1 do
                 196 ( 4103)         video[lstart+i]:=' ';
                 197 ( 4124)   end;
                 198 ( 4145) end;
                 199 ( 4159) 
                 200 ( 4160) proc updline(pnt: cpnt; lstart:integer);
                 201 ( 4160) var pos: integer;
                 202 ( 4163) begin
                 203 ( 4163)   for pos:=0 to xmax-1 do
                 204 ( 4175)     pnt[pos]:=video[lstart+pos];
                 205 ( 4201) end;
                 206 ( 4221) 
                 207 ( 4222) func lastpos(l:integer):integer;
                 208 ( 4222) { returns -1 if line empty }
                 209 ( 4222) var endpos:integer;
                 210 ( 4225)     s:cpnt;
                 211 ( 4225) begin
                 212 ( 4225)   endpos:=xmax-1;
                 213 ( 4231)   s:=linepnt[l];
                 214 ( 4240)   while (chr(ord(s[endpos]) and $7f)=' ')
                 215 ( 4264)     and (endpos>0) do endpos:=endpos-1;
                 216 ( 4282)   if (endpos=0) and (chr(ord(s[endpos]) and $7f)=' ')
                 217 ( 4313)   then endpos:=-1;
                 218 ( 4320)   lastpos:=endpos;
                 219 ( 4325) end;
                 220 ( 4333) 
                 221 ( 4334) proc chkline;
                 222 ( 4334) begin
                 223 ( 4334)   if line<1 then line:=1
                 224 ( 4349)   else if line>nlines-1 then line:=nlines-1;
                 225 ( 4379) end;
                 226 ( 4384) 
                 227 ( 4385) proc chktop(show: boolean);
                 228 ( 4385) var savetop,bottom:integer;
                 229 ( 4388) begin
                 230 ( 4388)   savetop:=topline; bottom:=topline+scrlins-1;
                 231 ( 4407)   if line<topline then topline:=line;
                 232 ( 4424)   { keep cursor above bottom line, if possible }
                 233 ( 4432)   if line>=bottom-1 then
                 234 ( 4442)     topline:=line-scrlins+3;
                 235 ( 4456)   if show and (savetop<>topline) then showall;
                 236 ( 4482) end;
                 237 ( 4482) 
                 238 ( 4483) proc delline;
                 239 ( 4483) var i:integer; savpnt:cpnt;

----------------------------------------------------------------------

R65 Pascal program PEDIT           9/11/23     page 5

                 240 ( 4486) begin
                 241 ( 4486)   chkline; savpnt:=linepnt[line];
                 242 ( 4496)   if line<mark then mark:=mark-1
                 243 ( 4520)   else if line<mark+nmark then nmark:=nmark-1;
                 244 ( 4553)   for i:=line to nlines-2 do
                 245 ( 4572)     linepnt[i]:=linepnt[i+1];
                 246 ( 4593)   release(savpnt); nlines:=nlines-1;
                 247 ( 4631)   chkline; chktop(false);
                 248 ( 4648)   line:=line-1; savecx:=1;
                 249 ( 4661) end;
                 250 ( 4665) 
                 251 ( 4666) proc join;
                 252 ( 4666) var p,p1,p2,pm:integer;
                 253 ( 4669)     s1,s2:cpnt;
                 254 ( 4669) begin
                 255 ( 4669)   p1:=lastpos(line-1); p2:=lastpos(line);
                 256 ( 4702)   s1:=linepnt[line-1]; s2:=linepnt[line];
                 257 ( 4725)   for p:=p1+1 to xmax-1 do s1[p]:=s2[p-p1-1];
                 258 ( 4778)   if p1+p2<xmax then delline
                 259 ( 4810)   else begin
                 260 ( 4820)     pm:=xmax-p1;
                 261 ( 4822)     for p:=0 to xmax-pm do s2[+p]:=s2[p+pm-1];
                 262 ( 4873)     for p:=xmax-pm+1 to xmax-1 do s2[p]:=' ';
                 263 ( 4927)     line:=line-1;
                 264 ( 4951)   end;
                 265 ( 4956)   savecx:=p1+2; chkline; chktop(false); showall;
                 266 ( 4983) end;
                 267 ( 4983) 
                 268 ( 4984) func edlin(pnt: cpnt): char;
                 269 ( 4984) const key    = @1;
                 270 ( 4987) var   ch1,lstch1,lstch2: char;
                 271 ( 4987)       exit: boolean;
                 272 ( 4987)       lstart: integer;
                 273 ( 4987) begin
                 274 ( 4987)   goto(savecx,column);
                 275 ( 5005)   if savecx=1 then write(cright,cleft)
                 276 ( 5020)   else write(cleft,cright); {to update cursor}
                 277 ( 5030)   exit:=false; lstart:=column*xmax;
                 278 ( 5044)   repeat
                 279 ( 5049)     read(@key,ch1);
                 280 ( 5057)     lstch1:=' '; lstch2:=' ';
                 281 ( 5066)     case ch1 of
                 282 ( 5070)       delchr,rubout: if (curpos=0) and (line>1)
                 283 ( 5100)              then begin
                 284 ( 5102)                updline(pnt,lstart);join;exit:=true;
                 285 ( 5125)              end else write(cleft,delchr);
                 286 ( 5138)       cleft: if curpos>0 then write(cleft)
                 287 ( 5159)              else if line>1 then begin
                 288 ( 5170)                updline(pnt,lstart);
                 289 ( 5187)                line:=line-1; curpos:=lastpos(line)+1;
                 290 ( 5212)                exit:=true;
                 291 ( 5219)              end;
                 292 ( 5223)       cright:if curpos<xmax-1 then begin
                 293 ( 5242)                write(cright);
                 294 ( 5248)              end else if line<nlines-1 then begin
                 295 ( 5263)                updline(pnt,lstart);
                 296 ( 5280)                line:=line+1; curpos:=0;
                 297 ( 5293)                exit:=true;
                 298 ( 5299)              end;
                 299 ( 5303)       cup,cdown,esc,cr,rup,rdown,

----------------------------------------------------------------------

R65 Pascal program PEDIT           9/11/23     page 6

                 300 ( 5345)       pgup,pgdown,hom,pgend: exit:=true
                 301 ( 5376)       else begin
                 302 ( 5385)              if (ch1>=' ') and (ch1<chr($7f))
                 303 ( 5398)              then begin
                 304 ( 5401)                lstch1:=video[lstart+xmax-1];
                 305 ( 5417)                lstch1:=chr(ord(lstch1) and $7f);
                 306 ( 5430)                lstch2:=video[lstart+xmax-2];
                 307 ( 5448)                lstch2:=chr(ord(lstch2) and $7f);
                 308 ( 5461)                if curpos>=xmax-1 then begin
                 309 ( 5475)                  if line>=nlines-1 then newline;
                 310 ( 5497)                  video[lstart+xmax-1]:=ch1;
                 311 ( 5507)                  curpos:=0;
                 312 ( 5520)                  lstch1:=cdown;
                 313 ( 5526)                end else begin
                 314 ( 5533)                  write(inschr); write(ch1);
                 315 ( 5541)                end;
                 316 ( 5541)                if (lstch1<>' ') or (lstch2<>' ')
                 317 ( 5554)                  then exit:=true;
                 318 ( 5561)              end;
                 319 ( 5565)            end
                 320 ( 5565)     end {case};
                 321 ( 5567)     until exit;
                 322 ( 5567)   updline(pnt,lstart);
                 323 ( 5588)   if (lstch1<>' ') or (lstch2<>' ') then edlin:=lstch1
                 324 ( 5606)   else edlin:=ch1;
                 325 ( 5617)   if (ch1<>delchr) and (ch1<>rubout) then
                 326 ( 5639)     savecx:=curpos+1;
                 327 ( 5648) end;
                 328 ( 5653) 
                 329 ( 5654) proc readinput;
                 330 ( 5654) var i,pend:integer;
                 331 ( 5657) begin
                 332 ( 5657)   cyclus:=0; drive:=1;
                 333 ( 5667)   goto(1,1); write(clrscr);
                 334 ( 5684)   agetstring(name,default,cyclus,drive);
                 335 ( 5724)   asetfile(name,cyclus,drive,'P');
                 336 ( 5746)   openr(fno);
                 337 ( 5752)   nlines := 1; line:=1; topline:=1;
                 338 ( 5766)   pend:=15; while name[pend]=' ' do pend:=pend-1;
                 339 ( 5796)   for i:=0 to pend do stemp[i]:=name[i];
                 340 ( 5831)   stemp[pend+1]:=endmark;
                 341 ( 5862)   stradd(':P.',stemp);
                 342 ( 5882)   hexstr(filcyc,stemp2);
                 343 ( 5896)   stradd(stemp2,stemp);
                 344 ( 5910)   while strlen(stemp)<17 do stradd(' ',stemp);
                 345 ( 5942)   putontop(stemp,17,true);
                 346 ( 5959)   putontop('Reading',36,true);
                 347 ( 5979)   repeat
                 348 ( 5979)     linepnt[nlines] := new;
                 349 ( 5989)     iseof := readline(fno, linepnt[nlines]);
                 350 ( 6013)     nlines := nlines+1;
                 351 ( 6023)     showtop;
                 352 ( 6032)     until iseof or (nlines >= maxlines-9);
                 353 ( 6047)   if nlines >= maxlines-9 then
                 354 ( 6060)       showerror('Too many lines');
                 355 ( 6088)   close(fno);
                 356 ( 6094)   clrmessage;
                 357 ( 6098)   showall;
                 358 ( 6102) end;
                 359 ( 6102) 

----------------------------------------------------------------------

R65 Pascal program PEDIT           9/11/23     page 7

                 360 ( 6103) proc writeoutput;
                 361 ( 6103) var pos,endpos:integer;s,saveline:cpnt;
                 362 ( 6106) begin
                 363 ( 6106)   cyclus:=0; drive:=1;
                 364 ( 6116)   goto(1,1); write(clrscr);
                 365 ( 6133)   asetfile(name,cyclus,drive,'P');
                 366 ( 6155)   openw(fno);
                 367 ( 6161)   putontop('Writing',36,true);
                 368 ( 6181)   for line:=1 to nlines-1 do begin
                 369 ( 6203)     showtop;
                 370 ( 6207)     endpos:=lastpos(line);
                 371 ( 6219)     s:=linepnt[line];
                 372 ( 6227)     for pos:=0 to endpos do
                 373 ( 6241)       write(@fno,chr(ord(s[pos]) and $7f));
                 374 ( 6275)     if (line<nlines-1) then write(@fno,cr);
                 375 ( 6313)   end;
                 376 ( 6313)   close(fno); line:=nlines-1;
                 377 ( 6339)   showall;
                 378 ( 6348) end;
                 379 ( 6348) 
                 380 ( 6349) proc clrmarks;
                 381 ( 6349) var x,savel:integer; s:cpnt;
                 382 ( 6352) begin
                 383 ( 6352)   savel:=line;
                 384 ( 6354)   for line:=1 to nlines-1 do begin
                 385 ( 6384)     s:=linepnt[line];
                 386 ( 6388)     for x:=0 to xmax-1 do
                 387 ( 6406)       s[x]:=chr(ord(s[x]) and $7f);
                 388 ( 6433)     showtop;
                 389 ( 6456)     end;
                 390 ( 6456)   line:=savel; mark:=0; nmark:=0;
                 391 ( 6486) end;
                 392 ( 6490) 
                 393 ( 6491) proc find(again:boolean);
                 394 ( 6491) var pos,x,i:integer;
                 395 ( 6494)     ch:char;
                 396 ( 6494)     found:boolean;
                 397 ( 6494)     s2:cpnt;
                 398 ( 6494) 
                 399 ( 6494)   proc checkrest;
                 400 ( 6494)   var failed:boolean;
                 401 ( 6497)       x1:integer;
                 402 ( 6497)       s1:cpnt;
                 403 ( 6497)   begin
                 404 ( 6497)     failed:=false; pos:=3; x1:=x+1;
                 405 ( 6517)     while (fs[pos]<>endmark) and (x1<xmax) do begin
                 406 ( 6546)       s1:=linepnt[line];
                 407 ( 6550)       if s1[x1] <> fs[pos] then failed:=true;
                 408 ( 6584)       pos:=pos+1; x1:=x1+1;
                 409 ( 6605)       end;
                 410 ( 6610)      if (failed=false) and (fs[pos]=endmark)
                 411 ( 6632)       then found:=true;
                 412 ( 6639)   end;
                 413 ( 6643) 
                 414 ( 6644) begin
                 415 ( 6644)   clrmessage;
                 416 ( 6650)   if not again then strcpy(stemp,fs);
                 417 ( 6672)   if fs[1]=endmark then begin
                 418 ( 6683)     {empty string -> delete all marks}
                 419 ( 6686)     putontop('Clearing marks',36,true);

----------------------------------------------------------------------

R65 Pascal program PEDIT           9/11/23     page 8

                 420 ( 6713)     clrmarks; showall;
                 421 ( 6721)     end
                 422 ( 6721)   else begin
                 423 ( 6724)     putontop('Searching',36,true);
                 424 ( 6746)     found:=false;
                 425 ( 6748)     repeat
                 426 ( 6752)       x:=0;
                 427 ( 6754)       repeat
                 428 ( 6758)         pos:=2;
                 429 ( 6760)         s2:=linepnt[line];
                 430 ( 6768)         if s2[x]=fs[pos] then checkrest;
                 431 ( 6804)         x:=x+1;
                 432 ( 6810)         until found or (x>=xmax);
                 433 ( 6826)       showtop; line:=line+1;
                 434 ( 6840)       until found or (line>=nlines);
                 435 ( 6858)     if found then begin
                 436 ( 6866)       line:=line-1; x:=x-1; i:=2;
                 437 ( 6893)       s2:=linepnt[line];
                 438 ( 6901)       while fs[i]<>endmark do begin
                 439 ( 6925)         s2[x+i-2]:=chr(ord(s2[x+i-2]) or $80);
                 440 ( 6958)          i:=i+1;
                 441 ( 6969)         end
                 442 ( 6974)       end
                 443 ( 6974)     else begin
                 444 ( 6980)       line:=nlines-1;
                 445 ( 6986)     end;
                 446 ( 6991)   end
                 447 ( 6991) end;
                 448 ( 6991) 
                 449 ( 6992) proc insertline;
                 450 ( 6992) var i:integer;
                 451 ( 6995)     s1,s2:cpnt;
                 452 ( 6995) begin
                 453 ( 6995)   if nlines<maxlines-1 then begin
                 454 ( 7008)     if line<mark then mark:=mark+1
                 455 ( 7027)     else if line<mark+nmark then nmark:=nmark+1;
                 456 ( 7060)     if line<nlines-1 then begin
                 457 ( 7077)       for i:=nlines-1 downto line+1 do
                 458 ( 7097)         linepnt[i+1]:=linepnt[i];
                 459 ( 7118)       end;
                 460 ( 7140)     linepnt[line+1]:=new;
                 461 ( 7153)     s1:=linepnt[line+1]; s2:=linepnt[line];
                 462 ( 7176)     for i:=0 to xmax-1 do s1[i]:=' ';
                 463 ( 7210)     for i:=curpos to xmax-1 do begin
                 464 ( 7249)       s1[i-curpos]:=s2[i]; s2[i]:=' ';
                 465 ( 7277)       end;
                 466 ( 7281)     line:=line+1; nlines:=nlines+1;
                 467 ( 7312)     savecx:=1; chkline; chktop(false); showall;
                 468 ( 7339)   end;
                 469 ( 7339) end;
                 470 ( 7339) 
                 471 ( 7340) proc paste;
                 472 ( 7340) var l,i:integer; s1,s2:cpnt;
                 473 ( 7343) begin
                 474 ( 7343)   if nlines+nmark<nlines-5 then begin
                 475 ( 7362)     for i:=nlines-1 downto line do
                 476 ( 7376)       linepnt[i+nmark]:=linepnt[i];
                 477 ( 7402)     nlines:=nlines+nmark;
                 478 ( 7428)     if mark>line then mark:=mark+nmark;
                 479 ( 7453)     for l:=mark to mark+nmark-1 do begin

----------------------------------------------------------------------

R65 Pascal program PEDIT           9/11/23     page 9

                 480 ( 7491)       linepnt[line]:=new;
                 481 ( 7501)       s1:=linepnt[line]; s2:=linepnt[l];
                 482 ( 7521)       for i:=0 to xmax-1 do s1[i]:=s2[i];
                 483 ( 7561)       line:=line+1;
                 484 ( 7587)     end;
                 485 ( 7592)     showall;
                 486 ( 7610)   end else showerror('Error: Out of memory');
                 487 ( 7642) end;
                 488 ( 7642) 
                 489 ( 7643) proc move;
                 490 ( 7643) var i,j,saveline:integer; savepnt:cpnt;
                 491 ( 7646) begin
                 492 ( 7646)   saveline:=line; { insert above}
                 493 ( 7656)   if line>=mark+nmark then begin
                 494 ( 7670)     mark:=mark+nmark-1;
                 495 ( 7684)     for j:=0 to nmark-1 do begin
                 496 ( 7711)       savepnt:=linepnt[mark];
                 497 ( 7715)       for i:=mark to line-1 do
                 498 ( 7737)         linepnt[i]:=linepnt[i+1];
                 499 ( 7758)       mark:=mark-1; line:=line-1;
                 500 ( 7797)       linepnt[line]:=savepnt;
                 501 ( 7806)     end;
                 502 ( 7814)   end else if line<mark then begin
                 503 ( 7840)     for j:=0 to nmark-1 do begin
                 504 ( 7865)       savepnt:=linepnt[mark];
                 505 ( 7869)       for i:=mark downto line+1 do
                 506 ( 7891)         linepnt[i]:=linepnt[i-1];
                 507 ( 7912)       linepnt[line]:=savepnt;
                 508 ( 7938)       mark:=mark+1; line:=line+1;
                 509 ( 7963)     end;
                 510 ( 7968)   end else showerror('Move inside move');
                 511 ( 8010)  mark:=saveline; line:=saveline; showall;
                 512 ( 8030) end;
                 513 ( 8030) 
                 514 ( 8031) func doesc: boolean;
                 515 ( 8031) var ch:char;
                 516 ( 8034)     i,n:integer;
                 517 ( 8034)     s,savl:cpnt;
                 518 ( 8034) begin
                 519 ( 8034)   clrmessage;
                 520 ( 8040)   doesc:=false; savecx:=1;
                 521 ( 8048)   getinput(n,stemp); ch:=stemp[0];
                 522 ( 8076)   if (strlen(stemp)>1) and (stemp[1]<>' ') then
                 523 ( 8108)     showerror('Expected f: xxx')
                 524 ( 8130)   else begin
                 525 ( 8139)     case ch of
                 526 ( 8139)       't': begin {top}
                 527 ( 8150)              line:=1; chktop(true);
                 528 ( 8164)            end;
                 529 ( 8164)       'b': begin {bottom}
                 530 ( 8174)              line:=nlines-1; chktop(true);
                 531 ( 8193)            end;
                 532 ( 8193)       'l': begin {line number}
                 533 ( 8203)              line:=n; chkline; chktop(true);
                 534 ( 8223)            end;
                 535 ( 8223)       'f','g': begin {find string}
                 536 ( 8240)              find(ch='g'); chkline; chktop(false);
                 537 ( 8265)              showall;
                 538 ( 8269)            end;
                 539 ( 8269)       'c': begin {mark lines for copy}

----------------------------------------------------------------------

R65 Pascal program PEDIT           9/11/23     page 10

                 540 ( 8279)              if n<1 then n:=1;
                 541 ( 8291)              if line+n>= nlines-1 then
                 542 ( 8310)                showerror('Too many lines')
                 543 ( 8332)              else begin
                 544 ( 8341)                mark:=line; nmark:=n;
                 545 ( 8349)                for line:=mark to mark+nmark-1 do
                 546 ( 8376)                begin
                 547 ( 8386)                  s:=linepnt[line];
                 548 ( 8390)                  for i:=0 to xmax-1 do
                 549 ( 8408)                    s[i]:= chr(ord(s[i]) or $80);
                 550 ( 8435)                end;
                 551 ( 8454)                line:=mark;
                 552 ( 8468)              end;
                 553 ( 8476)              showall;
                 554 ( 8480)            end;
                 555 ( 8480)       'p': begin {paste marked lines}
                 556 ( 8490)              if mark=0 then
                 557 ( 8496)                showerror('Nothing marked')
                 558 ( 8517)              else begin
                 559 ( 8526)                if nlines+nmark>=maxlines then
                 560 ( 8538)                  showerror('Too many lines')
                 561 ( 8559)                else paste;
                 562 ( 8572)              end;
                 563 ( 8572)            end;
                 564 ( 8572)       'm': begin {move marked lines }
                 565 ( 8582)              if mark=0 then
                 566 ( 8588)                showerror('Nothing marked')
                 567 ( 8609)              else move;
                 568 ( 8622)            end;
                 569 ( 8622)       'd': begin {delete n lines}
                 570 ( 8632)              if n<1 then n:=1;
                 571 ( 8644)              if line+n=maxlines-3 then
                 572 ( 8662)                n:=maxlines-3-line;
                 573 ( 8673)              for i:=1 to n do begin
                 574 ( 8701)                delline; line:=line+1;
                 575 ( 8711)              end;
                 576 ( 8716)              chkline; chktop(false); showall;
                 577 ( 8746)            end;
                 578 ( 8746)       'w': writeoutput; {write output}
                 579 ( 8763)       'q': begin {write output and quit}
                 580 ( 8770)              writeoutput; doesc:=true;
                 581 ( 8776)            end;
                 582 ( 8780)       'k': doesc:=true; {kill program}
                 583 ( 8799)       '?','h': showerror('tb/l/fg/cpm/d/wqk/?h');
                 584 ( 8842)       endmark: begin end
                 585 ( 8852)       else showerror('tb/l/fg/cpm/d/wqk/?h')
                 586 ( 8878)     end {case};
                 587 ( 8886)   end;
                 588 ( 8886)   clrmessage;
                 589 ( 8890) end;
                 590 ( 8890) 
                 591 ( 8891) proc newline;
                 592 ( 8891) begin
                 593 ( 8891)   linepnt[nlines]:=new; nlines:=nlines+1;
                 594 ( 8916) end;
                 595 ( 8921) 
                 596 ( 8922) proc insert(ch:char;l:integer);
                 597 ( 8922) { insert char at start of line (recursive) }
                 598 ( 8922) var i,y:integer;
                 599 ( 8925)     pnt:cpnt;

----------------------------------------------------------------------

R65 Pascal program PEDIT           9/11/23     page 11

                 600 ( 8925)     lstch1,lstch2:char;
                 601 ( 8925) begin
                 602 ( 8925)   if l>=nlines then newline;
                 603 ( 8943)   pnt:=linepnt[l];
                 604 ( 8947)   lstch1:=chr(ord(pnt[xmax-1]) and $7f);
                 605 ( 8969)   lstch2:=chr(ord(pnt[xmax-2]) and $7f);
                 606 ( 8988)   if (lstch1<>' ') or (lstch2<>' ')
                 607 ( 9006)     then insert(lstch1,l+1);
                 608 ( 9028)   for i:=xmax-2 downto 0 do pnt[i+1]:=pnt[i];
                 609 ( 9063)   pnt[0]:=ch; y:=l-topline+1;
                 610 ( 9104)   if (y>0) and (y<scrlins) then showline(pnt,y);
                 611 ( 9141) end;
                 612 ( 9141) 
                 613 ( 9142) func printable(ch:char):boolean;
                 614 ( 9142) begin
                 615 ( 9142)   printable:=((ord(ch)>=$20) and (ord(ch)<=$7e))
                 616 ( 9161)     and (ch<>rubout);
                 617 ( 9169) end;
                 618 ( 9174) 
                 619 ( 9175) begin {main}
                 620 ( 9175)   for i:=0 to maxlines-1 do linepnt[i]:=nil;
                 621 ( 9205)   stemp:=strnew; stemp2:=strnew; fs:=strnew; debug:=0;
                 622 ( 9255)   setnumlin($0f,$37); write(hom,clrscr);
                 623 ( 9275)   putontop('Line xxx of xxx',0,true);
                 624 ( 9303)   relpnt:=maxlines-1; mark:=0; nmark:=0; savecx:=1;
                 625 ( 9327)   clrmessage; readinput; fs[0]:=endmark;
                 626 ( 9343)   putontop('pedit version 2.0',36,true);
                 627 ( 9377)   topline:= 1; line:=1; showall; exit:=false;
                 628 ( 9395)   repeat
                 629 ( 9399)     showtop; chi := edlin(linepnt[line]);
                 630 ( 9419)     if printable(chi) then insert(chi,line+1)
                 631 ( 9448)     else case chi of
                 632 ( 9458)       cup,cdown: begin
                 633 ( 9476)              if chi=cup then line:=line-1
                 634 ( 9490)              else line:=line+1;
                 635 ( 9506)              chkline;
                 636 ( 9515)              if curpos>lastpos(line)+2 then
                 637 ( 9532)                savecx:=lastpos(line)+2;
                 638 ( 9551)              chktop(true);
                 639 ( 9564)            end;
                 640 ( 9564)       pgup: begin
                 641 ( 9574)              line:=line-15; chkline; chktop(true);
                 642 ( 9597)            end;
                 643 ( 9597)       pgdown: begin
                 644 ( 9607)              line:=line+15; chkline; chktop(true);
                 645 ( 9630)            end;
                 646 ( 9630)       rup: if (topline>1) then begin
                 647 ( 9647)              topline:=topline-1;chktop(false);showall;
                 648 ( 9673)            end;
                 649 ( 9673)       rdown: if (topline<nlines-15) then begin
                 650 ( 9695)              topline:=topline+1;chktop(false);showall;
                 651 ( 9721)            end;
                 652 ( 9721)       hom: begin
                 653 ( 9731)              line:=1; savecx:=1; chktop(true);
                 654 ( 9751)            end;
                 655 ( 9751)       pgend: begin
                 656 ( 9761)              line:=nlines-1; savecx:=1; chktop(true);
                 657 ( 9786)            end;
                 658 ( 9786)       cr:  insertline;
                 659 ( 9800)       esc: if doesc then exit:=true

----------------------------------------------------------------------

R65 Pascal program PEDIT           9/11/23     page 12

                 660 ( 9819)     end {case};
                 661 ( 9827)     until exit;
                 662 ( 9827)   setnumlin($29,$2f);
                 663 ( 9844)   writeln(hom, clrscr);
                 664 ( 9856)   dummy:=freedsk(fildrv,true);
                 665 ( 9869) end.
                 666 ( 9873) 

End compile

Code lenght:          9872
Compiler stack size:  120
Ident stack size:     182
Pascal errors:        0
