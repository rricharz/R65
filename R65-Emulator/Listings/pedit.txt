
R65 Pascal program PEDIT           7/11/23     page 1


                   1 (    4) program pedit;
                   2 (    4) 
                   3 (    4) { Pascal editor, original 1980 RR
                   4 (    4)   rewritten 2023 RR for R65 system }
                   5 (    4) 
                   6 (    4) uses syslib, arglib, strlib;
                   7 ( 2379) 
                   8 ( 2379) const maxlines = 420; xmax=56;
                   9 ( 2382)     scrlins = 16;
                  10 ( 2382)     eol    = chr($00); esc    = chr($00);
                  11 ( 2382)     pgdown = chr($02); pgup   = chr($08);
                  12 ( 2382)     pgend  = chr($10); clrscr = chr($11);
                  13 ( 2382)     clrlin = chr($17); cdown  = chr($18);
                  14 ( 2382)     cup    = chr($1a); cleft  = chr($03);
                  15 ( 2382)     inschr = chr($15); delchr = chr($19);
                  16 ( 2382)     rubout = chr($5f); cright = chr($16);
                  17 ( 2382)     mlenght   = 19; inpx=37;
                  18 ( 2382) 
                  19 ( 2382) mem curlin  = $ed: integer&;
                  20 ( 2382)     curpos  = $ee: integer&;
                  21 ( 2382)     filcyc  = $311: integer&;
                  22 ( 2382)     video   = $400: array[900] of char&;
                  23 ( 2382)     top     = $400: array[xmax] of integer&;
                  24 ( 2382) 
                  25 ( 2382) var line,nlines,topline,i: integer;
                  26 ( 2382)     name: array[15] of char;
                  27 ( 2382)     fno: file;
                  28 ( 2382)     chi : char;
                  29 ( 2382)     cyclus,drive,mark,nmark,savecx: integer;
                  30 ( 2382)     default, iseof, exit: boolean;
                  31 ( 2382)     fs: cpnt;
                  32 ( 2382)     linepnt: array[maxlines] of cpnt;
                  33 ( 2382)     relpnt:  integer;
                  34 ( 2382)     stemp,stemp2: cpnt;
                  35 ( 2382) 
                  36 ( 2382) proc putontop(s:cpnt;pos:integer;inv:boolean);
                  37 ( 2382) var i:integer;
                  38 ( 2385) begin
                  39 ( 2385)   i:=0; { faster version: if not in loop }
                  40 ( 2393)   if inv then while s[i]<>chr(0) do begin
                  41 ( 2417)     top[i+pos]:=ord(s[i]) or 128; i:=i+1;
                  42 ( 2452)   end else while s[i]<>chr(0) do begin
                  43 ( 2480)     top[i+pos]:=ord(s[i]); i:=i+1;
                  44 ( 2512)   end;
                  45 ( 2517) end;
                  46 ( 2520) 
                  47 ( 2521) func new:cpnt;
                  48 ( 2521) begin
                  49 ( 2521)   if relpnt<maxlines-1 then begin
                  50 ( 2537)     relpnt:=relpnt+1; new:=linepnt[relpnt];
                  51 ( 2555)   end else  {assign new memory}
                  52 ( 2566)     new:=strnew;
                  53 ( 2572) end;
                  54 ( 2576) 
                  55 ( 2577) proc release(p:cpnt);
                  56 ( 2577) begin
                  57 ( 2577)   linepnt[relpnt]:=p; relpnt:=relpnt-1;
                  58 ( 2600) end;
                  59 ( 2605) 

----------------------------------------------------------------------

R65 Pascal program PEDIT           7/11/23     page 2

                  60 ( 2606) proc setnumlin(l,c:integer);
                  61 ( 2606) mem numlin=$1789: integer&;
                  62 ( 2609)     numchr=$178a: integer&;
                  63 ( 2609) begin
                  64 ( 2609)   numlin:=l; numchr:=c;
                  65 ( 2620) end;
                  66 ( 2629) 
                  67 ( 2630) func column:integer;
                  68 ( 2630) begin
                  69 ( 2630)   column:=line-topline+1;
                  70 ( 2646) end;
                  71 ( 2651) 
                  72 ( 2652) proc goto(xpos, ypos: integer);
                  73 ( 2652) begin
                  74 ( 2652)   curlin:=ypos; { top on line 2 }
                  75 ( 2665)   if curlin>15 then curlin:=15;
                  76 ( 2676)   curpos:=xpos-1;
                  77 ( 2686) end;
                  78 ( 2691) 
                  79 ( 2692) proc clrmessage;
                  80 ( 2692) var i:integer;
                  81 ( 2695) begin
                  82 ( 2695)   for i:=inpx-1 to xmax-1 do top[i]:=128;
                  83 ( 2726) end;
                  84 ( 2747) 
                  85 ( 2748) proc getinput(var n:integer; s:cpnt);
                  86 ( 2748) var i,j,stop:integer; ch: char;
                  87 ( 2751) begin
                  88 ( 2751)   goto(inpx,0); write(chr(ord(':') or 128));
                  89 ( 2770)   read(@key,ch); i:=0;
                  90 ( 2781)   while (ch<>chr(13)) do begin
                  91 ( 2796)     if (ch=rubout) then begin
                  92 ( 2803)       if i>0 then i:=i-1; goto(i+inpx+1,0);
                  93 ( 2845)       write(chr(ord(' ') or 128),cleft);
                  94 ( 2855)     end else if (ch>=' ') and (ch<=chr($7d)) and
                  95 ( 2873)       (inpx+i<xmax-1) then begin
                  96 ( 2888)       goto(i+inpx+1,0);
                  97 ( 2909)       write(chr(ord(ch) or 128)); i:=i+1;
                  98 ( 2924)     end;
                  99 ( 2929)     read(@key,ch);
                 100 ( 2937)   end;
                 101 ( 2938)   stop:=i+inpx;
                 102 ( 2947)   i:=inpx; n:=0;
                 103 ( 2960)   while ((top[i] and 127)>=ord('0')) and
                 104 ( 2979)     ((top[i] and 127)<=ord('9')) and
                 105 ( 2994)     (i<stop) do begin
                 106 ( 3008)     n:=10*n+(top[i] and 127)-ord('0');
                 107 ( 3030)     i:=i+1;
                 108 ( 3041)   end;
                 109 ( 3046)   j:=0;
                 110 ( 3051)   while i<stop do begin
                 111 ( 3067)     s[j]:=chr(top[i] and 127); i:=i+1; j:=j+1;
                 112 ( 3105)   end;
                 113 ( 3110)   s[j]:=chr(0);
                 114 ( 3119) end;
                 115 ( 3124) 
                 116 ( 3125) func readline(input: file; pnt: cpnt): boolean;
                 117 ( 3125) const alteof=chr(127);
                 118 ( 3128) var ch1: char;
                 119 ( 3128)     pos: integer;

----------------------------------------------------------------------

R65 Pascal program PEDIT           7/11/23     page 3

                 120 ( 3128) begin
                 121 ( 3128)   pos := 0; read(@fno,ch1);
                 122 ( 3146)   while (ch1>=' ') and (ch1<>alteof) and
                 123 ( 3161)       (pos<xmax-1) do begin
                 124 ( 3176)     pnt[pos]:=ch1; pos:=pos+1; read(@fno,ch1);
                 125 ( 3209)     end;
                 126 ( 3210)   while pos<xmax do begin
                 127 ( 3223)     pnt[pos]:=' '; pos:=pos+1;
                 128 ( 3239)   end;
                 129 ( 3244)   readline:=(ch1=eof) or (ch1=alteof);
                 130 ( 3261) end;
                 131 ( 3266) 
                 132 ( 3267) proc showline(pnt:cpnt; y: integer);
                 133 ( 3267) var lstart,pos: integer;
                 134 ( 3270) begin
                 135 ( 3270)   lstart:=y*xmax;
                 136 ( 3278)   for pos:=0 to xmax-1 do
                 137 ( 3293)     video[lstart+pos]:=pnt[pos];
                 138 ( 3320) end;
                 139 ( 3343) 
                 140 ( 3344) proc showtop;
                 141 ( 3344) begin
                 142 ( 3344)   intstr(line,stemp,3); putontop(stemp,5,true);
                 143 ( 3379)   intstr(nlines-1,stemp,3); putontop(stemp,12,true);
                 144 ( 3412) end;
                 145 ( 3412) 
                 146 ( 3413) proc showerror(s:cpnt);
                 147 ( 3413) var i: integer;
                 148 ( 3416)     ch: char;
                 149 ( 3416) begin
                 150 ( 3416)   clrmessage;
                 151 ( 3422)   putontop(s,36,true);
                 152 ( 3436)   read(@key,ch);
                 153 ( 3444)   clrmessage;
                 154 ( 3449) end;
                 155 ( 3449) 
                 156 ( 3450) proc showall;
                 157 ( 3450) var lstart,y,i,l,lstart: integer;
                 158 ( 3453) begin
                 159 ( 3453)   showtop;
                 160 ( 3459)   for y:=1 to scrlins-1 do begin
                 161 ( 3479)     l:=topline-1+y; lstart:=y*xmax;
                 162 ( 3501)     if l<nlines then
                 163 ( 3510)       showline(linepnt[l],y)
                 164 ( 3526)     else
                 165 ( 3536)       for i:=0 to xmax-1 do
                 166 ( 3549)         video[lstart+i]:=' ';
                 167 ( 3570)   end;
                 168 ( 3591) end;
                 169 ( 3605) 
                 170 ( 3606) proc updline(pnt: cpnt; lstart:integer);
                 171 ( 3606) var pos: integer;
                 172 ( 3609) begin
                 173 ( 3609)   for pos:=0 to xmax-1 do
                 174 ( 3621)     pnt[pos]:=video[lstart+pos];
                 175 ( 3647) end;
                 176 ( 3667) 
                 177 ( 3668) func lastpos(l:integer):integer;
                 178 ( 3668) { returns -1 if line empty }
                 179 ( 3668) var endpos:integer;

----------------------------------------------------------------------

R65 Pascal program PEDIT           7/11/23     page 4

                 180 ( 3671)     s:cpnt;
                 181 ( 3671) begin
                 182 ( 3671)   endpos:=xmax-1;
                 183 ( 3677)   s:=linepnt[l]
                 184 ( 3682)   while (s[endpos]=chr(ord(' ') and $7f))
                 185 ( 3709)     and (endpos>=0) do endpos:=endpos-1;
                 186 ( 3728)   lastpos:=endpos;
                 187 ( 3736) end;
                 188 ( 3744) 
                 189 ( 3745) proc chkline;
                 190 ( 3745) begin
                 191 ( 3745)   if line<1 then line:=1
                 192 ( 3760)   else if line>nlines-1 then line:=nlines-1;
                 193 ( 3790) end;
                 194 ( 3795) 
                 195 ( 3796) proc chktop(show: boolean);
                 196 ( 3796) var savetop,bottom:integer;
                 197 ( 3799) begin
                 198 ( 3799)   savetop:=topline; bottom:=topline+scrlins-1;
                 199 ( 3818)   if line<topline then topline:=line;
                 200 ( 3835)   if line>=bottom then
                 201 ( 3847)     topline:=line-scrlins+2;
                 202 ( 3864)   if show and (savetop<>topline) then showall;
                 203 ( 3890) end;
                 204 ( 3890) 
                 205 ( 3891) proc delline;
                 206 ( 3891) var i:integer; savpnt:cpnt;
                 207 ( 3894) begin
                 208 ( 3894)   chkline; savpnt:=linepnt[line];
                 209 ( 3904)   if line<mark then mark:=mark-1
                 210 ( 3928)   else if line<mark+nmark then nmark:=nmark-1;
                 211 ( 3961)   for i:=line to nlines-2 do
                 212 ( 3980)     linepnt[i]:=linepnt[i+1];
                 213 ( 4001)   release(savpnt); nlines:=nlines-1;
                 214 ( 4039)   chkline; chktop(false);
                 215 ( 4056)   line:=line-1; savecx:=1;
                 216 ( 4069) end;
                 217 ( 4073) 
                 218 ( 4074) proc join;
                 219 ( 4074) var p,p1,p2,pm:integer;
                 220 ( 4077)     s1,s2:cpnt;
                 221 ( 4077) begin
                 222 ( 4077)   p1:=lastpos(line-1); p2:=lastpos(line);
                 223 ( 4110)   s1:=linepnt[line-1]; s2:=linepnt[line];
                 224 ( 4133)   for p:=p1+1 to xmax-1 do s1[p]:=s2[p-p1-1];
                 225 ( 4186)   if p1+p2<xmax then delline
                 226 ( 4218)   else begin
                 227 ( 4228)     pm:=xmax-p1;
                 228 ( 4230)     for p:=0 to xmax-pm do s2[+p]:=s2[p+pm-1];
                 229 ( 4281)     for p:=xmax-pm+1 to xmax-1 do s2[p]:=' ';
                 230 ( 4335)     line:=line-1;
                 231 ( 4359)   end;
                 232 ( 4364)   savecx:=p1+2; chkline; chktop(false); showall;
                 233 ( 4391) end;
                 234 ( 4391) 
                 235 ( 4392) func edlin(pnt: cpnt): char;
                 236 ( 4392) const key    = @1;
                 237 ( 4395) var   ch1: char;
                 238 ( 4395)       exit: boolean;
                 239 ( 4395)       lstart: integer;

----------------------------------------------------------------------

R65 Pascal program PEDIT           7/11/23     page 5

                 240 ( 4395) begin
                 241 ( 4395)   goto(savecx,column);
                 242 ( 4413)   if savecx=1 then write(cright,cleft)
                 243 ( 4428)   else write(cleft,cright); {to update cursor}
                 244 ( 4438)   exit:=false; lstart:=column*xmax;
                 245 ( 4452)   repeat
                 246 ( 4457)     read(@key,ch1);
                 247 ( 4465)     case ch1 of
                 248 ( 4466)       delchr,rubout: if (curpos=0) and (line>1)
                 249 ( 4496)              then begin
                 250 ( 4498)                updline(pnt,lstart) ;join; exit:=true;
                 251 ( 4521)                end
                 252 ( 4525)              else write(cleft,delchr);
                 253 ( 4534)       cleft: if curpos>0 then write(cleft)
                 254 ( 4555)              else if line>1 then begin
                 255 ( 4566)                updline(pnt,lstart);
                 256 ( 4583)                line:=line-1; curpos:=lastpos(line)+1;
                 257 ( 4608)                exit:=true;
                 258 ( 4615)              end;
                 259 ( 4619)       cright:if (curpos<lastpos(line)+1) and
                 260 ( 4648)                (curpos<xmax-1) then begin
                 261 ( 4658)                write(cright);
                 262 ( 4664)              end else if line<nlines-1 then begin
                 263 ( 4679)                updline(pnt,lstart);
                 264 ( 4696)                line:=line+1; curpos:=0;
                 265 ( 4709)                exit:=true;
                 266 ( 4715)              end;
                 267 ( 4719)       cup,cdown,esc,cr,
                 268 ( 4747)       pgup,pgdown,hom,pgend: exit:=true
                 269 ( 4778)       else begin
                 270 ( 4787)              if (ch1>=' ') and (ch1<chr($7f))
                 271 ( 4800)              then begin
                 272 ( 4803)                write(inschr); write(ch1);
                 273 ( 4814)                if curpos<1 then begin
                 274 ( 4820)                  updline(pnt,lstart);
                 275 ( 4837)                  line:=line+1;
                 276 ( 4843)                  if line>=nlines then begin
                 277 ( 4857)                    linepnt[line]:=strnew;
                 278 ( 4870)                    nlines:=nlines+1;
                 279 ( 4880)                  end;
                 280 ( 4885)                  curpos:=0; exit:=true;
                 281 ( 4893)                end;
                 282 ( 4897)              end;
                 283 ( 4897)            end
                 284 ( 4897)     end {case};
                 285 ( 4899)     until exit;
                 286 ( 4899)   updline(pnt,lstart);
                 287 ( 4920)   edlin := ch1;
                 288 ( 4920)   if (ch1<>delchr) and (ch1<>rubout) then
                 289 ( 4942)     savecx:=curpos+1;
                 290 ( 4951) end;
                 291 ( 4956) 
                 292 ( 4957) proc readinput;
                 293 ( 4957) var i,pend:integer;
                 294 ( 4960) begin
                 295 ( 4960)   cyclus:=0; drive:=1;
                 296 ( 4970)   goto(1,1); write(clrscr);
                 297 ( 4987)   agetstring(name,default,cyclus,drive);
                 298 ( 5027)   asetfile(name,cyclus,drive,'P');
                 299 ( 5049)   openr(fno);

----------------------------------------------------------------------

R65 Pascal program PEDIT           7/11/23     page 6

                 300 ( 5055)   nlines := 1; line:=1; topline:=1;
                 301 ( 5069)   pend:=15; while name[pend]=' ' do pend:=pend-1;
                 302 ( 5099)   for i:=0 to pend do stemp[i]:=name[i];
                 303 ( 5134)   stemp[pend+1]:=chr(0);
                 304 ( 5165)   stradd(':P.',stemp);
                 305 ( 5186)   hexstr(filcyc,stemp2);
                 306 ( 5200)   stradd(stemp2,stemp);
                 307 ( 5214)   while strlen(stemp)<17 do stradd(' ',stemp);
                 308 ( 5246)   putontop(stemp,17,true);
                 309 ( 5263)   putontop('Reading',36,true);
                 310 ( 5283)   repeat
                 311 ( 5283)     linepnt[nlines] := strnew;
                 312 ( 5293)     iseof := readline(fno, linepnt[nlines]);
                 313 ( 5317)     nlines := nlines+1;
                 314 ( 5327)     showtop;
                 315 ( 5336)     until iseof or (nlines >= maxlines-1);
                 316 ( 5351)   if nlines >= maxlines-1 then
                 317 ( 5364)       showerror('Too many lines');
                 318 ( 5392)   close(fno);
                 319 ( 5398)   clrmessage;
                 320 ( 5402)   showall;
                 321 ( 5406) end;
                 322 ( 5406) 
                 323 ( 5407) proc writeoutput;
                 324 ( 5407) var pos,endpos:integer;s,saveline:cpnt;
                 325 ( 5410) begin
                 326 ( 5410)   cyclus:=0; drive:=1;
                 327 ( 5420)   goto(1,1); write(clrscr);
                 328 ( 5437)   asetfile(name,cyclus,drive,'P');
                 329 ( 5459)   openw(fno);
                 330 ( 5465)   putontop('Writing',36,true);
                 331 ( 5485)   for line:=1 to nlines-1 do begin
                 332 ( 5507)     showtop;
                 333 ( 5511)     endpos:=lastpos(line);
                 334 ( 5523)     s:=linepnt[line];
                 335 ( 5531)     for pos:=0 to endpos do
                 336 ( 5545)       write(@fno,chr(ord(s[pos]) and $7f));
                 337 ( 5579)     if (line<nlines-1) or (endpos<>0) then
                 338 ( 5612)       write(@fno,cr);
                 339 ( 5625)   end;
                 340 ( 5625)   close(fno); line:=nlines-1;
                 341 ( 5651)   showall;
                 342 ( 5660) end;
                 343 ( 5660) 
                 344 ( 5661) proc clrmarks;
                 345 ( 5661) var x,savel:integer; s:cpnt;
                 346 ( 5664) begin
                 347 ( 5664)   savel:=line;
                 348 ( 5666)   for line:=1 to nlines-1 do begin
                 349 ( 5696)     s:=linepnt[line];
                 350 ( 5700)     for x:=0 to xmax-1 do
                 351 ( 5718)       s[x]:=chr(ord(s[x]) and $7f);
                 352 ( 5745)     showtop;
                 353 ( 5768)     end;
                 354 ( 5768)   line:=savel; mark:=0; nmark:=0;
                 355 ( 5798) end;
                 356 ( 5802) 
                 357 ( 5803) proc find(again:boolean);
                 358 ( 5803) var pos,x,i:integer;
                 359 ( 5806)     ch:char;

----------------------------------------------------------------------

R65 Pascal program PEDIT           7/11/23     page 7

                 360 ( 5806)     found:boolean;
                 361 ( 5806)     s2:cpnt;
                 362 ( 5806) 
                 363 ( 5806)   proc checkrest;
                 364 ( 5806)   var failed:boolean;
                 365 ( 5809)       x1:integer;
                 366 ( 5809)       s1:cpnt;
                 367 ( 5809)   begin
                 368 ( 5809)     failed:=false; pos:=3; x1:=x+1;
                 369 ( 5829)     while (fs[pos]<>chr(0)) and (x1<xmax) do begin
                 370 ( 5859)       s1:=linepnt[line];
                 371 ( 5863)       if s1[x1] <> fs[pos] then failed:=true;
                 372 ( 5897)       pos:=pos+1; x1:=x1+1;
                 373 ( 5918)       end;
                 374 ( 5923)      if (failed=false) and (fs[pos]=chr(0))
                 375 ( 5945)       then found:=true;
                 376 ( 5953)   end;
                 377 ( 5957) 
                 378 ( 5958) begin
                 379 ( 5958)   if not again then strcpy(stemp,fs);
                 380 ( 5982)   if fs[1]=chr(0) then begin
                 381 ( 5994)     {empty string -> delete all marks}
                 382 ( 5997)     putontop('Clearing marks',36,true);
                 383 ( 6024)     clrmarks; showall;
                 384 ( 6032)     end
                 385 ( 6032)   else begin
                 386 ( 6035)     putontop('Searching',36,true);
                 387 ( 6057)     found:=false;
                 388 ( 6059)     repeat
                 389 ( 6063)       x:=0;
                 390 ( 6065)       repeat
                 391 ( 6069)         pos:=2;
                 392 ( 6071)         s2:=linepnt[line];
                 393 ( 6079)         if s2[x]=fs[pos] then checkrest;
                 394 ( 6115)         x:=x+1;
                 395 ( 6121)         until found or (x>=xmax);
                 396 ( 6137)       showtop; line:=line+1;
                 397 ( 6151)       until found or (line>=nlines);
                 398 ( 6169)     if found then begin
                 399 ( 6177)       line:=line-1; x:=x-1; i:=2;
                 400 ( 6204)       s2:=linepnt[line];
                 401 ( 6212)       while fs[i]<>chr(0) do begin
                 402 ( 6237)         s2[x+i-2]:=chr(ord(s2[x+i-2]) or $80);
                 403 ( 6270)          i:=i+1;
                 404 ( 6281)         end
                 405 ( 6286)       end
                 406 ( 6286)     else begin
                 407 ( 6292)       line:=nlines-1;
                 408 ( 6298)     end;
                 409 ( 6303)   end
                 410 ( 6303) end;
                 411 ( 6303) 
                 412 ( 6304) proc insertline;
                 413 ( 6304) var i:integer;
                 414 ( 6307)     s1,s2:cpnt;
                 415 ( 6307) begin
                 416 ( 6307)   if nlines<maxlines-1 then begin
                 417 ( 6320)     if line<mark then mark:=mark+1
                 418 ( 6339)     else if line<mark+nmark then nmark:=nmark+1;
                 419 ( 6372)     if line<nlines-1 then begin

----------------------------------------------------------------------

R65 Pascal program PEDIT           7/11/23     page 8

                 420 ( 6389)       for i:=nlines-1 downto line+1 do
                 421 ( 6409)         linepnt[i+1]:=linepnt[i];
                 422 ( 6430)       end;
                 423 ( 6452)     linepnt[line+1]:=strnew;
                 424 ( 6465)     s1:=linepnt[line+1]; s2:=linepnt[line];
                 425 ( 6488)     for i:=0 to xmax-1 do s1[i]:=' ';
                 426 ( 6522)     for i:=curpos to xmax-1 do begin
                 427 ( 6561)       s1[i-curpos]:=s2[i]; s2[i]:=' ';
                 428 ( 6589)       end;
                 429 ( 6593)     line:=line+1; nlines:=nlines+1;
                 430 ( 6624)     savecx:=1; chkline; chktop(false); showall;
                 431 ( 6651)   end;
                 432 ( 6651) end;
                 433 ( 6651) 
                 434 ( 6652) proc paste;
                 435 ( 6652) var l,i:integer; s1,s2:cpnt;
                 436 ( 6655) begin
                 437 ( 6655)   for i:=nlines-1 downto line do
                 438 ( 6668)     linepnt[i+nmark]:=linepnt[i];
                 439 ( 6694)   nlines:=nlines+nmark;
                 440 ( 6720)   if mark>line then mark:=mark+nmark;
                 441 ( 6745)   for l:=mark to mark+nmark-1 do begin
                 442 ( 6783)     linepnt[line]:=strnew;
                 443 ( 6793)     s1:=linepnt[line]; s2:=linepnt[l];
                 444 ( 6813)     for i:=0 to xmax-1 do s1[i]:=s2[i];
                 445 ( 6853)     line:=line+1;
                 446 ( 6879)   end;
                 447 ( 6884)   showall;
                 448 ( 6902) end;
                 449 ( 6902) 
                 450 ( 6903) proc move;
                 451 ( 6903) var i,j,saveline:integer; savepnt:cpnt;
                 452 ( 6906) begin
                 453 ( 6906)   saveline:=line; { insert above}
                 454 ( 6916)   if line>=mark+nmark then begin
                 455 ( 6930)     mark:=mark+nmark-1;
                 456 ( 6944)     for j:=0 to nmark-1 do begin
                 457 ( 6971)       savepnt:=linepnt[mark];
                 458 ( 6975)       for i:=mark to line-1 do
                 459 ( 6997)         linepnt[i]:=linepnt[i+1];
                 460 ( 7018)       mark:=mark-1; line:=line-1;
                 461 ( 7057)       linepnt[line]:=savepnt;
                 462 ( 7066)     end;
                 463 ( 7074)   end else if line<mark then begin
                 464 ( 7100)     for j:=0 to nmark-1 do begin
                 465 ( 7125)       savepnt:=linepnt[mark];
                 466 ( 7129)       for i:=mark downto line+1 do
                 467 ( 7151)         linepnt[i]:=linepnt[i-1];
                 468 ( 7172)       linepnt[line]:=savepnt;
                 469 ( 7198)       mark:=mark+1; line:=line+1;
                 470 ( 7223)     end;
                 471 ( 7228)   end else showerror('Move inside move');
                 472 ( 7270)  mark:=saveline; line:=saveline; showall;
                 473 ( 7290) end;
                 474 ( 7290) 
                 475 ( 7291) func doesc: boolean;
                 476 ( 7291) var ch:char;
                 477 ( 7294)     i,n:integer;
                 478 ( 7294)     s,savl:cpnt;
                 479 ( 7294) begin

----------------------------------------------------------------------

R65 Pascal program PEDIT           7/11/23     page 9

                 480 ( 7294)   doesc:=false; savecx:=1;
                 481 ( 7304)   getinput(n,stemp); ch:=stemp[0];
                 482 ( 7332)   if (strlen(stemp)>1) and (stemp[1]<>' ') then
                 483 ( 7364)     showerror('Expected f: xxx')
                 484 ( 7386)   else begin
                 485 ( 7395)     case ch of
                 486 ( 7395)       't': begin {top}
                 487 ( 7406)              line:=1; chktop(true);
                 488 ( 7420)            end;
                 489 ( 7420)       'b': begin {bottom}
                 490 ( 7430)              line:=nlines-1; chktop(true);
                 491 ( 7449)            end;
                 492 ( 7449)       'l': begin {line number}
                 493 ( 7459)              line:=n; chkline; chktop(true);
                 494 ( 7479)            end;
                 495 ( 7479)       'f','g': begin {find string}
                 496 ( 7496)              find(ch='g'); chkline; chktop(false);
                 497 ( 7521)              showall;
                 498 ( 7525)            end;
                 499 ( 7525)       'c': begin {mark lines for copy}
                 500 ( 7535)              if n<1 then n:=1;
                 501 ( 7547)              if line+n>= nlines-1 then
                 502 ( 7566)                showerror('Too many lines')
                 503 ( 7588)              else begin
                 504 ( 7597)                mark:=line; nmark:=n;
                 505 ( 7605)                for line:=mark to mark+nmark-1 do
                 506 ( 7632)                begin
                 507 ( 7642)                  s:=linepnt[line];
                 508 ( 7646)                  for i:=0 to xmax-1 do
                 509 ( 7664)                    s[i]:= chr(ord(s[i]) or $80);
                 510 ( 7691)                end;
                 511 ( 7710)                line:=mark;
                 512 ( 7724)              end;
                 513 ( 7732)              showall;
                 514 ( 7736)            end;
                 515 ( 7736)       'p': begin {paste marked lines}
                 516 ( 7746)              if mark=0 then
                 517 ( 7752)                showerror('Nothing marked')
                 518 ( 7773)              else begin
                 519 ( 7782)                if nlines+nmark>=maxlines then
                 520 ( 7794)                  showerror('Too many lines')
                 521 ( 7815)                else paste;
                 522 ( 7828)              end;
                 523 ( 7828)            end;
                 524 ( 7828)       'm': begin {move marked lines }
                 525 ( 7838)              if mark=0 then
                 526 ( 7844)                showerror('Nothing marked')
                 527 ( 7865)              else move;
                 528 ( 7878)            end;
                 529 ( 7878)       'd': begin {delete n lines}
                 530 ( 7888)              if n<1 then n:=1;
                 531 ( 7900)              if line+n=maxlines-3 then
                 532 ( 7918)                n:=maxlines-3-line;
                 533 ( 7929)              for i:=1 to n do begin
                 534 ( 7957)                delline; line:=line+1;
                 535 ( 7967)              end;
                 536 ( 7972)              chkline; chktop(false); showall;
                 537 ( 8002)            end;
                 538 ( 8002)       'w': writeoutput; {write output}
                 539 ( 8019)       'q': begin {write output and quit}

----------------------------------------------------------------------

R65 Pascal program PEDIT           7/11/23     page 10

                 540 ( 8026)              writeoutput; doesc:=true;
                 541 ( 8032)            end;
                 542 ( 8036)       'k': doesc:=true; {kill program}
                 543 ( 8055)       '?','h': showerror('tb/l/fg/cpm/d/wqk/?h')
                 544 ( 8092)       else showerror('Unknown escape')
                 545 ( 8118)     end {case};
                 546 ( 8126)   end;
                 547 ( 8126)   clrmessage;
                 548 ( 8130) end;
                 549 ( 8130) 
                 550 ( 8131) begin {main}
                 551 ( 8131)   stemp:=strnew; stemp2:=strnew; fs:=strnew;
                 552 ( 8160)   setnumlin($0f,$37);
                 553 ( 8174)   write(hom,clrscr);
                 554 ( 8180)   putontop('Line xxx of xxx',0,true);
                 555 ( 8208)   relpnt:=maxlines-1;
                 556 ( 8213)   mark:=0; nmark:=0; savecx:=1;
                 557 ( 8232)   clrmessage;
                 558 ( 8240)   readinput; fs[0]:=chr(0);
                 559 ( 8248)   topline:= 1; line:=1; showall; exit:=false;
                 560 ( 8271)   repeat
                 561 ( 8275)     showtop; chi := edlin(linepnt[line]);
                 562 ( 8295)     case chi of
                 563 ( 8299)       cup,cdown: begin
                 564 ( 8317)              if chi=cup then line:=line-1
                 565 ( 8331)              else line:=line+1;
                 566 ( 8347)              chkline;
                 567 ( 8356)              if curpos>lastpos(line)+2 then
                 568 ( 8373)                savecx:=lastpos(line)+2;
                 569 ( 8392)              chktop(true);
                 570 ( 8405)            end;
                 571 ( 8405)       pgup: begin
                 572 ( 8415)              line:=line-15; chkline; chktop(true);
                 573 ( 8438)            end;
                 574 ( 8438)       pgdown: begin
                 575 ( 8448)              line:=line+15; chkline; chktop(true);
                 576 ( 8471)            end;
                 577 ( 8471)       hom: begin
                 578 ( 8481)              line:=1; savecx:=1; chktop(true);
                 579 ( 8501)            end;
                 580 ( 8501)       pgend: begin
                 581 ( 8511)              line:=nlines-1; savecx:=1; chktop(true);
                 582 ( 8536)            end;
                 583 ( 8536)       cr:  insertline;
                 584 ( 8550)       esc: if doesc then exit:=true
                 585 ( 8569)     end {case};
                 586 ( 8577)     until exit;
                 587 ( 8577)   setnumlin($29,$2f);
                 588 ( 8594)   writeln(hom, clrscr, 'closing...');
                 589 ( 8617) end.
                 590 ( 8617) 

End compile

Code lenght:          8616
Compiler stack size:  115
Ident stack size:     170
Pascal errors:        0
