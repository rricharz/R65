
R65 COMPILE 4.2: program PEDIT            7/2/24 page 1


   1 (    4) program pedit;
   2 (    4) 
   3 (    4) { Pascal editor, original 1980 RR
   4 (    4)   rewritten 2023 RR for R65 system }
   5 (    4) 
   6 (    4) uses syslib, arglib, strlib, disklib;
   7 ( 2446) 
   8 ( 2446) const title='R65 PEDIT 2.1'; {max 20 chars}
   9 ( 2463) 
  10 ( 2463)     maxlines= 360;      xmax   = 56;
  11 ( 2463)     scrlins = 16;       mlenght= 19;
  12 ( 2463)     inpx    = 37;       marked = 58;
  13 ( 2463)     eol     = chr($00); esc    = chr($00);
  14 ( 2463)     rdown   = chr($02); rup    = chr($08);
  15 ( 2463)     pgdown  = chr($14); pgup   = chr($12);
  16 ( 2463)     cdown   = chr($18); cup    = chr($1a);
  17 ( 2463)     pgend   = chr($10); clrscr = chr($11);
  18 ( 2463)     clrlin  = chr($17); cleft  = chr($03);
  19 ( 2463)     inschr  = chr($15); delchr = chr($19);
  20 ( 2463)     rubout  = chr($5f); cright = chr($16);
  21 ( 2463) 
  22 ( 2463) mem curlin  = $ed: integer&;
  23 ( 2463)     curpos  = $ee: integer&;
  24 ( 2463)     filcyc  = $311: integer&;
  25 ( 2463)     video   = $400: array[900] of char&;
  26 ( 2463)     topi    = $400: array[xmax] of integer&;
  27 ( 2463)     topc    = $400: array[xmax] of char&;
  28 ( 2463) 
  29 ( 2463) 
  30 ( 2463) var line,nlines,topline,i,dummy,debug: integer;
  31 ( 2463)     name: array[15] of char;
  32 ( 2463)     fno: file;
  33 ( 2463)     chi : char;
  34 ( 2463)     cyclus,drive,mark,nmarks,savecx: integer;
  35 ( 2463)     default, iseof, stop: boolean;
  36 ( 2463)     fs: cpnt;
  37 ( 2463)     linepnt: array[maxlines] of cpnt;
  38 ( 2463)     relpnt:  integer;
  39 ( 2463)     stemp,stemp2: cpnt;
  40 ( 2463) 
  41 ( 2463) func printable(ch:char):boolean;
  42 ( 2463) begin
  43 ( 2463)   printable:=((ord(ch)>=$20) and (ord(ch)<=$7e))
  44 ( 2482)     and (ch<>rubout);
  45 ( 2490) end;
  46 ( 2495) 
  47 ( 2496) proc putontop(s:cpnt;pos:integer;inv:boolean);
  48 ( 2496) var i:integer;
  49 ( 2499) begin
  50 ( 2499)   i:=0; { faster version: if not in loop }
  51 ( 2507)   if inv then while s[i]<>endmark do begin
  52 ( 2530)     topi[i+pos]:=ord(s[i]) or 128; i:=i+1;
  53 ( 2565)   end else while s[i]<>endmark do begin
  54 ( 2592)     topc[i+pos]:=s[i]; i:=i+1;
  55 ( 2624)   end;
  56 ( 2629) end;
  57 ( 2632) 
  58 ( 2633) proc release(p:cpnt);
  59 ( 2633) begin

----------------------------------------------------------------------

R65 COMPILE 4.2: program PEDIT            7/2/24 page 2

  60 ( 2633)   linepnt[relpnt]:=p; relpnt:=relpnt-1;
  61 ( 2656) end;
  62 ( 2661) 
  63 ( 2662) proc setnumlin(l,c:integer);
  64 ( 2662) mem numlin=$1789: integer&;
  65 ( 2665)     numchr=$178a: integer&;
  66 ( 2665) begin
  67 ( 2665)   numlin:=l; numchr:=c;
  68 ( 2676) end;
  69 ( 2685) 
  70 ( 2686) func column:integer;
  71 ( 2686) begin
  72 ( 2686)   column:=line-topline+1;
  73 ( 2702) end;
  74 ( 2707) 
  75 ( 2708) proc goto(xpos, ypos: integer);
  76 ( 2708) begin
  77 ( 2708)   curlin:=ypos; { top on line 2 }
  78 ( 2721)   if curlin>15 then curlin:=15;
  79 ( 2732)   curpos:=xpos-1;
  80 ( 2742) end;
  81 ( 2747) 
  82 ( 2748) proc clrmessage;
  83 ( 2748) var i:integer;
  84 ( 2751) begin
  85 ( 2751)   for i:=inpx-1 to xmax-1 do topi[i]:=128;
  86 ( 2782) end;
  87 ( 2803) 
  88 ( 2804) proc showerror(s:cpnt);
  89 ( 2804) var i: integer;
  90 ( 2807)     ch: char;
  91 ( 2807) begin
  92 ( 2807)   clrmessage;
  93 ( 2813)   putontop(s,36,true);
  94 ( 2827)   read(@key,ch);
  95 ( 2835)   clrmessage;
  96 ( 2840) end;
  97 ( 2840) 
  98 ( 2841) func rnew:cpnt;
  99 ( 2841) var i:integer;
 100 ( 2844)     s:cpnt;
 101 ( 2844) begin
 102 ( 2844)   if relpnt<maxlines-1 then begin
 103 ( 2857)     relpnt:=relpnt+1; s:=linepnt[relpnt];
 104 ( 2875)   end else if nlines<maxlines-1 then s:=new
 105 ( 2900)   else s:=nil;
 106 ( 2915)   rnew:=s;
 107 ( 2919)   if s<>nil then begin
 108 ( 2934)     for i:=0 to xmax-1 do s[i]:=' ';
 109 ( 2963)     s[xmax]:=endmark;
 110 ( 2985)     s[marked]:=chr(0);
 111 ( 2993)   end;
 112 ( 2998)   if nlines>maxlines-5 then
 113 ( 3007)     showerror('Warning: Low memory');
 114 ( 3040) end;
 115 ( 3040) 
 116 ( 3041) proc newline;
 117 ( 3041) begin
 118 ( 3041)   linepnt[nlines]:=rnew;
 119 ( 3056)   nlines:=nlines+1;

----------------------------------------------------------------------

R65 COMPILE 4.2: program PEDIT            7/2/24 page 3

 120 ( 3066) end;
 121 ( 3071) 
 122 ( 3072) 
 123 ( 3072) func isnumber(ci:integer):boolean;
 124 ( 3072) begin
 125 ( 3072)   isnumber:=(ci>=ord('0')) and (ci<=ord('9'))
 126 ( 3090) end;
 127 ( 3096) 
 128 ( 3097) proc getinput(var c:char;var n:integer; s:cpnt);
 129 ( 3097) { get input line on top and analyze it }
 130 ( 3097) var i,j,stop:integer; ch: char;
 131 ( 3100) begin
 132 ( 3100)   goto(inpx,0); write(chr(ord(':') or 128));
 133 ( 3119)   {read input}
 134 ( 3119)   read(@key,ch); i:=0;
 135 ( 3130)   while (ch<>chr(13)) and (ch<>esc) do begin
 136 ( 3153)     if (ch=rubout) then begin
 137 ( 3160)       if i>0 then i:=i-1; goto(i+inpx+1,0);
 138 ( 3202)       write(chr(ord(' ') or 128),cleft);
 139 ( 3212)     end else if (ch>=' ') and (ch<=chr($7d)) and
 140 ( 3230)       (inpx+i<xmax-1) then begin
 141 ( 3245)       goto(i+inpx+1,0);
 142 ( 3266)       write(chr(ord(ch) or 128)); i:=i+1;
 143 ( 3281)     end;
 144 ( 3286)     read(@key,ch);
 145 ( 3294)   end;
 146 ( 3295)   stop:=i+inpx; n:=0; s[0]:=endmark; c:=endmark;
 147 ( 3325)   {set c}
 148 ( 3329)   if stop<=inpx then exit;
 149 ( 3340)   c:=chr(topi[inpx] and 127);
 150 ( 3350)   {set n}
 151 ( 3355)   if stop<inpx+1 then exit;
 152 ( 3369)   i:=inpx+1;
 153 ( 3373)   while isnumber(topi[i] and 127) and
 154 ( 3398)       (i<stop) do begin
 155 ( 3411)     n:=10*n+(topi[i] and 127)-ord('0');
 156 ( 3433)     i:=i+1;
 157 ( 3444)   end;
 158 ( 3449)   j:=0;
 159 ( 3454)   while i<=stop do begin
 160 ( 3470)     s[j]:=chr(topi[i] and 127); i:=i+1; j:=j+1;
 161 ( 3508)   end;
 162 ( 3513)   s[j]:=endmark;
 163 ( 3522) end;
 164 ( 3526) 
 165 ( 3527) func readline(input: file; pnt: cpnt): boolean;
 166 ( 3527) const alteof=chr(127);
 167 ( 3530) var ch1: char;
 168 ( 3530)     pos: integer;
 169 ( 3530) begin
 170 ( 3530)   pos := 0; read(@fno,ch1);
 171 ( 3548)   while (ch1>=' ') and (ch1<>alteof) and
 172 ( 3563)       (pos<xmax-1) do begin
 173 ( 3578)     pnt[pos]:=ch1; pos:=pos+1; read(@fno,ch1);
 174 ( 3611)     end;
 175 ( 3612)   { not  required, done by new }
 176 ( 3615)   { while pos<xmax do begin
 177 ( 3615)     pnt[pos]:=' '; pos:=pos+1;
 178 ( 3615)   end; }
 179 ( 3615)   readline:=(ch1=eof) or (ch1=alteof);

----------------------------------------------------------------------

R65 COMPILE 4.2: program PEDIT            7/2/24 page 4

 180 ( 3629) end;
 181 ( 3634) 
 182 ( 3635) proc showline(pnt:cpnt; y: integer);
 183 ( 3635) var lstart,pos: integer;
 184 ( 3638) begin
 185 ( 3638)   lstart:=y*xmax;
 186 ( 3646)   if (pnt=nil) then
 187 ( 3658)    for pos:=0 to xmax-1 do
 188 ( 3671)     video[lstart+pos]:=' '
 189 ( 3690)   else begin
 190 ( 3716)     pos:=0;
 191 ( 3718)     while (pos<xmax) and (pnt[pos]<>endmark) do begin
 192 ( 3746)       video[lstart+pos]:=pnt[pos]; pos:=pos+1
 193 ( 3776)     end;
 194 ( 3783)     while pos<xmax do begin
 195 ( 3796)       video[lstart+pos]:=' '; pos:=pos+1
 196 ( 3818)     end
 197 ( 3820)   end;
 198 ( 3828) end;
 199 ( 3828) 
 200 ( 3829) proc showtop;
 201 ( 3829) begin
 202 ( 3829)   intstr(line,stemp,3); putontop(stemp,5,true);
 203 ( 3864)   intstr(nlines-1,stemp,3); putontop(stemp,12,true);
 204 ( 3897) end;
 205 ( 3897) 
 206 ( 3898) proc showall;
 207 ( 3898) var lstart,y,i,l,lstart: integer;
 208 ( 3901) begin
 209 ( 3901)   showtop;
 210 ( 3907)   for y:=1 to scrlins-1 do begin
 211 ( 3927)     l:=topline-1+y; lstart:=y*xmax;
 212 ( 3949)     if l<nlines then
 213 ( 3958)       showline(linepnt[l],y)
 214 ( 3974)     else
 215 ( 3984)       for i:=0 to xmax-1 do
 216 ( 3997)         video[lstart+i]:=' ';
 217 ( 4018)   end;
 218 ( 4039) end;
 219 ( 4053) 
 220 ( 4054) proc updline(pnt: cpnt; lstart:integer);
 221 ( 4054) var pos: integer;
 222 ( 4057) begin
 223 ( 4057)   for pos:=0 to xmax-1 do
 224 ( 4069)     pnt[pos]:=video[lstart+pos];
 225 ( 4095) end;
 226 ( 4115) 
 227 ( 4116) func lastpos(l:integer):integer;
 228 ( 4116) { returns -1 if line empty }
 229 ( 4116) var endpos:integer;
 230 ( 4119)     s:cpnt;
 231 ( 4119) begin
 232 ( 4119)   endpos:=xmax-1;
 233 ( 4125)   s:=linepnt[l];
 234 ( 4134)   while (chr(ord(s[endpos]) and $7f)=' ')
 235 ( 4158)     and (endpos>0) do endpos:=endpos-1;
 236 ( 4176)   if (endpos=0) and (chr(ord(s[endpos]) and $7f)=' ')
 237 ( 4207)   then endpos:=-1;
 238 ( 4214)   lastpos:=endpos;
 239 ( 4219) end;

----------------------------------------------------------------------

R65 COMPILE 4.2: program PEDIT            7/2/24 page 5

 240 ( 4227) 
 241 ( 4228) proc chkline;
 242 ( 4228) begin
 243 ( 4228)   if line<1 then line:=1
 244 ( 4243)   else if line>nlines-1 then line:=nlines-1;
 245 ( 4273) end;
 246 ( 4278) 
 247 ( 4279) proc chktop(show: boolean);
 248 ( 4279) var savetop,bottom:integer;
 249 ( 4282) begin
 250 ( 4282)   savetop:=topline; bottom:=topline+scrlins-1;
 251 ( 4301)   if line<topline then topline:=line;
 252 ( 4318)   { keep cursor above bottom line, if possible }
 253 ( 4326)   if line>=bottom-1 then
 254 ( 4336)     topline:=line-scrlins+3;
 255 ( 4350)   if show and (savetop<>topline) then showall;
 256 ( 4376) end;
 257 ( 4376) 
 258 ( 4377) proc delline;
 259 ( 4377) var i:integer; savpnt:cpnt;
 260 ( 4380) begin
 261 ( 4380)   chkline; savpnt:=linepnt[line];
 262 ( 4390)   if line<mark then mark:=mark-1;
 263 ( 4416)   for i:=line to nlines-2 do
 264 ( 4435)     linepnt[i]:=linepnt[i+1];
 265 ( 4456)   release(savpnt); nlines:=nlines-1;
 266 ( 4494)   chkline; chktop(false);
 267 ( 4511)   line:=line-1; savecx:=1;
 268 ( 4524) end;
 269 ( 4528) 
 270 ( 4529) proc join;
 271 ( 4529) var p,p1,p2,pm:integer;
 272 ( 4532)     s1,s2:cpnt;
 273 ( 4532) begin
 274 ( 4532)   p1:=lastpos(line-1); p2:=lastpos(line);
 275 ( 4565)   s1:=linepnt[line-1]; s2:=linepnt[line];
 276 ( 4588)   for p:=p1+1 to xmax-1 do s1[p]:=s2[p-p1-1];
 277 ( 4641)   if p1+p2<xmax then delline
 278 ( 4673)   else begin
 279 ( 4683)     pm:=xmax-p1;
 280 ( 4685)     for p:=0 to xmax-pm do s2[+p]:=s2[p+pm-1];
 281 ( 4736)     for p:=xmax-pm+1 to xmax-1 do s2[p]:=' ';
 282 ( 4790)     line:=line-1;
 283 ( 4814)   end;
 284 ( 4819)   savecx:=p1+2; chkline; chktop(false); showall;
 285 ( 4846) end;
 286 ( 4846) 
 287 ( 4847) func edlin(pnt: cpnt): char;
 288 ( 4847) const key    = @1;
 289 ( 4850) var   ch1,lstch1,lstch2: char;
 290 ( 4850)       stop: boolean;
 291 ( 4850)       lstart: integer;
 292 ( 4850) begin
 293 ( 4850)   goto(savecx,column);
 294 ( 4868)   if savecx=1 then write(cright,cleft)
 295 ( 4883)   else write(cleft,cright); {to update cursor}
 296 ( 4893)   stop:=false; lstart:=column*xmax;
 297 ( 4907)   repeat
 298 ( 4912)     read(@key,ch1);
 299 ( 4920)     lstch1:=' '; lstch2:=' ';

----------------------------------------------------------------------

R65 COMPILE 4.2: program PEDIT            7/2/24 page 6

 300 ( 4929)     case ch1 of
 301 ( 4933)       delchr,rubout: if (curpos=0) and (line>1)
 302 ( 4963)              then begin
 303 ( 4965)                updline(pnt,lstart);join;stop:=true;
 304 ( 4988)              end else write(cleft,delchr);
 305 ( 5001)       cleft: if curpos>0 then write(cleft)
 306 ( 5022)              else if line>1 then begin
 307 ( 5033)                updline(pnt,lstart);
 308 ( 5050)                line:=line-1; curpos:=lastpos(line)+1;
 309 ( 5075)                stop:=true;
 310 ( 5082)              end;
 311 ( 5086)       cright:if curpos<xmax-1 then begin
 312 ( 5105)                write(cright);
 313 ( 5111)              end else if line<nlines-1 then begin
 314 ( 5126)                updline(pnt,lstart);
 315 ( 5143)                line:=line+1; curpos:=0;
 316 ( 5156)                stop:=true;
 317 ( 5162)              end;
 318 ( 5166)       cup,cdown,esc,cr,rup,rdown,
 319 ( 5208)       pgup,pgdown,hom,pgend: stop:=true
 320 ( 5239)       else begin
 321 ( 5248)              if printable(ch1) then begin
 322 ( 5260)                lstch1:=video[lstart+xmax-1];
 323 ( 5276)                lstch1:=chr(ord(lstch1) and $7f);
 324 ( 5289)                lstch2:=video[lstart+xmax-2];
 325 ( 5307)                lstch2:=chr(ord(lstch2) and $7f);
 326 ( 5320)                if curpos>=xmax-1 then begin
 327 ( 5334)                  if line>=nlines-1 then newline;
 328 ( 5356)                  video[lstart+xmax-1]:=ch1;
 329 ( 5366)                  curpos:=0;
 330 ( 5379)                  lstch1:=cdown;
 331 ( 5385)                end else begin
 332 ( 5392)                  write(inschr); write(ch1);
 333 ( 5400)                end;
 334 ( 5400)                if (lstch1<>' ') or (lstch2<>' ')
 335 ( 5413)                  then stop:=true;
 336 ( 5420)              end;
 337 ( 5424)            end
 338 ( 5424)     end {case};
 339 ( 5426)     until stop;
 340 ( 5426)   updline(pnt,lstart);
 341 ( 5447)   if (lstch1<>' ') or (lstch2<>' ') then edlin:=lstch1
 342 ( 5465)   else edlin:=ch1;
 343 ( 5476)   if (ch1<>delchr) and (ch1<>rubout) then
 344 ( 5498)     savecx:=curpos+1;
 345 ( 5507) end;
 346 ( 5512) 
 347 ( 5513) proc setsubtype(subtype:char);
 348 ( 5513) { only set subtype if not already there }
 349 ( 5513) var i:integer;
 350 ( 5516) begin
 351 ( 5516)   i:=0;
 352 ( 5520)   repeat
 353 ( 5524)     i:=i+1;
 354 ( 5530)   until (name[i]=':') or
 355 ( 5546)     (name[i]=' ') or (i>=14);
 356 ( 5565)   if name[i]<>':' then begin
 357 ( 5580)     name[i]:=':';
 358 ( 5589)     name[i+1]:=subtype;
 359 ( 5600)   end;

----------------------------------------------------------------------

R65 COMPILE 4.2: program PEDIT            7/2/24 page 7

 360 ( 5608) end;
 361 ( 5608) 
 362 ( 5609) proc readinput;
 363 ( 5609) var i,pend,maxl1:integer;
 364 ( 5612) begin
 365 ( 5612)   cyclus:=0; drive:=1;
 366 ( 5622)   goto(1,1); write(clrscr); goto(1,0);
 367 ( 5649)   agetstring(name,default,cyclus,drive);
 368 ( 5689)   setsubtype('P');
 369 ( 5697)   asetfile(name,cyclus,drive,' ');
 370 ( 5719)   { openr(fno); }
 371 ( 5719)   nlines := 1; line:=1; topline:=1;
 372 ( 5733)   pend:=15; while name[pend]=' ' do pend:=pend-1;
 373 ( 5763)   for i:=0 to pend do stemp[i]:=name[i];
 374 ( 5798)   stemp[pend+1]:=endmark;
 375 ( 5829)   stradd('.',stemp);
 376 ( 5847)   hexstr(filcyc,stemp2);
 377 ( 5861)   stradd(stemp2,stemp);
 378 ( 5875)   while strlen(stemp)<17 do stradd(' ',stemp);
 379 ( 5907)   putontop(stemp,17,true);
 380 ( 5924)   putontop('Reading',36,true);
 381 ( 5944)   maxl1:=maxlines-9;
 382 ( 5949)   showtop;
 383 ( 5958)   exit;
 384 ( 5959)   repeat
 385 ( 5959)     linepnt[nlines] := rnew;
 386 ( 5969)     iseof := readline(fno, linepnt[nlines]);
 387 ( 5993)     nlines := nlines+1;
 388 ( 6003)     if (nlines and $1f)=0 then showtop;
 389 ( 6025)     until iseof or (nlines >= maxl1);
 390 ( 6038)   showtop;
 391 ( 6046)   if nlines >= maxlines-9 then
 392 ( 6055)       showerror('Too many lines');
 393 ( 6083)   close(fno);
 394 ( 6089)   clrmessage;
 395 ( 6093)   showall;
 396 ( 6097) end;
 397 ( 6097) 
 398 ( 6098) proc writeoutput;
 399 ( 6098) var pos,endpos,nlm1:integer;s,saveline:cpnt;
 400 ( 6101) begin
 401 ( 6101)   cyclus:=0; drive:=1;
 402 ( 6111)   goto(1,1); write(clrscr); goto(1,0);
 403 ( 6138)   asetfile(name,cyclus,drive,' ');
 404 ( 6160)   openw(fno);
 405 ( 6166)   putontop('Writing',36,true);
 406 ( 6186)   nlm1:=nlines-1;
 407 ( 6192)   for line:=1 to nlm1 do begin
 408 ( 6216)     if (line and $1f)=0 then showtop;
 409 ( 6233)     endpos:=lastpos(line);
 410 ( 6245)     s:=linepnt[line];
 411 ( 6253)     for pos:=0 to endpos do
 412 ( 6267)       write(@fno,chr(ord(s[pos]) and $7f));
 413 ( 6301)     if (line<nlm1) then write(@fno,cr);
 414 ( 6336)   end;
 415 ( 6336)   showtop;
 416 ( 6354)   close(fno); line:=nlines-1;
 417 ( 6366)   showall;
 418 ( 6375) end;
 419 ( 6375) 

----------------------------------------------------------------------

R65 COMPILE 4.2: program PEDIT            7/2/24 page 8

 420 ( 6376) proc clrmarks;
 421 ( 6376) var x,savel,xm1:integer; s:cpnt;
 422 ( 6379) begin
 423 ( 6379)   putontop('Clearing marks',36,true);
 424 ( 6408)   savel:=line;
 425 ( 6408)   for line:=1 to nlines-1 do begin
 426 ( 6438)     s:=linepnt[line];
 427 ( 6442)     if s[marked]<>chr(0) then begin
 428 ( 6462)       xm1:=xmax-1;
 429 ( 6469)       for x:=0 to xm1 do
 430 ( 6480)         s[x]:=chr(ord(s[x]) and $7f);
 431 ( 6510)       s[marked]:=chr(0);
 432 ( 6533)       end;
 433 ( 6538)     end;
 434 ( 6538)   line:=savel; mark:=0;
 435 ( 6562) end;
 436 ( 6566) 
 437 ( 6567) proc find(again:boolean);
 438 ( 6567) var pos,x,i:integer;
 439 ( 6570)     ch:char;
 440 ( 6570)     found:boolean;
 441 ( 6570)     s2:cpnt;
 442 ( 6570) 
 443 ( 6570)   proc checkrest;
 444 ( 6570)   var failed:boolean;
 445 ( 6573)       x1:integer;
 446 ( 6573)       s1:cpnt;
 447 ( 6573)   begin
 448 ( 6573)     failed:=false; pos:=2; x1:=x+1;
 449 ( 6593)     while (fs[pos]<>endmark) and (x1<xmax) do begin
 450 ( 6622)       s1:=linepnt[line];
 451 ( 6626)       if s1[x1] <> fs[pos] then failed:=true;
 452 ( 6660)       pos:=pos+1; x1:=x1+1;
 453 ( 6681)       end;
 454 ( 6686)      if (failed=false) and (fs[pos]=endmark)
 455 ( 6708)       then found:=true;
 456 ( 6715)   end;
 457 ( 6719) 
 458 ( 6720) begin
 459 ( 6720)   clrmessage;
 460 ( 6726)   if not again then strcpy(stemp,fs);
 461 ( 6748)   if fs[0]=endmark then begin
 462 ( 6759)     {empty string -> delete all marks}
 463 ( 6762)     clrmarks;
 464 ( 6766)     end
 465 ( 6766)   else begin
 466 ( 6769)     putontop('Searching',36,true);
 467 ( 6791)     found:=false;
 468 ( 6793)     repeat
 469 ( 6797)       x:=0;
 470 ( 6799)       repeat
 471 ( 6803)         pos:=1;
 472 ( 6805)         s2:=linepnt[line];
 473 ( 6813)         if s2[x]=fs[pos] then checkrest;
 474 ( 6849)         x:=x+1;
 475 ( 6855)         until found or (x>=xmax);
 476 ( 6871)       if (line and $0f)=0 then showtop;
 477 ( 6892)       line:=line+1;
 478 ( 6898)       until found or (line>=nlines);
 479 ( 6916)     if found then begin

----------------------------------------------------------------------

R65 COMPILE 4.2: program PEDIT            7/2/24 page 9

 480 ( 6924)       line:=line-1; x:=x-1; i:=1;
 481 ( 6951)       s2:=linepnt[line];
 482 ( 6959)       savecx:=x+i;
 483 ( 6971)       s2[marked]:=chr(1);
 484 ( 6984)       while fs[i]<>endmark do begin
 485 ( 7005)         s2[x+i-1]:=chr(ord(s2[x+i-1]) or $80);
 486 ( 7038)          i:=i+1;
 487 ( 7049)         end
 488 ( 7054)       end
 489 ( 7054)     else begin
 490 ( 7060)       line:=nlines-1;
 491 ( 7066)     end;
 492 ( 7071)     showtop;
 493 ( 7075)   end
 494 ( 7075) end;
 495 ( 7075) 
 496 ( 7076) proc insertline;
 497 ( 7076) var i:integer;
 498 ( 7079)     s1,s2:cpnt;
 499 ( 7079) begin
 500 ( 7079)   if nlines<maxlines-1 then begin
 501 ( 7092)     if line<mark then mark:=mark+1;
 502 ( 7113)     if line<nlines-1 then begin
 503 ( 7130)       for i:=nlines-1 downto line+1 do
 504 ( 7150)         linepnt[i+1]:=linepnt[i];
 505 ( 7171)       end;
 506 ( 7193)     linepnt[line+1]:=rnew;
 507 ( 7206)     s1:=linepnt[line+1]; s2:=linepnt[line];
 508 ( 7229)     for i:=0 to xmax-1 do s1[i]:=' ';
 509 ( 7263)     for i:=curpos to xmax-1 do begin
 510 ( 7302)       s1[i-curpos]:=s2[i]; s2[i]:=' ';
 511 ( 7330)       end;
 512 ( 7334)     line:=line+1; nlines:=nlines+1;
 513 ( 7365)     savecx:=1; chkline; chktop(false); showall;
 514 ( 7392)   end;
 515 ( 7392) end;
 516 ( 7392) 
 517 ( 7393) proc paste;
 518 ( 7393) var l,i,saveline:integer; s1,s2:cpnt;
 519 ( 7396) begin
 520 ( 7396)   saveline:=line;
 521 ( 7398)   if nlines+nmarks<maxlines then begin
 522 ( 7419)     if (line>=mark+nmarks) or
 523 ( 7436)           (line<mark) then begin
 524 ( 7446)       putontop('Pasting',36,true);
 525 ( 7469)       for l:=0 to nmarks-1 do begin
 526 ( 7491)         for i:=nlines-1 downto line do
 527 ( 7502)           linepnt[i+1]:=linepnt[i];
 528 ( 7526)         nlines:=nlines+1;
 529 ( 7554)         if mark>line then mark:=mark+1;
 530 ( 7577)         linepnt[line]:=rnew;
 531 ( 7592)         s1:=linepnt[line];
 532 ( 7600)         s2:=linepnt[mark+l];
 533 ( 7617)         for i:=0 to xmax do s1[i]:=s2[i];
 534 ( 7654)         s1[marked]:=chr($80);
 535 ( 7678)         line:=line+1;
 536 ( 7689)       end;
 537 ( 7694)       showall;
 538 ( 7712)     end else showerror('Cannot paste here');
 539 ( 7741)   end else showerror('Error: Out of memory');

----------------------------------------------------------------------

R65 COMPILE 4.2: program PEDIT            7/2/24 page 10

 540 ( 7773)   line:=saveline; chktop(false);
 541 ( 7789) end;
 542 ( 7789) 
 543 ( 7790) proc move;
 544 ( 7790) var l,i,saveline:integer; s1,s2,savpnt:cpnt;
 545 ( 7793) begin
 546 ( 7793)   saveline:=line;
 547 ( 7795)   if (line>=mark+nmarks) or
 548 ( 7817)         (line<mark) then begin
 549 ( 7827)     putontop('Moving',36,true);
 550 ( 7849)     for l:=0 to nmarks-1 do begin
 551 ( 7871)       savpnt:=linepnt[mark];
 552 ( 7875)       if mark>line then begin
 553 ( 7892)         for i:=mark-1 downto line do
 554 ( 7906)           linepnt[i+1]:=linepnt[i];
 555 ( 7930)         linepnt[line]:=savpnt;
 556 ( 7956)         line:=line+1; mark:=mark+1;
 557 ( 7981)       end else begin
 558 ( 7989)         for i:=mark+1 to line-1 do
 559 ( 8006)           linepnt[i-1]:=linepnt[i];
 560 ( 8027)         linepnt[line-1]:=savpnt;
 561 ( 8056)         saveline:=saveline-1;
 562 ( 8070)       end;
 563 ( 8075)     end;
 564 ( 8075)     showall;
 565 ( 8093)   end else showerror('Cannot move here');
 566 ( 8121)   line:=saveline; mark:=saveline;
 567 ( 8129)   chktop(false);
 568 ( 8145) end;
 569 ( 8145) 
 570 ( 8146) func doesc: boolean;
 571 ( 8146) var ch:char;
 572 ( 8149)     i,j,n:integer;
 573 ( 8149)     s,savl:cpnt;
 574 ( 8149) begin
 575 ( 8149)   clrmessage;
 576 ( 8155)   doesc:=false; savecx:=1;
 577 ( 8163)   getinput(ch,n,stemp);
 578 ( 8193)   if (ch='f') and (stemp[0]<>' ') and
 579 ( 8211)     (strlen(stemp)<>0) then
 580 ( 8227)     showerror('Expected f xxx')
 581 ( 8248)   else if (ch<>'l') and (ch<>'d') and
 582 ( 8271)     (ch<>'c') and (n>0) then
 583 ( 8287)     showerror('n>1 not allowed')
 584 ( 8309)   else begin
 585 ( 8318)     case ch of
 586 ( 8318)       't': begin {top}
 587 ( 8329)              line:=1; chktop(true);
 588 ( 8343)            end;
 589 ( 8343)       'b': begin {bottom}
 590 ( 8353)              line:=nlines-1; chktop(true);
 591 ( 8372)            end;
 592 ( 8372)       'l': begin {goto line}
 593 ( 8382)              line:=n; chkline; chktop(true);
 594 ( 8402)            end;
 595 ( 8402)       'f','a': begin {find string (again)}
 596 ( 8419)              find(ch='a'); chkline; chktop(false);
 597 ( 8444)              showall;
 598 ( 8448)            end;
 599 ( 8448)       'z': begin {clear marks}

----------------------------------------------------------------------

R65 COMPILE 4.2: program PEDIT            7/2/24 page 11

 600 ( 8458)              clrmarks; showall;
 601 ( 8466)            end;
 602 ( 8466)       'c': begin {mark lines for copy}
 603 ( 8476)              clrmarks;
 604 ( 8480)              if n<1 then n:=1;
 605 ( 8492)              if n>nlines-line then n:=nlines-line;
 606 ( 8517)              mark:=line;
 607 ( 8526)              nmarks:=n;
 608 ( 8534)              for i:=0 to n-1 do begin
 609 ( 8564)                s:=linepnt[line+i];
 610 ( 8573)                for j:=0 to xmax-1 do
 611 ( 8591)                  s[j]:= chr(ord(s[j]) or $80);
 612 ( 8618)                s[marked]:=chr(1);
 613 ( 8641)              end;
 614 ( 8646)              showall;
 615 ( 8664)            end;
 616 ( 8664)       'p': begin {paste copied lines}
 617 ( 8674)              if mark=0 then
 618 ( 8680)                showerror('Error: Nothing copied')
 619 ( 8708)              else paste;
 620 ( 8721)            end;
 621 ( 8721)       'm': begin {move copied lines}
 622 ( 8731)              if mark=0 then
 623 ( 8737)                showerror('Error: Nothing copied')
 624 ( 8765)              else move;
 625 ( 8778)            end;
 626 ( 8778)       'd': begin {delete n lines}
 627 ( 8788)              if n<1 then n:=1;
 628 ( 8800)              if line+n=maxlines-3 then
 629 ( 8818)                n:=maxlines-3-line;
 630 ( 8829)              for i:=1 to n do begin
 631 ( 8857)                delline; line:=line+1;
 632 ( 8867)              end;
 633 ( 8872)              chkline; chktop(false); showall;
 634 ( 8902)            end;
 635 ( 8902)       'w': writeoutput; {write output}
 636 ( 8919)       'q': begin {write output and quit}
 637 ( 8926)              writeoutput; doesc:=true;
 638 ( 8932)            end;
 639 ( 8936)       'k': doesc:=true; {kill program}
 640 ( 8955)       '?','h': showerror('tb/l/fg/cpm/d/wqk/?h');
 641 ( 8998)       endmark: begin end
 642 ( 9008)       else showerror('tb/l/faz/cpm/d/wqk/?')
 643 ( 9034)     end {case};
 644 ( 9042)   end;
 645 ( 9042)   clrmessage;
 646 ( 9046) end;
 647 ( 9046) 
 648 ( 9047) proc newline;
 649 ( 9047) begin
 650 ( 9047)   linepnt[nlines]:=rnew; nlines:=nlines+1;
 651 ( 9072) end;
 652 ( 9077) 
 653 ( 9078) proc insert(ch:char;l:integer);
 654 ( 9078) { insert char at start of line (recursive) }
 655 ( 9078) var i,y:integer;
 656 ( 9081)     pnt:cpnt;
 657 ( 9081)     lstch1,lstch2:char;
 658 ( 9081) begin
 659 ( 9081)   if l>=nlines then newline;

----------------------------------------------------------------------

R65 COMPILE 4.2: program PEDIT            7/2/24 page 12

 660 ( 9099)   pnt:=linepnt[l];
 661 ( 9103)   lstch1:=chr(ord(pnt[xmax-1]) and $7f);
 662 ( 9125)   lstch2:=chr(ord(pnt[xmax-2]) and $7f);
 663 ( 9144)   if (lstch1<>' ') or (lstch2<>' ')
 664 ( 9162)     then insert(lstch1,l+1);
 665 ( 9184)   for i:=xmax-2 downto 0 do pnt[i+1]:=pnt[i];
 666 ( 9219)   pnt[0]:=ch; y:=l-topline+1;
 667 ( 9260)   if (y>0) and (y<scrlins) then showline(pnt,y);
 668 ( 9297) end;
 669 ( 9297) 
 670 ( 9298) begin {main}
 671 ( 9298)   for i:=0 to maxlines-1 do linepnt[i]:=nil;
 672 ( 9328)   stemp:=new; stemp2:=new; fs:=new; debug:=0;
 673 ( 9378)   setnumlin($0f,$37); write(hom,clrscr);
 674 ( 9398)   putontop('Line xxx of xxx',0,true);
 675 ( 9426)   relpnt:=maxlines-1; mark:=0; savecx:=1;
 676 ( 9444)   clrmessage; readinput; fs[0]:=endmark;
 677 ( 9460)   putontop(title,36,true);
 678 ( 9478)   topline:= 1; line:=1; showall; stop:=false;
 679 ( 9496)   repeat
 680 ( 9500)     showtop; chi := edlin(linepnt[line]);
 681 ( 9520)     if printable(chi) then insert(chi,line+1)
 682 ( 9549)     else case chi of
 683 ( 9559)       cup,cdown: begin
 684 ( 9577)              if chi=cup then line:=line-1
 685 ( 9591)              else line:=line+1;
 686 ( 9607)              chkline;
 687 ( 9616)              if curpos>lastpos(line)+2 then
 688 ( 9633)                savecx:=lastpos(line)+2;
 689 ( 9652)              chktop(true);
 690 ( 9665)            end;
 691 ( 9665)       pgup: begin
 692 ( 9675)              line:=line-15; chkline; chktop(true);
 693 ( 9698)            end;
 694 ( 9698)       pgdown: begin
 695 ( 9708)              line:=line+15; chkline; chktop(true);
 696 ( 9731)            end;
 697 ( 9731)       rup: if (topline>1) then begin
 698 ( 9748)              topline:=topline-1;chktop(false);showall;
 699 ( 9774)            end;
 700 ( 9774)       rdown: if (topline<nlines-15) then begin
 701 ( 9796)              topline:=topline+1;chktop(false);showall;
 702 ( 9822)            end;
 703 ( 9822)       hom: begin
 704 ( 9832)              line:=1; savecx:=1; chktop(true);
 705 ( 9852)            end;
 706 ( 9852)       pgend: begin
 707 ( 9862)              line:=nlines-1; savecx:=1; chktop(true);
 708 ( 9887)            end;
 709 ( 9887)       cr:  insertline;
 710 ( 9901)       esc: if doesc then stop:=true
 711 ( 9920)     end {case};
 712 ( 9928)     until stop;
 713 ( 9928)   setnumlin($29,$2f);
 714 ( 9945)   writeln(hom, clrscr);
 715 ( 9957)   dummy:=freedsk(fildrv,true);
 716 ( 9970) end.
 717 ( 9974) 

End compile

Code lenght:          9973
Compiler stack size:  134
Ident stack size:     192
Pascal errors:        0
