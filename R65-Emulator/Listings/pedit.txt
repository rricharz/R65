
R65 Pascal program PEDIT           8/11/23     page 1


                   1 (    4) program pedit;
                   2 (    4) 
                   3 (    4) { Pascal editor, original 1980 RR
                   4 (    4)   rewritten 2023 RR for R65 system }
                   5 (    4) 
                   6 (    4) uses syslib, arglib, strlib,disklib;
                   7 ( 2655) 
                   8 ( 2655) const
                   9 ( 2655)     maxlines= 420;      xmax   =56;
                  10 ( 2658)     scrlins = 16;       mlenght= 19;
                  11 ( 2658)     inpx    = 37;
                  12 ( 2658)     eol     = chr($00); esc    = chr($00);
                  13 ( 2658)     rdown   = chr($02); rup    = chr($08);
                  14 ( 2658)     pgdown  = chr($26); pgup   = chr($24);
                  15 ( 2658)     pgend   = chr($10); clrscr = chr($11);
                  16 ( 2658)     clrlin  = chr($17); cdown  = chr($18);
                  17 ( 2658)     cup     = chr($1a); cleft  = chr($03);
                  18 ( 2658)     inschr  = chr($15); delchr = chr($19);
                  19 ( 2658)     rubout  = chr($5f); cright = chr($16);
                  20 ( 2658) 
                  21 ( 2658) mem curlin  = $ed: integer&;
                  22 ( 2658)     curpos  = $ee: integer&;
                  23 ( 2658)     filcyc  = $311: integer&;
                  24 ( 2658)     video   = $400: array[900] of char&;
                  25 ( 2658)     topi    = $400: array[xmax] of integer&;
                  26 ( 2658)     topc    = $400: array[xmax] of char&;
                  27 ( 2658) 
                  28 ( 2658) 
                  29 ( 2658) var line,nlines,topline,i,dummy: integer;
                  30 ( 2658)     name: array[15] of char;
                  31 ( 2658)     fno: file;
                  32 ( 2658)     chi : char;
                  33 ( 2658)     cyclus,drive,mark,nmark,savecx: integer;
                  34 ( 2658)     default, iseof, exit: boolean;
                  35 ( 2658)     fs: cpnt;
                  36 ( 2658)     linepnt: array[maxlines] of cpnt;
                  37 ( 2658)     relpnt:  integer;
                  38 ( 2658)     stemp,stemp2: cpnt;
                  39 ( 2658) 
                  40 ( 2658) proc putontop(s:cpnt;pos:integer;inv:boolean);
                  41 ( 2658) var i:integer;
                  42 ( 2661) begin
                  43 ( 2661)   i:=0; { faster version: if not in loop }
                  44 ( 2669)   if inv then while s[i]<>chr(0) do begin
                  45 ( 2693)     topi[i+pos]:=ord(s[i]) or 128; i:=i+1;
                  46 ( 2728)   end else while s[i]<>chr(0) do begin
                  47 ( 2756)     topc[i+pos]:=s[i]; i:=i+1;
                  48 ( 2788)   end;
                  49 ( 2793) end;
                  50 ( 2796) 
                  51 ( 2797) func new:cpnt;
                  52 ( 2797) var i:integer;
                  53 ( 2800) begin
                  54 ( 2800)   if relpnt<maxlines-1 then begin
                  55 ( 2813)     relpnt:=relpnt+1; new:=linepnt[relpnt];
                  56 ( 2831)   end else  {assign new memory}
                  57 ( 2842)     new:=strnew;
                  58 ( 2848) end;
                  59 ( 2852) 

----------------------------------------------------------------------

R65 Pascal program PEDIT           8/11/23     page 2

                  60 ( 2853) proc release(p:cpnt);
                  61 ( 2853) begin
                  62 ( 2853)   linepnt[relpnt]:=p; relpnt:=relpnt-1;
                  63 ( 2876) end;
                  64 ( 2881) 
                  65 ( 2882) proc setnumlin(l,c:integer);
                  66 ( 2882) mem numlin=$1789: integer&;
                  67 ( 2885)     numchr=$178a: integer&;
                  68 ( 2885) begin
                  69 ( 2885)   numlin:=l; numchr:=c;
                  70 ( 2896) end;
                  71 ( 2905) 
                  72 ( 2906) func column:integer;
                  73 ( 2906) begin
                  74 ( 2906)   column:=line-topline+1;
                  75 ( 2922) end;
                  76 ( 2927) 
                  77 ( 2928) proc goto(xpos, ypos: integer);
                  78 ( 2928) begin
                  79 ( 2928)   curlin:=ypos; { top on line 2 }
                  80 ( 2941)   if curlin>15 then curlin:=15;
                  81 ( 2952)   curpos:=xpos-1;
                  82 ( 2962) end;
                  83 ( 2967) 
                  84 ( 2968) proc clrmessage;
                  85 ( 2968) var i:integer;
                  86 ( 2971) begin
                  87 ( 2971)   for i:=inpx-1 to xmax-1 do topi[i]:=128;
                  88 ( 3002) end;
                  89 ( 3023) 
                  90 ( 3024) proc getinput(var n:integer; s:cpnt);
                  91 ( 3024) var i,j,stop:integer; ch: char;
                  92 ( 3027) begin
                  93 ( 3027)   goto(inpx,0); write(chr(ord(':') or 128));
                  94 ( 3046)   read(@key,ch); i:=0;
                  95 ( 3057)   while (ch<>chr(13)) and (ch<>esc) do begin
                  96 ( 3080)     if (ch=rubout) then begin
                  97 ( 3087)       if i>0 then i:=i-1; goto(i+inpx+1,0);
                  98 ( 3129)       write(chr(ord(' ') or 128),cleft);
                  99 ( 3139)     end else if (ch>=' ') and (ch<=chr($7d)) and
                 100 ( 3157)       (inpx+i<xmax-1) then begin
                 101 ( 3172)       goto(i+inpx+1,0);
                 102 ( 3193)       write(chr(ord(ch) or 128)); i:=i+1;
                 103 ( 3208)     end;
                 104 ( 3213)     read(@key,ch);
                 105 ( 3221)   end;
                 106 ( 3222)   stop:=i+inpx;
                 107 ( 3231)   i:=inpx; n:=0;
                 108 ( 3244)   while ((topi[i] and 127)>=ord('0')) and
                 109 ( 3263)     ((topi[i] and 127)<=ord('9')) and
                 110 ( 3278)     (i<stop) do begin
                 111 ( 3292)     n:=10*n+(topi[i] and 127)-ord('0');
                 112 ( 3314)     i:=i+1;
                 113 ( 3325)   end;
                 114 ( 3330)   j:=0;
                 115 ( 3335)   while i<stop do begin
                 116 ( 3351)     s[j]:=chr(topi[i] and 127); i:=i+1; j:=j+1;
                 117 ( 3389)   end;
                 118 ( 3394)   s[j]:=chr(0);
                 119 ( 3403) end;

----------------------------------------------------------------------

R65 Pascal program PEDIT           8/11/23     page 3

                 120 ( 3408) 
                 121 ( 3409) func readline(input: file; pnt: cpnt): boolean;
                 122 ( 3409) const alteof=chr(127);
                 123 ( 3412) var ch1: char;
                 124 ( 3412)     pos: integer;
                 125 ( 3412) begin
                 126 ( 3412)   pos := 0; read(@fno,ch1);
                 127 ( 3430)   while (ch1>=' ') and (ch1<>alteof) and
                 128 ( 3445)       (pos<xmax-1) do begin
                 129 ( 3460)     pnt[pos]:=ch1; pos:=pos+1; read(@fno,ch1);
                 130 ( 3493)     end;
                 131 ( 3494)   while pos<xmax do begin
                 132 ( 3507)     pnt[pos]:=' '; pos:=pos+1;
                 133 ( 3523)   end;
                 134 ( 3528)   readline:=(ch1=eof) or (ch1=alteof);
                 135 ( 3545) end;
                 136 ( 3550) 
                 137 ( 3551) proc showline(pnt:cpnt; y: integer);
                 138 ( 3551) var lstart,pos: integer;
                 139 ( 3554) begin
                 140 ( 3554)   lstart:=y*xmax;
                 141 ( 3562)   if (pnt=nil) then
                 142 ( 3574)    for pos:=0 to xmax-1 do
                 143 ( 3587)     video[lstart+pos]:='&'
                 144 ( 3606)   else begin
                 145 ( 3632)     pos:=0;
                 146 ( 3634)     while (pos<xmax) and (pnt[pos]<>chr(0)) do begin
                 147 ( 3663)       video[lstart+pos]:=pnt[pos]; pos:=pos+1
                 148 ( 3693)     end;
                 149 ( 3700)     while pos<xmax do begin
                 150 ( 3713)       video[lstart+pos]:=' '; pos:=pos+1
                 151 ( 3735)     end
                 152 ( 3737)   end;
                 153 ( 3745) end;
                 154 ( 3745) 
                 155 ( 3746) proc showtop;
                 156 ( 3746) begin
                 157 ( 3746)   intstr(line,stemp,3); putontop(stemp,5,true);
                 158 ( 3781)   intstr(nlines-1,stemp,3); putontop(stemp,12,true);
                 159 ( 3814) end;
                 160 ( 3814) 
                 161 ( 3815) proc showerror(s:cpnt);
                 162 ( 3815) var i: integer;
                 163 ( 3818)     ch: char;
                 164 ( 3818) begin
                 165 ( 3818)   clrmessage;
                 166 ( 3824)   putontop(s,36,true);
                 167 ( 3838)   read(@key,ch);
                 168 ( 3846)   clrmessage;
                 169 ( 3851) end;
                 170 ( 3851) 
                 171 ( 3852) proc showall;
                 172 ( 3852) var lstart,y,i,l,lstart: integer;
                 173 ( 3855) begin
                 174 ( 3855)   showtop;
                 175 ( 3861)   for y:=1 to scrlins-1 do begin
                 176 ( 3881)     l:=topline-1+y; lstart:=y*xmax;
                 177 ( 3903)     if l<nlines then
                 178 ( 3912)       showline(linepnt[l],y)
                 179 ( 3928)     else

----------------------------------------------------------------------

R65 Pascal program PEDIT           8/11/23     page 4

                 180 ( 3938)       for i:=0 to xmax-1 do
                 181 ( 3951)         video[lstart+i]:=' ';
                 182 ( 3972)   end;
                 183 ( 3993) end;
                 184 ( 4007) 
                 185 ( 4008) proc updline(pnt: cpnt; lstart:integer);
                 186 ( 4008) var pos: integer;
                 187 ( 4011) begin
                 188 ( 4011)   for pos:=0 to xmax-1 do
                 189 ( 4023)     pnt[pos]:=video[lstart+pos];
                 190 ( 4049) end;
                 191 ( 4069) 
                 192 ( 4070) func lastpos(l:integer):integer;
                 193 ( 4070) { returns -1 if line empty }
                 194 ( 4070) var endpos:integer;
                 195 ( 4073)     s:cpnt;
                 196 ( 4073) begin
                 197 ( 4073)   endpos:=xmax-1;
                 198 ( 4079)   s:=linepnt[l];
                 199 ( 4088)   while (chr(ord(s[endpos]) and $7f)=' ')
                 200 ( 4112)     and (endpos>0) do endpos:=endpos-1;
                 201 ( 4130)   if (endpos=0) and (chr(ord(s[endpos]) and $7f)=' ')
                 202 ( 4161)   then endpos:=-1;
                 203 ( 4168)   lastpos:=endpos;
                 204 ( 4173) end;
                 205 ( 4181) 
                 206 ( 4182) proc chkline;
                 207 ( 4182) begin
                 208 ( 4182)   if line<1 then line:=1
                 209 ( 4197)   else if line>nlines-1 then line:=nlines-1;
                 210 ( 4227) end;
                 211 ( 4232) 
                 212 ( 4233) proc chktop(show: boolean);
                 213 ( 4233) var savetop,bottom:integer;
                 214 ( 4236) begin
                 215 ( 4236)   savetop:=topline; bottom:=topline+scrlins-1;
                 216 ( 4255)   if line<topline then topline:=line;
                 217 ( 4272)   { keep cursor above bottom line, if possible }
                 218 ( 4280)   if line>=bottom-1 then
                 219 ( 4290)     topline:=line-scrlins+3;
                 220 ( 4304)   if show and (savetop<>topline) then showall;
                 221 ( 4330) end;
                 222 ( 4330) 
                 223 ( 4331) proc delline;
                 224 ( 4331) var i:integer; savpnt:cpnt;
                 225 ( 4334) begin
                 226 ( 4334)   chkline; savpnt:=linepnt[line];
                 227 ( 4344)   if line<mark then mark:=mark-1
                 228 ( 4368)   else if line<mark+nmark then nmark:=nmark-1;
                 229 ( 4401)   for i:=line to nlines-2 do
                 230 ( 4420)     linepnt[i]:=linepnt[i+1];
                 231 ( 4441)   release(savpnt); nlines:=nlines-1;
                 232 ( 4479)   chkline; chktop(false);
                 233 ( 4496)   line:=line-1; savecx:=1;
                 234 ( 4509) end;
                 235 ( 4513) 
                 236 ( 4514) proc join;
                 237 ( 4514) var p,p1,p2,pm:integer;
                 238 ( 4517)     s1,s2:cpnt;
                 239 ( 4517) begin

----------------------------------------------------------------------

R65 Pascal program PEDIT           8/11/23     page 5

                 240 ( 4517)   p1:=lastpos(line-1); p2:=lastpos(line);
                 241 ( 4550)   s1:=linepnt[line-1]; s2:=linepnt[line];
                 242 ( 4573)   for p:=p1+1 to xmax-1 do s1[p]:=s2[p-p1-1];
                 243 ( 4626)   if p1+p2<xmax then delline
                 244 ( 4658)   else begin
                 245 ( 4668)     pm:=xmax-p1;
                 246 ( 4670)     for p:=0 to xmax-pm do s2[+p]:=s2[p+pm-1];
                 247 ( 4721)     for p:=xmax-pm+1 to xmax-1 do s2[p]:=' ';
                 248 ( 4775)     line:=line-1;
                 249 ( 4799)   end;
                 250 ( 4804)   savecx:=p1+2; chkline; chktop(false); showall;
                 251 ( 4831) end;
                 252 ( 4831) 
                 253 ( 4832) func edlin(pnt: cpnt): char;
                 254 ( 4832) const key    = @1;
                 255 ( 4835) var   ch1,lastch: char;
                 256 ( 4835)       exit: boolean;
                 257 ( 4835)       lstart: integer;
                 258 ( 4835) begin
                 259 ( 4835)    goto(savecx,column);
                 260 ( 4853)   if savecx=1 then write(cright,cleft)
                 261 ( 4868)   else write(cleft,cright); {to update cursor}
                 262 ( 4878)   exit:=false; lstart:=column*xmax;
                 263 ( 4892)   repeat
                 264 ( 4897)     read(@key,ch1);
                 265 ( 4905)     lastch:=' ');
                 266 ( 4912)     case ch1 of
                 267 ( 4912)       delchr,rubout: if (curpos=0) and (line>1)
                 268 ( 4942)              then begin
                 269 ( 4944)                updline(pnt,lstart) ;join; exit:=true;
                 270 ( 4967)                end
                 271 ( 4971)              else write(cleft,delchr);
                 272 ( 4980)       cleft: if curpos>0 then write(cleft)
                 273 ( 5001)              else if line>1 then begin
                 274 ( 5012)                updline(pnt,lstart);
                 275 ( 5029)                line:=line-1; curpos:=lastpos(line)+1;
                 276 ( 5054)                exit:=true;
                 277 ( 5061)              end;
                 278 ( 5065)       cright:if curpos<xmax-1 then begin
                 279 ( 5084)                write(cright);
                 280 ( 5090)              end else if line<nlines-1 then begin
                 281 ( 5105)                updline(pnt,lstart);
                 282 ( 5122)                line:=line+1; curpos:=0;
                 283 ( 5135)                exit:=true;
                 284 ( 5141)              end;
                 285 ( 5145)       cup,cdown,esc,cr,rup,rdown,
                 286 ( 5187)       pgup,pgdown,hom,pgend: exit:=true
                 287 ( 5218)       else begin
                 288 ( 5227)              if (ch1>=' ') and (ch1<chr($7f))
                 289 ( 5240)              then begin
                 290 ( 5243)                lastch:=video[lstart+xmax-1];
                 291 ( 5259)                lastch:=chr(ord(lastch) and $7f);
                 292 ( 5272)                if curpos>=xmax-1 then begin
                 293 ( 5286)                  { insert char at last position }
                 294 ( 5289)                  video[lstart+xmax-1]:=ch1;
                 295 ( 5299)                  curpos:=0;
                 296 ( 5312)                  lastch:=cdown;
                 297 ( 5318)                  if line>=nlines-1 then newline;
                     ^
                *** (1,5335)   Ident unknown
Continue?

----------------------------------------------------------------------

R65 Pascal program PEDIT           8/11/23     page 6

                