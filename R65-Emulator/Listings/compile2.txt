
R65 COMPILE 4.4: program COMPILE2         1/3/26 page 1


   1 (    4) 
   2 (    4) {   ********************************
   3 (    4)     *                              *
   4 (    4)     *  R65 "Tiny" Pascal Compiler  *
   5 (    4)     *      Pass 2  (Loader)        *
   6 (    4)     *                              *
   7 (    4)     ********************************
   8 (    4) 
   9 (    4) First version 19978 by rricharz
  10 (    4) Original version 3.1  01/08/82 rricharz
  11 (    4) 
  12 (    4) Recovered 2018 by rricharz (r77@bluewin.ch)
  13 (    4) 
  14 (    4) Original derived from the publication by
  15 (    4) Kin-Man Chung and Herbert Yen in
  16 (    4) Byte, Volume 3, Number 9 and Number 10, 1978
  17 (    4) 
  18 (    4) Adapted for the R65 computer system and
  19 (    4) substantially enhanced by rricharz 1978-1982
  20 (    4) 
  21 (    4) usage:
  22 (    4)  compile2 name[.cy[,drv]]
  23 (    4)   [] means not required                    }
  24 (    4) 
  25 (    4) program compile2;
  26 (    4) uses syslib,arglib,disklib;
  27 ( 1369) 
  28 ( 1369) const
  29 ( 1369)     title='R65 PASCAL COMPILER Version 4.2, Pass 2';
  30 ( 1412)     wrfile=$e81b;
  31 ( 1412)     sblock=$6000;
  32 ( 1412)     eblock=topmem;
  33 ( 1412) 
  34 ( 1412) mem endstk=$e,
  35 ( 1412)     stprog=$11: integer;
  36 ( 1412)     filerr=$db: integer&;
  37 ( 1412)     filsa=$031a,
  38 ( 1412)     filea=$031c,
  39 ( 1412)     filsa1=$0331: integer;
  40 ( 1412)     filtyp=$0300: char&;
  41 ( 1412) 
  42 ( 1412) var pointer,address,maxsize,dummy,
  43 ( 1412)     scyclus,sdrive,offset,cdrive: integer;
  44 ( 1412)     ch: char;
  45 ( 1412)     source: file;
  46 ( 1412)     stop,def: boolean;
  47 ( 1412)     name: array[15] of char;
  48 ( 1412) 
  49 ( 1412) 
  50 ( 1412) { * error * }
  51 ( 1412) 
  52 ( 1412) proc error(x:integer);
  53 ( 1412) 
  54 ( 1412) mem runerr=$0c: integer&;
  55 ( 1415) 
  56 ( 1415) begin
  57 ( 1415)   writeln;
  58 ( 1417)   write('*** ');
  59 ( 1428)   if x<100 then {file error, bcd}

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE2         1/3/26 page 2

  60 ( 1435)     writeln('File error ',(x shr 4),(x and 15))
  61 ( 1465)   else
  62 ( 1472)     case x of
  63 ( 1475)       101: writeln('Program too long');
  64 ( 1509)       102: writeln('Data input format ',ch);
  65 ( 1549)       105: writeln('Wrong address');
  66 ( 1579)       106: writeln('Unexpected eof');
  67 ( 1610)       107: writeln('Pointer not matching')
  68 ( 1641)       else writeln('Unknown error ',x)
  69 ( 1665)     end {case}
  70 ( 1678)   close(source);
  71 ( 1684)   runerr:=x;
  72 ( 1684)   abort;
  73 ( 1696) end {error};
  74 ( 1696) 
  75 ( 1697) 
  76 ( 1697) { * testerror * }
  77 ( 1697) 
  78 ( 1697) proc testerr;
  79 ( 1697) 
  80 ( 1697) var i: integer;
  81 ( 1700) 
  82 ( 1700) begin
  83 ( 1700)   if filerr<>0 then error(filerr)
  84 ( 1714) end;
  85 ( 1720) 
  86 ( 1721) 
  87 ( 1721) { * blocksave * }
  88 ( 1721) 
  89 ( 1721) proc blocksave(lowlim,highlim: integer);
  90 ( 1721) 
  91 ( 1721) var i: integer;
  92 ( 1724) 
  93 ( 1724) begin
  94 ( 1724)   asetfile(name,scyclus,sdrive,'R');
  95 ( 1748)   filsa:=lowlim;
  96 ( 1748)   filea:=highlim;
  97 ( 1756)   filsa1:=lowlim;
  98 ( 1764)   filtyp:='B';
  99 ( 1774)   call(wrfile);
 100 ( 1783)   testerr
 101 ( 1783) end {blocksave};
 102 ( 1787) 
 103 ( 1788) 
 104 ( 1788) { * init * }
 105 ( 1788) 
 106 ( 1788) proc init; {initialize program}
 107 ( 1788) 
 108 ( 1788) var i: integer;
 109 ( 1791)     default: boolean;
 110 ( 1791) 
 111 ( 1791) begin
 112 ( 1791)   cdrive:=fildrv; { drive of compile program }
 113 ( 1800)   endstk:=sblock-144;   {reserve memory }
 114 ( 1809)   writeln;
 115 ( 1809)   writeln(title);
 116 ( 1826)   scyclus:=0; sdrive:=1;
 117 ( 1834)   agetstring(name,default,scyclus,sdrive);
 118 ( 1878)   asetfile(name,scyclus,sdrive,'Q');
 119 ( 1900)   openr(source);

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE2         1/3/26 page 3

 120 ( 1906)   writeln;
 121 ( 1906)   scyclus:=filcyc;
 122 ( 1916) end {init};
 123 ( 1920) 
 124 ( 1921) 
 125 ( 1921) { * getbyte1 * }
 126 ( 1921) 
 127 ( 1921) func getbyte1: integer;
 128 ( 1921) 
 129 ( 1921) var byte: integer;
 130 ( 1924) 
 131 ( 1924) begin
 132 ( 1924)   if (ch<'0') or (ch>'@') then error(102);
 133 ( 1952)   byte:=(ord(ch) and 15) shl 4;
 134 ( 1961)   read(@source,ch);
 135 ( 1976)   if (ch<'0') or (ch>'@') then error(102);
 136 ( 2003)   byte:=byte + ((ord(ch) and 15));
 137 ( 2014)   getbyte1:=byte;
 138 ( 2019)   { heartbeat: }
 139 ( 2027)   if (pointer and 63)=0 then write('.');
 140 ( 2042) end {getbyte1};
 141 ( 2042) 
 142 ( 2043) 
 143 ( 2043) { * getbyte2 * }
 144 ( 2043) 
 145 ( 2043) func getbyte2: integer;
 146 ( 2043) begin
 147 ( 2043)   read(@source,ch); getbyte2:=getbyte1
 148 ( 2059) end {getbyte2};
 149 ( 2069) 
 150 ( 2070) 
 151 ( 2070) { * getbl * }
 152 ( 2070) 
 153 ( 2070) proc getbl(base:integer);  {get block }
 154 ( 2070) 
 155 ( 2070)   proc getlib; {get library }
 156 ( 2073) 
 157 ( 2073)   var i: integer;
 158 ( 2076)       savsr: file;
 159 ( 2076)       ch1: char;
 160 ( 2076)       lname: array[7] of char;
 161 ( 2076)       lcyclus,ldrive: integer;
 162 ( 2076) 
 163 ( 2076)   begin
 164 ( 2076)     savsr:=source;
 165 ( 2078)     for i:=0 to 7 do begin
 166 ( 2103)       read(@source,ch1);
 167 ( 2113)       lname[i]:=ch1
 168 ( 2118)     end;
 169 ( 2126)     lcyclus:=0; ldrive:=cdrive;
 170 ( 2146)     write('Loading library ');
 171 ( 2171)     prtext8(output,lname);
 172 ( 2185)     { loading library from same drive }
 173 ( 2185)     { as program compile2 }
 174 ( 2185)     asetfile(lname&'        ',
 175 ( 2201)       lcyclus,ldrive,'T');
 176 ( 2217)     openr(source);
 177 ( 2223)     getbl(offset-2);
 178 ( 2236)     close(source);
 179 ( 2242)     source:=savsr;

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE2         1/3/26 page 4

 180 ( 2242)     if (pointer+4-sblock)>maxsize then
 181 ( 2261)       error(101);
 182 ( 2277)     mem[pointer-1]:=43;
 183 ( 2286)     mem[pointer]:=0;
 184 ( 2293)     mem[pointer+1]:=3;
 185 ( 2303)     mem[pointer+2]:=0;
 186 ( 2313)     mem[pointer+3]:=0;
 187 ( 2323)     pointer:=pointer+4;
 188 ( 2330)     offset:=pointer-sblock;
 189 ( 2342)     writeln;
 190 ( 2347)     writeln('Library loaded')
 191 ( 2368)   end {getlib};
 192 ( 2374) 
 193 ( 2375) 
 194 ( 2375) begin { * body of getbl * }
 195 ( 2375)   stop:=false;
 196 ( 2379)   repeat
 197 ( 2383)     read(@source,ch);
 198 ( 2393)     case ch of
 199 ( 2394) 
 200 ( 2398)       'F':  begin {fixup}
 201 ( 2405)               address:=getbyte2+
 202 ( 2411)                   (getbyte2 shl 8)+offset;
 203 ( 2421)               if (address<offset) or
 204 ( 2439)                   (address>maxsize) then begin
 205 ( 2449)                 writeln;
 206 ( 2452)                 write(address,' ',offset);
 207 ( 2470)                 error(105);
 208 ( 2478)               end;
 209 ( 2478)               mem[address+sblock]:=getbyte2;
 210 ( 2492)               mem[address+sblock+1]:=getbyte2;
 211 ( 2510)             end {fixup};
 212 ( 2511) 
 213 ( 2514)       'L':  getlib;
 214 ( 2525) 
 215 ( 2528)       'E':  stop:=true;
 216 ( 2537) 
 217 ( 2544)       eof:  error(106)
 218 ( 2553) 
 219 ( 2559)       else begin {data}
 220 ( 2562)         mem[pointer]:=getbyte1;
 221 ( 2572)         pointer:=pointer+1;
 222 ( 2579)         if (pointer-sblock)>maxsize then
 223 ( 2592)           error(101);
 224 ( 2608)       end {data}
 225 ( 2608)     end {case};
 226 ( 2610)   until stop;
 227 ( 2610)   stop:=false;
 228 ( 2619)   mem[sblock]:=(pointer-sblock) and 255;
 229 ( 2636)   mem[sblock+1]:=(pointer-sblock) shr 8;
 230 ( 2654)   address:=getbyte2+(getbyte2 shl 8)+base;
 231 ( 2672)   if address<>(pointer-sblock) then begin
 232 ( 2694)     writeln(address,' ',pointer-sblock);
 233 ( 2719)     error(107)
 234 ( 2721)   end
 235 ( 2727) end {getbl};
 236 ( 2727) 
 237 ( 2728) { show used bytes }
 238 ( 2728) 
 239 ( 2728) proc showused;

----------------------------------------------------------------------

R65 COMPILE 4.4: program COMPILE2         1/3/26 page 5

 240 ( 2728) var usedbytes, maxbytes,
 241 ( 2731)     usedpages, maxpages: integer;
 242 ( 2731) begin
 243 ( 2731)   usedbytes := pointer - sblock;
 244 ( 2740)   maxbytes  := maxsize + 2;
 245 ( 2751) 
 246 ( 2756)   usedpages := (usedbytes + 255) div 256;
 247 ( 2766)   maxpages  := (maxbytes  + 255) div 256;
 248 ( 2781) 
 249 ( 2786)   writeln('Load area used: ', usedpages, '/',
 250 ( 2810)     maxpages, ' pages (',
 251 ( 2824)     usedbytes, '/', maxbytes, ' bytes)');
 252 ( 2850) end;
 253 ( 2850) 
 254 ( 2851) { * main * }
 255 ( 2851) 
 256 ( 2851) begin {main}
 257 ( 2851)   init; maxsize:=eblock-sblock-2;
 258 ( 2866)   pointer:=sblock+2; offset:=2;
 259 ( 2883)   getbl(0);
 260 ( 2895)   mem[pointer-1]:=0;
 261 ( 2904)   mem[pointer]:=255;
 262 ( 2911)   mem[pointer+1]:=255;
 263 ( 2921)   pointer:=pointer+1;
 264 ( 2928)   close(source);
 265 ( 2939)   writeln;
 266 ( 2939)   showused;
 267 ( 2949)   blocksave(sblock,pointer);
 268 ( 2962)   writeln('Program has been stored');
 269 ( 2992)   endstk:=topmem-144;
 270 ( 2997)   dummy:=freedsk(sdrive,true);
 271 ( 3015) end.
 272 ( 3019) 

End compile

Code lenght:          3018
Compiler stack size:  54
Ident stack size:     113
Pascal errors:        0
