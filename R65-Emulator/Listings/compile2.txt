
R65 Pascal program COMPILE2        5/11/23     page 1


                   1 (    4) 
                   2 (    4) {   ********************************
                   3 (    4)     *                              *
                   4 (    4)     *  R65 "Tiny" Pascal Compiler  *
                   5 (    4)     *      Pass 2  (Loader)        *
                   6 (    4)     *                              *
                   7 (    4)     ********************************
                   8 (    4) 
                   9 (    4) First version 19978 by rricharz
                  10 (    4) Current version 3.1  01/08/82 rricharz
                  11 (    4) 
                  12 (    4) Recovered 2018 by rricharz (r77@bluewin.ch)
                  13 (    4) 
                  14 (    4) Original derived from the publication by
                  15 (    4) Kin-Man Chung and Herbert Yen in
                  16 (    4) Byte, Volume 3, Number 9 and Number 10, 1978
                  17 (    4) 
                  18 (    4) Adapted for the R65 computer system and
                  19 (    4) substantially enhanced by rricharz 1978-1982
                  20 (    4) 
                  21 (    4) usage:
                  22 (    4)  compile2 name[.cy[,drv]]
                  23 (    4)   [] means not required                    }
                  24 (    4) 
                  25 (    4) program compile2;
                  26 (    4) uses syslib,arglib;
                  27 ( 1093) 
                  28 ( 1093) const wrfile=$e81b;
                  29 ( 1096)       sblock=$5000;
                  30 ( 1096)       eblock=topmem;
                  31 ( 1096) 
                  32 ( 1096) mem endstk=$e,
                  33 ( 1096)     stprog=$11: integer;
                  34 ( 1096)     filerr=$db: integer&;
                  35 ( 1096)     filsa=$031a,
                  36 ( 1096)     filea=$031c,
                  37 ( 1096)     filsa1=$0331: integer;
                  38 ( 1096)     filtyp=$0300: char&;
                  39 ( 1096) 
                  40 ( 1096) var pointer,address,exit,maxsize,
                  41 ( 1096)     scyclus,sdrive,offset,cdrive: integer;
                  42 ( 1096)     ch: char;
                  43 ( 1096)     source: file;
                  44 ( 1096)     exit,def: boolean;
                  45 ( 1096)     name: array[15] of char;
                  46 ( 1096) 
                  47 ( 1096) 
                  48 ( 1096) { * error * }
                  49 ( 1096) 
                  50 ( 1096) proc error(x:integer);
                  51 ( 1096) 
                  52 ( 1096) mem runerr=$0c: integer&;
                  53 ( 1099) 
                  54 ( 1099) begin
                  55 ( 1099)   writeln;
                  56 ( 1101)   write('*** ');
                  57 ( 1112)   if x<100 then {file error, bcd}
                  58 ( 1119)     writeln('File error ',(x shr 4),(x and 15))
                  59 ( 1149)   else

----------------------------------------------------------------------

R65 Pascal program COMPILE2        5/11/23     page 2

                  60 ( 1156)     case x of
                  61 ( 1159)       101: writeln('Program too long');
                  62 ( 1193)       102: writeln('Data input format ',ch);
                  63 ( 1233)       105: writeln('Wrong address');
                  64 ( 1263)       106: writeln('Unexpected eof');
                  65 ( 1294)       107: writeln('Pointer not matching')
                  66 ( 1325)       else writeln('Unknown error ',x)
                  67 ( 1349)     end {case}
                  68 ( 1362)   close(source);
                  69 ( 1368)   runerr:=x;
                  70 ( 1368)   abort;
                  71 ( 1380) end {error};
                  72 ( 1380) 
                  73 ( 1381) 
                  74 ( 1381) { * testerror * }
                  75 ( 1381) 
                  76 ( 1381) proc testerr;
                  77 ( 1381) 
                  78 ( 1381) var i: integer;
                  79 ( 1384) 
                  80 ( 1384) begin
                  81 ( 1384)   if filerr<>0 then error(filerr)
                  82 ( 1398) end;
                  83 ( 1404) 
                  84 ( 1405) 
                  85 ( 1405) { * blocksave * }
                  86 ( 1405) 
                  87 ( 1405) proc blocksave(lowlim,highlim: integer);
                  88 ( 1405) 
                  89 ( 1405) var i: integer;
                  90 ( 1408) 
                  91 ( 1408) begin
                  92 ( 1408)   asetfile(name,scyclus,sdrive,'R');
                  93 ( 1432)   filsa:=lowlim;
                  94 ( 1432)   filea:=highlim;
                  95 ( 1440)   filsa1:=lowlim;
                  96 ( 1448)   filtyp:='B';
                  97 ( 1458)   call(wrfile);
                  98 ( 1467)   testerr
                  99 ( 1467) end {blocksave};
                 100 ( 1471) 
                 101 ( 1472) 
                 102 ( 1472) { * init * }
                 103 ( 1472) 
                 104 ( 1472) proc init; {initialize program}
                 105 ( 1472) 
                 106 ( 1472) var i: integer;
                 107 ( 1475)     default: boolean;
                 108 ( 1475) 
                 109 ( 1475) begin
                 110 ( 1475)   cdrive:=fildrv; { drive of compile program }
                 111 ( 1484)   endstk:=sblock-144;   {reserve memory }
                 112 ( 1493)   writeln;
                 113 ( 1493)   writeln(tab8,'-- R65 Pascal Compiler --');
                 114 ( 1534)   writeln(tab8,'   Pass 2  Version 3.1');
                 115 ( 1566)   scyclus:=0; sdrive:=1;
                 116 ( 1574)   agetstring(name,default,scyclus,sdrive);
                 117 ( 1618)   asetfile(name,scyclus,sdrive,'Q');
                 118 ( 1640)   openr(source);
                 119 ( 1646)   writeln;

----------------------------------------------------------------------

R65 Pascal program COMPILE2        5/11/23     page 3

                 120 ( 1646)   scyclus:=filcyc;
                 121 ( 1656) end {init};
                 122 ( 1660) 
                 123 ( 1661) 
                 124 ( 1661) { * getbyte1 * }
                 125 ( 1661) 
                 126 ( 1661) func getbyte1: integer;
                 127 ( 1661) 
                 128 ( 1661) var byte: integer;
                 129 ( 1664) 
                 130 ( 1664) begin
                 131 ( 1664)   if (ch<'0') or (ch>'@') then error(102);
                 132 ( 1692)   byte:=(ord(ch) and 15) shl 4;
                 133 ( 1701)   read(@source,ch);
                 134 ( 1716)   if (ch<'0') or (ch>'@') then error(102);
                 135 ( 1743)   byte:=byte + ((ord(ch) and 15));
                 136 ( 1754)   getbyte1:=byte;
                 137 ( 1759)   { heartbeat: }
                 138 ( 1767)   if (pointer and 63)=0 then write('.');
                 139 ( 1782) end {getbyte1};
                 140 ( 1782) 
                 141 ( 1783) 
                 142 ( 1783) { * getbyte2 * }
                 143 ( 1783) 
                 144 ( 1783) func getbyte2: integer;
                 145 ( 1783) begin
                 146 ( 1783)   read(@source,ch); getbyte2:=getbyte1
                 147 ( 1799) end {getbyte2};
                 148 ( 1809) 
                 149 ( 1810) 
                 150 ( 1810) { * getbl * }
                 151 ( 1810) 
                 152 ( 1810) proc getbl(base:integer);  {get block }
                 153 ( 1810) 
                 154 ( 1810)   proc getlib; {get library }
                 155 ( 1813) 
                 156 ( 1813)   var i: integer;
                 157 ( 1816)       savsr: file;
                 158 ( 1816)       ch1: char;
                 159 ( 1816)       lname: array[7] of char;
                 160 ( 1816)       lcyclus,ldrive: integer;
                 161 ( 1816) 
                 162 ( 1816)   begin
                 163 ( 1816)     savsr:=source;
                 164 ( 1818)     for i:=0 to 7 do begin
                 165 ( 1843)       read(@source,ch1);
                 166 ( 1853)       lname[i]:=ch1
                 167 ( 1858)     end;
                 168 ( 1866)     lcyclus:=0; ldrive:=cdrive;
                 169 ( 1886)     write('Loading library ');
                 170 ( 1911)     prtext8(output,lname);
                 171 ( 1925)     { loading library from same drive }
                 172 ( 1925)     { as program compile2 }
                 173 ( 1925)     asetfile(lname&'        ',
                 174 ( 1941)       lcyclus,ldrive,'T');
                 175 ( 1957)     openr(source);
                 176 ( 1963)     getbl(offset-2);
                 177 ( 1976)     close(source);
                 178 ( 1982)     source:=savsr;
                 179 ( 1982)     if (pointer+4-sblock)>maxsize then

----------------------------------------------------------------------

R65 Pascal program COMPILE2        5/11/23     page 4

                 180 ( 2001)       error(101);
                 181 ( 2017)     mem[pointer-1]:=43;
                 182 ( 2026)     mem[pointer]:=0;
                 183 ( 2033)     mem[pointer+1]:=3;
                 184 ( 2043)     mem[pointer+2]:=0;
                 185 ( 2053)     mem[pointer+3]:=0;
                 186 ( 2063)     pointer:=pointer+4;
                 187 ( 2070)     offset:=pointer-sblock;
                 188 ( 2082)     writeln('Library loaded')
                 189 ( 2102)   end {getlib};
                 190 ( 2108) 
                 191 ( 2109) 
                 192 ( 2109) begin { * body of getbl * }
                 193 ( 2109)   exit:=false;
                 194 ( 2113)   repeat
                 195 ( 2117)     read(@source,ch);
                 196 ( 2127)     case ch of
                 197 ( 2128) 
                 198 ( 2132)       'F':  begin {fixup}
                 199 ( 2139)               address:=getbyte2+
                 200 ( 2145)                   (getbyte2 shl 8)+offset;
                 201 ( 2155)               if (address<offset) or
                 202 ( 2173)                   (address>maxsize) then begin
                 203 ( 2183)                 writeln;
                 204 ( 2186)                 write(address,' ',offset);
                 205 ( 2204)                 error(105);
                 206 ( 2212)               end;
                 207 ( 2212)               mem[address+sblock]:=getbyte2;
                 208 ( 2226)               mem[address+sblock+1]:=getbyte2;
                 209 ( 2244)             end {fixup};
                 210 ( 2245) 
                 211 ( 2248)       'L':  getlib;
                 212 ( 2259) 
                 213 ( 2262)       'E':  exit:=true;
                 214 ( 2271) 
                 215 ( 2278)       eof:  error(106)
                 216 ( 2287) 
                 217 ( 2293)       else begin {data}
                 218 ( 2296)         mem[pointer]:=getbyte1;
                 219 ( 2306)         pointer:=pointer+1;
                 220 ( 2313)         if (pointer-sblock)>maxsize then
                 221 ( 2326)           error(101);
                 222 ( 2342)       end {data}
                 223 ( 2342)     end {case};
                 224 ( 2344)   until exit;
                 225 ( 2344)   exit:=false;
                 226 ( 2353)   mem[sblock]:=(pointer-sblock) and 255;
                 227 ( 2370)   mem[sblock+1]:=(pointer-sblock) shr 8;
                 228 ( 2388)   address:=getbyte2+(getbyte2 shl 8)+base;
                 229 ( 2406)   if address<>(pointer-sblock) then begin
                 230 ( 2428)     writeln(address,' ',pointer-sblock);
                 231 ( 2453)     error(107)
                 232 ( 2455)   end
                 233 ( 2461) end {getbl};
                 234 ( 2461) 
                 235 ( 2462) 
                 236 ( 2462) { * main * }
                 237 ( 2462) 
                 238 ( 2462) begin {main}
                 239 ( 2462)   init; maxsize:=eblock-sblock-2;

----------------------------------------------------------------------

R65 Pascal program COMPILE2        5/11/23     page 5

                 240 ( 2477)   pointer:=sblock+2; offset:=2;
                 241 ( 2494)   getbl(0);
                 242 ( 2506)   mem[pointer-1]:=0;
                 243 ( 2515)   mem[pointer]:=255;
                 244 ( 2522)   mem[pointer+1]:=255;
                 245 ( 2532)   pointer:=pointer+1;
                 246 ( 2539)   close(source);
                 247 ( 2550)   writeln;
                 248 ( 2550)   blocksave(sblock,pointer);
                 249 ( 2569)   writeln('Program has been stored');
                 250 ( 2599)   endstk:=topmem-144;
                 251 ( 2604) end.
                 252 ( 2608) 

End compile

Code lenght:          2607
Compiler stack size:  51
Ident stack size:     109
Pascal errors:        0
