
R65 COMPILE 4.2: program STRLIB           14/11/23 page 1


   1 (    4) { ************************************
   2 (    4)   *  strlib: handling cpnt pointers  *
   3 (    4)   ************************************
   4 (    4) 
   5 (    4) type cpnt are pointers to strings of
   6 (    4) 0 delimited strings of up to 64 characters }
   7 (    4) 
   8 (    4) library strlib;
   9 (    4) 
  10 (    4) const strsize=64;
  11 (    7)       endmark=chr(0);
  12 (    7) 
  13 (    7) { ***** strnew: allocate heap memory for cpnt ***** }
  14 (    7) 
  15 (    7) func strnew:cpnt;
  16 (    7) const stopcode = $2010;
  17 (   10)         mem   endstk = $000e: integer;
  18 (   10)       runerr = $000c: integer&;
  19 (   10)       sp     = $0008: integer;
  20 (   10) var freewords,i:integer;
  21 (   10)     str:cpnt;
  22 (   10) begin
  23 (   10)   { Pascal has no type unsigned integer. }
  24 (   10)   { But the free space can be larger than 32767 }
  25 (   10)   { We work therefore with free words here }
  26 (   10)   freewords:=(endstk-sp) shr 1;
  27 (   21)   if freewords < (strsize + 256) then begin
  28 (   37)     { 256 words are left for the growing stack }
  29 (   40)     runerr:=$88;
  30 (   42)     call(stopcode);
  31 (   50)   end;
  32 (   50)   { allocate heap memory }
  33 (   50)   endstk:=endstk-strsize;
  34 (   55)   str:=cpnt(endstk);
  35 (   62)   { initialize the string }
  36 (   66)   str[0]:=endmark;
  37 (   70)   strnew:=str;
  38 (   74) end;
  39 (   82) 
  40 (   83) { ***** strlen: length of string ***** }
  41 (   83) 
  42 (   83) func strlen(strin:cpnt):integer;
  43 (   83) var i:integer;
  44 (   86) begin
  45 (   86)   i:=0;
  46 (   90)   while (strin[i]<>endmark) and (i<strsize) do
  47 (  114)     i:=succ(i);
  48 (  122)   strlen:=i;
  49 (  130) end;
  50 (  138) 
  51 (  139) { ***** strcopy: copy cpnt string ***** }
  52 (  139) 
  53 (  139) proc strcpy(strin, strout:cpnt);
  54 (  139) var i: integer;
  55 (  142) begin
  56 (  142)   i:=0;
  57 (  146)   while (strin[i]<>endmark)
  58 (  162)                 and (i<strsize-2) do begin
  59 (  177)     strout[i]:=strin[i];

----------------------------------------------------------------------

R65 COMPILE 4.2: library STRLIB           14/11/23 page 2

  60 (  189)     i:=succ(i);
  61 (  199)   end;
  62 (  204)   strout[i]:=endmark;
  63 (  213) end;
  64 (  217) 
  65 (  218) { **** stradd: add string to string ***** }
  66 (  218) 
  67 (  218) proc stradd(strin,strinout:cpnt);
  68 (  218) var i,j:integer;
  69 (  221) begin
  70 (  221)     i:=strlen(strinout); j:=0;
  71 (  241)     while (strin[j]<>endmark)
  72 (  257)                 and (i<prec(strsize)) do begin
  73 (  270)       strinout[i]:=strin[j];
  74 (  282)       i:=succ(i); j:=succ(j);
  75 (  301)     end;
  76 (  306)     strinout[i]:=endmark;
  77 (  315) end;
  78 (  319) 
  79 (  320) { **** strcmp: compare two strings **** }
  80 (  320) { returns -1  if s1<s2
  81 (  320)            0  if s1=s2
  82 (  320)            1  if s1>s2                  }
  83 (  320) 
  84 (  320) func strcmp(s1,s2:cpnt):integer;
  85 (  320) var i:integer;
  86 (  323) begin
  87 (  323)   { find first difference or end of string }
  88 (  323)   i:=0;
  89 (  327)   while (s1[i]<>endmark) and (s1[i]=s2[i])
  90 (  362)     and (i<strsize) do i:=succ(i);
  91 (  381)   if s1[i]=s2[i] then strcmp:=0
  92 (  413)   else if s1[i]>s2[i] then strcmp:=1
  93 (  446)   else strcmp:=-1;
  94 (  457) end;
  95 (  462) 
  96 (  463) { **** strpos: find occurance of char **** }
  97 (  463) { returns -1 if char not found }
  98 (  463) func strpos(ch:char; s1:cpnt; start:integer): integer;
  99 (  463) var i,len: integer;
 100 (  466) begin
 101 (  466)   len:=strlen(s1);
 102 (  480)   if start>=len then strpos:=-1
 103 (  496)   else  begin
 104 (  506)     i:=start;
 105 (  506)     while (i<len) and (s1[i]<>ch) do i:=succ(i);
 106 (  546)     if s1[i]=ch then strpos:=i
 107 (  572)     else strpos:=-1;
 108 (  585)   end;
 109 (  590) end;
 110 (  590) 
 111 (  591) { **** strread: read string from input }
 112 (  591) { returns the number of chars read }
 113 (  591) 
 114 (  591) func strread(f: file; s: cpnt): integer;
 115 (  591) var i: integer;
 116 (  594)     ch: char;
 117 (  594) begin
 118 (  594)   i:=-1;
 119 (  598)   repeat

----------------------------------------------------------------------

R65 COMPILE 4.2: library STRLIB           14/11/23 page 3

 120 (  603)     i:=succ(i);
 121 (  607)     read(@f,ch);
 122 (  622)     s[i]:=ch;
 123 (  627)     until (ch=chr($d)) or (ch=chr($1f)) or
 124 (  651)       (ch=chr($7f)) or (ch=chr(0)) or (i>=strsize-1);
 125 (  680)   s[i]:=chr(0);
 126 (  690)   strread:=i;
 127 (  695) end;
 128 (  703) 
 129 (  704) { **** intstr: convert integer to string **** }
 130 (  704) { right justified in a field of 6 chars }
 131 (  704) 
 132 (  704) proc intstr(n:integer;s:cpnt;fsize:integer);
 133 (  704) var pos,n0,n1:integer;
 134 (  707)     isneg:boolean;
 135 (  707) begin
 136 (  707)   pos:=fsize-1; n0:=n; isneg:=false;
 137 (  730)   if (n0<0) then begin
 138 (  741)     isneg:=true; n0:=-n0;
 139 (  750)   end;
 140 (  759)   s[pos+1]:=chr(0); { end mark }
 141 (  773)   repeat
 142 (  773)     { avoid 2nd division for mod }
 143 (  773)     n1:=n0 div 10;
 144 (  779)     s[pos]:=chr(n0-10*n1+ord('0'));
 145 (  803)     n0:=n1; pos:=pos-1;
 146 (  822)     until (n0=0) or (pos<0);
 147 (  841)   if (n0<>0) or (isneg and (pos<0)) then begin
 148 (  865)     for pos:=0 to fsize-1 do s[pos]:=chr($23);
 149 (  896)   end else begin
 150 (  918)     if isneg then begin
 151 (  922)       s[pos]:='-'; pos:=pos-1;
 152 (  941)     end;
 153 (  946)     while pos>=0 do begin
 154 (  956)       s[pos]:=' '; pos:=pos-1;
 155 (  972)     end;
 156 (  977)   end;
 157 (  980) end;
 158 (  980) 
 159 (  981) { hexstr: convert hex byte to hex string }
 160 (  981) 
 161 (  981) proc hexstr(d:integer; s:cpnt);
 162 (  981)   func hchar(h:integer):char;
 163 (  984)   begin
 164 (  984)     if h<10 then hchar:=chr(h+ord('0'))
 165 ( 1005)     else hchar:=chr(h-10+ord('A'));
 166 ( 1024)   end;
 167 ( 1029) begin
 168 ( 1030)   s[0]:=hchar((d shr 4) and 15);
 169 ( 1052)   s[1]:=hchar(d and 15);
 170 ( 1073)   s[2]:=chr(0);
 171 ( 1081) end;
 172 ( 1086) 
 173 ( 1087) { *** strinsc: insert char into string *** }
 174 ( 1087) { inserts char if string is short enough }
 175 ( 1087) 
 176 ( 1087) proc strinsc(ch:char;pos:integer;s:cpnt);
 177 ( 1087) var i,l:integer;
 178 ( 1090) begin
 179 ( 1090)   l:=strlen(s);

----------------------------------------------------------------------

R65 COMPILE 4.2: library STRLIB           14/11/23 page 4

 180 ( 1104)   if (l<strsize-1) and (pos>=0)
 181 ( 1124)     and (pos<strsize-1) then begin
 182 ( 1137)     for i:=l downto pos do
 183 ( 1148)       { move includes end mark }
 184 ( 1161)       s[i+1]:=s[i];
 185 ( 1176)     if pos > l then begin
 186 ( 1205)       for i:=l to pos-1 do s[i]:=' ';
 187 ( 1238)       s[pos+1]:=chr(0);
 188 ( 1265)     end;
 189 ( 1270)     s[pos]:=ch;
 190 ( 1274)   end
 191 ( 1282) end;
 192 ( 1282) 
 193 ( 1283) { *** strdelc: delete char in string *** }
 194 ( 1283) 
 195 ( 1283) proc strdelc(pos:integer;s:cpnt);
 196 ( 1283) var i,l:integer;
 197 ( 1286) begin
 198 ( 1286)   l:=strlen(s);
 199 ( 1300)   for i:=pos to l-1 do
 200 ( 1318)       { move includes end mark }
 201 ( 1328)       s[i]:=s[i+1];
 202 ( 1343) end;
 203 ( 1363) 
 204 ( 1364) begin
 205 ( 1364) end.
 206 ( 1366) 

End compile

Code lenght:          1365
Compiler stack size:  32
Ident stack size:     22
Pascal errors:        0
