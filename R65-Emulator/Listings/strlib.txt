
R65 COMPILE 4.2: program STRLIB           6/12/23 page 1


   1 (    4) { ************************************
   2 (    4)   *  strlib: handling cpnt pointers  *
   3 (    4)   ************************************
   4 (    4) 
   5 (    4) type cpnt are pointers to strings of
   6 (    4) 0 delimited strings of up to 64 characters }
   7 (    4) 
   8 (    4) library strlib;
   9 (    4) 
  10 (    4) const strsize=64;
  11 (    7)       endmark=chr(0);
  12 (    7) 
  13 (    7) { ***** strnew: allocate heap memory for cpnt ***** }
  14 (    7) 
  15 (    7) func strnew:cpnt;
  16 (    7) const stopcode = $2010;
  17 (   10)         mem   endstk = $000e: integer;
  18 (   10)       runerr = $000c: integer&;
  19 (   10)       sp     = $0008: integer;
  20 (   10) var freewords,i:integer;
  21 (   10)     str:cpnt;
  22 (   10) begin
  23 (   10)   { Pascal has no type unsigned integer. }
  24 (   10)   { But the free space can be larger than 32767 }
  25 (   10)   { We work therefore with free words here }
  26 (   10)   freewords:=(endstk-sp) shr 1;
  27 (   21)   if freewords < (strsize + 256) then begin
  28 (   37)     { 256 words are left for the growing stack }
  29 (   40)     runerr:=$88;
  30 (   42)     call(stopcode);
  31 (   50)   end;
  32 (   50)   { allocate heap memory }
  33 (   50)   endstk:=endstk-strsize;
  34 (   55)   str:=cpnt(endstk);
  35 (   62)   { initialize the string }
  36 (   66)   str[0]:=endmark;
  37 (   70)   strnew:=str;
  38 (   74) end;
  39 (   82) 
  40 (   83) { ***** strlen: length of string ***** }
  41 (   83) 
  42 (   83) func strlen(strin:cpnt):integer;
  43 (   83) var i:integer;
  44 (   86) begin
  45 (   86)   i:=0;
  46 (   90)   while (strin[i]<>endmark) and (i<strsize) do
  47 (  114)     i:=succ(i);
  48 (  122)   strlen:=i;
  49 (  130) end;
  50 (  138) 
  51 (  139) { ***** strcopy: copy cpnt string ***** }
  52 (  139) 
  53 (  139) proc strcpy(strin, strout:cpnt);
  54 (  139) var i: integer;
  55 (  142) begin
  56 (  142)   strout[0]:=endmark;
  57 (  148)   write(@strout,strin);
  58 (  163) end;
  59 (  163) 

----------------------------------------------------------------------

R65 COMPILE 4.2: library STRLIB           6/12/23 page 2

  60 (  164) { **** stradd: add string to string ***** }
  61 (  164) 
  62 (  164) proc stradd(strin,strinout:cpnt);
  63 (  164) var i,j:integer;
  64 (  167) begin
  65 (  167)   write(@strinout,strin);
  66 (  180) end;
  67 (  180) 
  68 (  181) { **** strcmp: compare two strings **** }
  69 (  181) { returns -1  if s1<s2
  70 (  181)            0  if s1=s2
  71 (  181)            1  if s1>s2                  }
  72 (  181) 
  73 (  181) func strcmp(s1,s2:cpnt):integer;
  74 (  181) var i:integer;
  75 (  184) begin
  76 (  184)   { find first difference or end of string }
  77 (  184)   i:=0;
  78 (  188)   while (s1[i]<>endmark) and (s1[i]=s2[i])
  79 (  223)     and (i<strsize) do i:=succ(i);
  80 (  242)   if s1[i]=s2[i] then strcmp:=0
  81 (  274)   else if s1[i]>s2[i] then strcmp:=1
  82 (  307)   else strcmp:=-1;
  83 (  318) end;
  84 (  323) 
  85 (  324) { **** strpos: find occurance of char **** }
  86 (  324) { returns -1 if char not found }
  87 (  324) func strpos(ch:char; s1:cpnt; start:integer): integer;
  88 (  324) var i,len: integer;
  89 (  327) begin
  90 (  327)   len:=strlen(s1);
  91 (  341)   if start>=len then strpos:=-1
  92 (  357)   else  begin
  93 (  367)     i:=start;
  94 (  367)     while (i<len) and (s1[i]<>ch) do i:=succ(i);
  95 (  407)     if s1[i]=ch then strpos:=i
  96 (  433)     else strpos:=-1;
  97 (  446)   end;
  98 (  451) end;
  99 (  451) 
 100 (  452) { **** strread: read string from input }
 101 (  452) { returns the number of chars read }
 102 (  452) 
 103 (  452) func strread(f: file; s: cpnt): integer;
 104 (  452) var i: integer;
 105 (  455)     ch: char;
 106 (  455) begin
 107 (  455)   i:=-1;
 108 (  459)   repeat
 109 (  464)     i:=succ(i);
 110 (  468)     read(@f,ch);
 111 (  483)     s[i]:=ch;
 112 (  488)     until (ch=chr($d)) or (ch=chr($1f)) or
 113 (  512)       (ch=chr($7f)) or (ch=chr(0)) or (i>=strsize-1);
 114 (  541)   s[i]:=chr(0);
 115 (  551)   strread:=i;
 116 (  556) end;
 117 (  564) 
 118 (  565) { hexstr: convert hex byte to hex string }
 119 (  565) 

----------------------------------------------------------------------

R65 COMPILE 4.2: library STRLIB           6/12/23 page 3

 120 (  565) proc hexstr(d:integer; s:cpnt);
 121 (  565)   func hchar(h:integer):char;
 122 (  568)   begin
 123 (  568)     if h<10 then hchar:=chr(h+ord('0'))
 124 (  589)     else hchar:=chr(h-10+ord('A'));
 125 (  608)   end;
 126 (  613) begin
 127 (  614)   s[0]:=hchar((d shr 4) and 15);
 128 (  636)   s[1]:=hchar(d and 15);
 129 (  657)   s[2]:=chr(0);
 130 (  665) end;
 131 (  670) 
 132 (  671) { *** strinsc: insert char into string *** }
 133 (  671) { inserts char if string is short enough }
 134 (  671) 
 135 (  671) proc strinsc(ch:char;pos:integer;s:cpnt);
 136 (  671) var i,l:integer;
 137 (  674) begin
 138 (  674)   l:=strlen(s);
 139 (  688)   if (l<strsize-1) and (pos>=0)
 140 (  708)     and (pos<strsize-1) then begin
 141 (  721)     for i:=l downto pos do
 142 (  732)       { move includes end mark }
 143 (  745)       s[i+1]:=s[i];
 144 (  760)     if pos > l then begin
 145 (  789)       for i:=l to pos-1 do s[i]:=' ';
 146 (  822)       s[pos+1]:=chr(0);
 147 (  849)     end;
 148 (  854)     s[pos]:=ch;
 149 (  858)   end
 150 (  866) end;
 151 (  866) 
 152 (  867) { *** strdelc: delete char in string *** }
 153 (  867) 
 154 (  867) proc strdelc(pos:integer;s:cpnt);
 155 (  867) var i,l:integer;
 156 (  870) begin
 157 (  870)   l:=strlen(s);
 158 (  884)   for i:=pos to l-1 do
 159 (  902)       { move includes end mark }
 160 (  912)       s[i]:=s[i+1];
 161 (  927) end;
 162 (  947) 
 163 (  948) { **** intstr: convert integer to string **** }
 164 (  948) { right justified in a field of 6 chars }
 165 (  948) 
 166 (  948) proc intstr(n:integer;s:cpnt;fsize:integer);
 167 (  948) begin
 168 (  948)   s[0]:=endmark;
 169 (  957)   write(@s,n);
 170 (  972)   while strlen(s)<fsize do strinsc(' ',0,s);
 171 ( 1006) end;
 172 ( 1009) 
 173 ( 1010) begin
 174 ( 1010) end.
 175 ( 1012) 

End compile

Code lenght:          1011
Compiler stack size:  32
Ident stack size:     21
Pascal errors:        0
