
R65 Pascal program STRLIB          4/11/23     page 1


                   1 (    4) { ************************************
                   2 (    4)   *  strlib: handling cpnt pointers  *
                   3 (    4)   ************************************
                   4 (    4) 
                   5 (    4) type cpnt are pointers to strings of
                   6 (    4) 0 delimited strings of up to 64 characters }
                   7 (    4) 
                   8 (    4) library strlib;
                   9 (    4) 
                  10 (    4) const strsize=64;
                  11 (    7)       endmark=chr(0);
                  12 (    7) 
                  13 (    7) { ***** strnew: allocate heap memory for cpnt ***** }
                  14 (    7) 
                  15 (    7) func strnew:cpnt;
                  16 (    7) const stopcode = $2010;
                  17 (   10)         mem   endstk = $000e: integer;
                  18 (   10)       runerr = $000c: integer&;
                  19 (   10)       sp     = $0008: integer;
                  20 (   10) var freewords,i:integer;
                  21 (   10)     str:cpnt;
                  22 (   10) begin
                  23 (   10)   { Pascal has no type unsigned integer. }
                  24 (   10)   { But the free space can be larger than 32767 }
                  25 (   10)   { We work therefore with free words here }
                  26 (   10)   freewords:=(endstk-sp) shr 1;
                  27 (   21)   if freewords < (strsize + 256) then begin
                  28 (   37)     { 256 words are left for the growing stack }
                  29 (   40)     runerr:=$88;
                  30 (   42)     call(stopcode);
                  31 (   50)   end;
                  32 (   50)   { allocate heap memory }
                  33 (   50)   endstk:=endstk-strsize;
                  34 (   55)   str:=cpnt(endstk);
                  35 (   62)   { initialize the string }
                  36 (   66)   str[0]:=endmark;
                  37 (   70)   strnew:=str;
                  38 (   74) end;
                  39 (   82) 
                  40 (   83) { ***** strlen: length of string ***** }
                  41 (   83) 
                  42 (   83) func strlen(strin:cpnt):integer;
                  43 (   83) var i:integer;
                  44 (   86) begin
                  45 (   86)   i:=0;
                  46 (   90)   while (strin[i]<>endmark) and (i<strsize) do
                  47 (  114)     i:=succ(i);
                  48 (  122)   strlen:=i;
                  49 (  130) end;
                  50 (  138) 
                  51 (  139) { ***** strcopy: copy cpnt string ***** }
                  52 (  139) { maximal max characters }
                  53 (  139) 
                  54 (  139) proc strcpy(strin, strout:cpnt; max: integer);
                  55 (  139) var i: integer;
                  56 (  142) begin
                  57 (  142)   i:=0;
                  58 (  146)   while (strin[i]<>endmark) and (i<max)
                  59 (  167)                 and (i<strsize-2) do begin

----------------------------------------------------------------------

R65 Pascal library STRLIB          4/11/23     page 2

                  60 (  187)     strout[i]:=strin[i];
                  61 (  199)     i:=succ(i);
                  62 (  209)   end;
                  63 (  214)   strout[i]:=endmark;
                  64 (  223) end;
                  65 (  227) 
                  66 (  228) { **** stradd: add string to string ***** }
                  67 (  228) 
                  68 (  228) proc stradd(strin,strinout:cpnt);
                  69 (  228) var i,j:integer;
                  70 (  231) begin
                  71 (  231)     i:=strlen(strinout); j:=0;
                  72 (  251)     while (strin[j]<>endmark)
                  73 (  267)                 and (i<prec(strsize)) do begin
                  74 (  280)       strinout[i]:=strin[j];
                  75 (  292)       i:=succ(i); j:=succ(j);
                  76 (  311)     end;
                  77 (  316)     strinout[i]:=endmark;
                  78 (  325) end;
                  79 (  329) 
                  80 (  330) { **** strcmp: compare two strings **** }
                  81 (  330) { returns -1  if s1<s2
                  82 (  330)            0  if s1=s2
                  83 (  330)            1  if s1>s2                  }
                  84 (  330) 
                  85 (  330) func strcmp(s1,s2:cpnt):integer;
                  86 (  330) var i:integer;
                  87 (  333) begin
                  88 (  333)   { find first difference or end of string }
                  89 (  333)   i:=0;
                  90 (  337)   while (s1[i]<>endmark) and (s1[i]=s2[i])
                  91 (  372)     and (i<strsize) do i:=succ(i);
                  92 (  391)   if s1[i]=s2[i] then strcmp:=0
                  93 (  423)   else if s1[i]>s2[i] then strcmp:=1
                  94 (  456)   else strcmp:=-1;
                  95 (  467) end;
                  96 (  472) 
                  97 (  473) { **** strpos: find occurance of char **** }
                  98 (  473) { returns -1 if char not found }
                  99 (  473) func strpos(ch:char; s1:cpnt; start:integer): integer;
                 100 (  473) var i,len: integer;
                 101 (  476) begin
                 102 (  476)   len:=strlen(s1);
                 103 (  490)   if start>=len then strpos:=-1
                 104 (  506)   else  begin
                 105 (  516)     i:=start;
                 106 (  516)     while (i<len) and (s1[i]<>ch) do i:=succ(i);
                 107 (  556)     if s1[i]=ch then strpos:=i
                 108 (  582)     else strpos:=-1;
                 109 (  595)   end;
                 110 (  600) end;
                 111 (  600) 
                 112 (  601) { **** strread: read string from input }
                 113 (  601) { returns the number of chars read }
                 114 (  601) 
                 115 (  601) func strread(f: file; s: cpnt): integer;
                 116 (  601) var i: integer;
                 117 (  604)     ch: char;
                 118 (  604) begin
                 119 (  604)   i:=-1;

----------------------------------------------------------------------

R65 Pascal library STRLIB          4/11/23     page 3

                 120 (  608)   repeat
                 121 (  613)     i:=succ(i);
                 122 (  617)     read(@f,ch);
                 123 (  632)     s[i]:=ch;
                 124 (  637)     until (ch=chr($d)) or (ch=chr($1f)) or
                 125 (  661)       (ch=chr($7f)) or (ch=chr(0)) or (i>=strsize-1);
                 126 (  690)   s[i]:=chr(0);
                 127 (  700)   strread:=i;
                 128 (  705) end;
                 129 (  713) 
                 130 (  714) { **** intstr: convert integer to string **** }
                 131 (  714) { right justified in a field of 6 chars }
                 132 (  714) 
                 133 (  714) proc intstr(n:integer;s:cpnt;fsize:integer);
                 134 (  714) var pos,n0,n1:integer;
                 135 (  717)     isneg:boolean;
                 136 (  717) begin
                 137 (  717)   pos:=fsize-1; n0:=n; isneg:=false;
                 138 (  740)   if (n0<0) then begin
                 139 (  751)     isneg:=true; n0:=-n0;
                 140 (  760)   end;
                 141 (  769)   s[pos+1]:=chr(0); { end mark }
                 142 (  783)   repeat
                 143 (  783)     { avoid 2nd division for mod }
                 144 (  783)     n1:=n0 div 10;
                 145 (  789)     s[pos]:=chr(n0-10*n1+ord('0'));
                 146 (  813)     n0:=n1; pos:=pos-1;
                 147 (  832)     until (n0=0) or (pos<0);
                 148 (  851)   if (n0<>0) or (isneg and (pos<0)) then begin
                 149 (  875)     for pos:=0 to fsize-1 do s[pos]:=chr($23);
                 150 (  906)   end else begin
                 151 (  928)     if isneg then begin
                 152 (  932)       s[pos]:='-'; pos:=pos-1;
                 153 (  951)     end;
                 154 (  956)     while pos>=0 do begin
                 155 (  966)       s[pos]:=' '; pos:=pos-1;
                 156 (  982)     end;
                 157 (  987)   end;
                 158 (  990) end;
                 159 (  990) 
                 160 (  991) begin
                 161 (  991) end.
                 162 (  993) 

End compile

Code lenght:          992
Compiler stack size:  23
Ident stack size:     22
Pascal errors:        0
