
R65 COMPILE 4.2: program STRLIB           7/12/23 page 1


   1 (    4) { ************************************
   2 (    4)   *  strlib: handling cpnt pointers  *
   3 (    4)   ************************************
   4 (    4) 
   5 (    4) type cpnt are pointers to strings of
   6 (    4) 0 delimited strings of up to 64 characters }
   7 (    4) 
   8 (    4) library strlib;
   9 (    4) 
  10 (    4) const strsize=64;
  11 (    7)       endmark=chr(0);
  12 (    7) 
  13 (    7) { ***** runerr: stop with runtime error ***** }
  14 (    7) 
  15 (    7) proc runerr(e:integer);
  16 (    7) const stopcode = $2010;
  17 (   10) mem   runerr = $000c: integer&;
  18 (   10) begin
  19 (   10)   runerr:=e;
  20 (   12)   call(stopcode);
  21 (   24) end;
  22 (   24) 
  23 (   25) { ***** new: allocate heap memory ***** }
  24 (   25) 
  25 (   25) func new:cpnt;
  26 (   25) mem  sp     = $0008: integer;
  27 (   28)      endstk = $000e: integer;
  28 (   28) var  freewords,i:integer;
  29 (   28)      str:cpnt;
  30 (   28) begin
  31 (   28)   { Pascal has no type unsigned integer. }
  32 (   28)   { But the free space can be larger than 32767 }
  33 (   28)   { We work therefore with free words here }
  34 (   28)   freewords:=(endstk-sp) shr 1;
  35 (   39)   if freewords < (strsize + 256) then begin
  36 (   55)     { 256 words are left for the growing stack }
  37 (   58)     runerr($88);
  38 (   66)   end;
  39 (   66)   { allocate heap memory }
  40 (   66)   endstk:=endstk-strsize;
  41 (   71)   str:=cpnt(endstk);
  42 (   78)   { initialize the string }
  43 (   82)   str[0]:=endmark;
  44 (   86)   new:=str;
  45 (   90) end;
  46 (   98) 
  47 (   99) { ***** release: release heap memory ***** }
  48 (   99) 
  49 (   99) proc release(s: cpnt);
  50 (   99) { Only the last allocated string can be released }
  51 (   99) { This is suitable for recursive functions }
  52 (   99) mem endstk=$000e: integer;
  53 (  102) begin
  54 (  102)   if cpnt(endstk)=s then endstk:=endstk+strsize
  55 (  118)   else runerr($92);
  56 (  135) end;
  57 (  135) 
  58 (  136) { ***** strlen: length of string ***** }
  59 (  136) 

----------------------------------------------------------------------

R65 COMPILE 4.2: library STRLIB           7/12/23 page 2

  60 (  136) func strlen(strin:cpnt):integer;
  61 (  136) var i:integer;
  62 (  139) begin
  63 (  139)   i:=0;
  64 (  143)   while (strin[i]<>endmark) and (i<strsize) do
  65 (  167)     i:=succ(i);
  66 (  175)   strlen:=i;
  67 (  183) end;
  68 (  191) 
  69 (  192) { ***** strcopy: copy cpnt string ***** }
  70 (  192) 
  71 (  192) proc strcpy(strin, strout:cpnt);
  72 (  192) var i: integer;
  73 (  195) begin
  74 (  195)   strout[0]:=endmark;
  75 (  201)   write(@strout,strin);
  76 (  216) end;
  77 (  216) 
  78 (  217) { **** stradd: add string to string ***** }
  79 (  217) 
  80 (  217) proc stradd(strin,strinout:cpnt);
  81 (  217) var i,j:integer;
  82 (  220) begin
  83 (  220)   write(@strinout,strin);
  84 (  233) end;
  85 (  233) 
  86 (  234) { **** strcmp: compare two strings **** }
  87 (  234) { returns -1  if s1<s2
  88 (  234)            0  if s1=s2
  89 (  234)            1  if s1>s2                  }
  90 (  234) 
  91 (  234) func strcmp(s1,s2:cpnt):integer;
  92 (  234) var i:integer;
  93 (  237) begin
  94 (  237)   { find first difference or end of string }
  95 (  237)   i:=0;
  96 (  241)   while (s1[i]<>endmark) and (s1[i]=s2[i])
  97 (  276)     and (i<strsize) do i:=succ(i);
  98 (  295)   if s1[i]=s2[i] then strcmp:=0
  99 (  327)   else if s1[i]>s2[i] then strcmp:=1
 100 (  360)   else strcmp:=-1;
 101 (  371) end;
 102 (  376) 
 103 (  377) { **** strpos: find occurance of char **** }
 104 (  377) { returns -1 if char not found }
 105 (  377) func strpos(ch:char; s1:cpnt; start:integer): integer;
 106 (  377) var i,len: integer;
 107 (  380) begin
 108 (  380)   len:=strlen(s1);
 109 (  394)   if start>=len then strpos:=-1
 110 (  410)   else  begin
 111 (  420)     i:=start;
 112 (  420)     while (i<len) and (s1[i]<>ch) do i:=succ(i);
 113 (  460)     if s1[i]=ch then strpos:=i
 114 (  486)     else strpos:=-1;
 115 (  499)   end;
 116 (  504) end;
 117 (  504) 
 118 (  505) { **** strread: read string from input }
 119 (  505) { returns the number of chars read }

----------------------------------------------------------------------

R65 COMPILE 4.2: library STRLIB           7/12/23 page 3

 120 (  505) 
 121 (  505) func strread(f: file; s: cpnt): integer;
 122 (  505) var i: integer;
 123 (  508)     ch: char;
 124 (  508) begin
 125 (  508)   i:=-1;
 126 (  512)   repeat
 127 (  517)     i:=succ(i);
 128 (  521)     read(@f,ch);
 129 (  536)     s[i]:=ch;
 130 (  541)     until (ch=chr($d)) or (ch=chr($1f)) or
 131 (  565)       (ch=chr($7f)) or (ch=chr(0)) or (i>=strsize-1);
 132 (  594)   s[i]:=chr(0);
 133 (  604)   strread:=i;
 134 (  609) end;
 135 (  617) 
 136 (  618) { hexstr: convert hex byte to hex string }
 137 (  618) 
 138 (  618) proc hexstr(d:integer; s:cpnt);
 139 (  618)   func hchar(h:integer):char;
 140 (  621)   begin
 141 (  621)     if h<10 then hchar:=chr(h+ord('0'))
 142 (  642)     else hchar:=chr(h-10+ord('A'));
 143 (  661)   end;
 144 (  666) begin
 145 (  667)   s[0]:=hchar((d shr 4) and 15);
 146 (  689)   s[1]:=hchar(d and 15);
 147 (  710)   s[2]:=chr(0);
 148 (  718) end;
 149 (  723) 
 150 (  724) { *** strinsc: insert char into string *** }
 151 (  724) { inserts char if string is short enough }
 152 (  724) 
 153 (  724) proc strinsc(ch:char;pos:integer;s:cpnt);
 154 (  724) var i,l:integer;
 155 (  727) begin
 156 (  727)   l:=strlen(s);
 157 (  741)   if (l<strsize-1) and (pos>=0)
 158 (  761)     and (pos<strsize-1) then begin
 159 (  774)     for i:=l downto pos do
 160 (  785)       { move includes end mark }
 161 (  798)       s[i+1]:=s[i];
 162 (  813)     if pos > l then begin
 163 (  842)       for i:=l to pos-1 do s[i]:=' ';
 164 (  875)       s[pos+1]:=chr(0);
 165 (  902)     end;
 166 (  907)     s[pos]:=ch;
 167 (  911)   end
 168 (  919)   else runerr($91);
 169 (  930) end;
 170 (  930) 
 171 (  931) { *** strdelc: delete char in string *** }
 172 (  931) 
 173 (  931) proc strdelc(pos:integer;s:cpnt);
 174 (  931) var i,l:integer;
 175 (  934) begin
 176 (  934)   l:=strlen(s);
 177 (  948)   for i:=pos to l-1 do
 178 (  966)       { move includes end mark }
 179 (  976)       s[i]:=s[i+1];

----------------------------------------------------------------------

R65 COMPILE 4.2: library STRLIB           7/12/23 page 4

 180 (  991) end;
 181 ( 1011) 
 182 ( 1012) { **** intstr: convert integer to string **** }
 183 ( 1012) { right justified in a field of 6 chars }
 184 ( 1012) 
 185 ( 1012) proc intstr(n:integer;s:cpnt;fsize:integer);
 186 ( 1012) begin
 187 ( 1012)   s[0]:=endmark;
 188 ( 1021)   write(@s,n);
 189 ( 1036)   while strlen(s)<fsize do strinsc(' ',0,s);
 190 ( 1070) end;
 191 ( 1073) 
 192 ( 1074) begin
 193 ( 1074) end.
 194 ( 1076) 

End compile

Code lenght:          1075
Compiler stack size:  36
Ident stack size:     23
Pascal errors:        0
