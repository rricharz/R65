
R65 Pascal program STRLIB          2/11/23     page 1


                   1 (    4) { ************************************
                   2 (    4)   *  strlib: handling cpnt pointers  *
                   3 (    4)   ************************************
                   4 (    4) 
                   5 (    4) type cpnt are pointers to strings of
                   6 (    4) 0 delimited strings of up to 64 characters }
                   7 (    4) 
                   8 (    4) library strlib;
                   9 (    4) 
                  10 (    4) const strsize=64;
                  11 (    7)       endmark=chr(0);
                  12 (    7) 
                  13 (    7) { ***** strnew: allocate heap memory for cpnt ***** }
                  14 (    7) 
                  15 (    7) func strnew:cpnt;
                  16 (    7) const stopcode = $2010;
                  17 (   10) mem   endstk = $000e: integer;
                  18 (   10)       runerr = $000c: integer&;
                  19 (   10)       sp     = $0008: integer;
                  20 (   10) var freewords,i:integer;
                  21 (   10)     str:cpnt;
                  22 (   10) begin
                  23 (   10)   { Pascal has no type unsigned integer. }
                  24 (   10)   { But the free space can be larger than 32767 }
                  25 (   10)   { We work therefore with free words here }
                  26 (   10)   freewords:=(endstk-sp) shr 1;
                  27 (   21)   if freewords < (strsize + 256) then begin
                  28 (   37)     { 256 words are left for the growing stack }
                  29 (   40)     runerr:=$88;
                  30 (   42)     call(stopcode);
                  31 (   50)   end;
                  32 (   50)   { allocate heap memory }
                  33 (   50)   endstk:=endstk-strsize;
                  34 (   55)   str:=cpnt(endstk);
                  35 (   62)   { initialize the string }
                  36 (   66)   str[0]:=endmark;
                  37 (   70)   strnew:=str;
                  38 (   74) end;
                  39 (   82) 
                  40 (   83) { ***** strlen: length of string ***** }
                  41 (   83) func strlen(strin:cpnt):integer;
                  42 (   83) var i:integer;
                  43 (   86) begin
                  44 (   86)   i:=0;
                  45 (   90)   while (strin[i]<>endmark) and (i<strsize) do
                  46 (  114)     i:=succ(i);
                  47 (  122)   strlen:=i;
                  48 (  130) end;
                  49 (  138) 
                  50 (  139) { ***** strcopy: copy cpnt string ***** }
                  51 (  139) 
                  52 (  139) proc strcpy(strin, strout:cpnt);
                  53 (  139) var i: integer;
                  54 (  142) begin
                  55 (  142)   i:=0;
                  56 (  146)   while (strin[i]<>endmark)
                  57 (  162)                 and (i<strsize-2) do begin
                  58 (  177)     strout[i]:=strin[i];
                  59 (  189)     i:=succ(i);

----------------------------------------------------------------------

R65 Pascal library STRLIB          2/11/23     page 2

                  60 (  199)   end;
                  61 (  204)   strout[i]:=endmark;
                  62 (  213) end;
                  63 (  217) 
                  64 (  218) { **** stradd: add string to string ***** }
                  65 (  218) proc stradd(strin,strinout:cpnt);
                  66 (  218) var i,j:integer;
                  67 (  221) begin
                  68 (  221)     i:=strlen(strinout); j:=0;
                  69 (  241)     while (strin[j]<>endmark)
                  70 (  257)                 and (i<prec(strsize)) do begin
                  71 (  270)       strinout[i]:=strin[j];
                  72 (  282)       i:=succ(i); j:=succ(j);
                  73 (  301)     end;
                  74 (  306)     strinout[i]:=endmark;
                  75 (  315) end;
                  76 (  319) 
                  77 (  320) { **** strcmp: compare two strings **** }
                  78 (  320) { returns -1  if s1<s2
                  79 (  320)            0  if s1=s2
                  80 (  320)            1  if s1>s2                  }
                  81 (  320) func strcmp(s1,s2:cpnt):integer;
                  82 (  320) var i:integer;
                  83 (  323) begin
                  84 (  323)   { find first difference or end of string }
                  85 (  323)   i:=0;
                  86 (  327)   while (s1[i]<>endmark) and (s1[i]=s2[i])
                  87 (  362)     and (i<strsize) do i:=succ(i);
                  88 (  381)   if s1[i]=s2[i] then strcmp:=0
                  89 (  413)   else if s1[i]>s2[i] then strcmp:=1
                  90 (  446)   else strcmp:=-1;
                  91 (  457) end;
                  92 (  462) 
                  93 (  463) { **** strpos: find occurance of char **** }
                  94 (  463) { returns -1 if char not found }
                  95 (  463) func strpos(ch:char; s1:cpnt; start:integer): integer;
                  96 (  463) var i,len: integer;
                  97 (  466) begin
                  98 (  466)   len:=strlen(s1);
                  99 (  480)   if start>=len then strpos:=-1
                 100 (  496)   else  begin
                 101 (  506)     i:=start;
                 102 (  506)     while (i<len) and (s1[i]<>ch) do i:=succ(i);
                 103 (  546)     if s1[i]=ch then strpos:=i
                 104 (  572)     else strpos:=-1;
                 105 (  585)   end;
                 106 (  590) end;
                 107 (  590) 
                 108 (  591) { **** strread: read string from input }
                 109 (  591) { returns the number of chars read }
                 110 (  591) func strread(f: file; s: cpnt): integer;
                 111 (  591) var i: integer;
                 112 (  594)     ch: char;
                 113 (  594) begin
                 114 (  594)   i:=-1;
                 115 (  598)   repeat
                 116 (  603)     i:=succ(i);
                 117 (  607)     read(@f,ch);
                 118 (  622)     s[i]:=ch;
                 119 (  627)     until (ch=chr($d)) or (ch=chr($1f)) or

----------------------------------------------------------------------

R65 Pascal library STRLIB          2/11/23     page 3

                 120 (  651)       (ch=chr($7f)) or (ch=chr(0)) or (i>=strsize-1);
                 121 (  680)   s[i]:=chr(0);
                 122 (  690)   strread:=i;
                 123 (  695) end;
                 124 (  703) 
                 125 (  704) begin
                 126 (  704) end.
                 127 (  706) 

End compile

Code lenght:          705
Compiler stack size:  18
Ident stack size:     18
Pascal errors:        0
