
R65 COMPILE 4.3: program SCRAMBLE         13/2/24 page 1


   1 (    4) { scramble: climb up the ladders }
   2 (    4) 
   3 (    4) program scramble;
   4 (    4) uses syslib,plotlib;
   5 ( 1566) 
   6 ( 1566) const erase=0; ball=$6ff6;
   7 ( 1569)       nfloors=5; vfloors=19; holesize=22;
   8 ( 1569)       gravity=-0.25; reflection=-0.7;
   9 ( 1569)       laddersize=7;
  10 ( 1569) 
  11 ( 1569) var bx,by,bxs,bys,bxspeed,byspeed: real;
  12 ( 1569)     floor: integer;
  13 ( 1569)     holes,ladders: array[nfloors] of integer;
  14 ( 1569) 
  15 ( 1569) {$I IRANDOM:P}
IRANDOM:P       .02  SP 0000-0200 0002 12/02/24
{I}    1 ( 1569) { irandom: real and integer random functions with limit
{I}    2 ( 1569) }
{I}    3 ( 1569) 
{I}    4 ( 1569) func rrandom(min,max:real):real;
{I}    5 ( 1569) begin
{I}    6 ( 1569)   rrandom := min + (conv(random)/255.0) * (max - min);
{I}    7 ( 1607) end;
{I}    8 ( 1615) 
{I}    9 ( 1616) func irandom(min,max:integer):integer;
{I}   10 ( 1616) begin
{I}   11 ( 1616)   irandom := trunc(rrandom(conv(min),conv(max)));
{I}   12 ( 1639) end;
{I}   13 ( 1644) 
  16 ( 1645) 
  17 ( 1645) proc showladder;
  18 ( 1645) var i,x1,x2,y1,y2:integer;
  19 ( 1648) begin
  20 ( 1648)   x1:=ladders[floor]; x2:=x1+laddersize;
  21 ( 1668)   y1:=floor*vfloors+1; y2:=y1+vfloors-1;
  22 ( 1696)   move(x1,y1); draw(x1,y2,white);
  23 ( 1731)   move(x2,y1); draw(x2,y2,white);
  24 ( 1761)   i:=1;
  25 ( 1763)   for i:=1 to 4 do begin
  26 ( 1784)     move(x1,y1+4*i); draw(x2,y1+4*i,white);
  27 ( 1830)   end;
  28 ( 1830) end;
  29 ( 1844) 
  30 ( 1845) func expaint: boolean;
  31 ( 1845) { paint picture and apply motion }
  32 ( 1845) begin
  33 ( 1845)   { paint }
  34 ( 1848)   expaint:=false;
  35 ( 1852)   plotmap(trunc(bxs),trunc(bys),erase);
  36 ( 1878)   plotmap(trunc(bx),trunc(by),ball);
  37 ( 1901)   if floor<nfloors then showladder;
  38 ( 1915)   bxs:=bx; bys:=by;
  39 ( 1927)   { motion }
  40 ( 1939)   bx:=bx+bxspeed; by:=by+byspeed;
  41 ( 1964)   { check for borders }
  42 ( 1977)   if bx>=conv(xsize-4) then begin
  43 ( 1990)     bx:=conv(xsize-4); bxspeed:=-bxspeed;
  44 ( 2005)   end else if bx<2.0 then begin
  45 ( 2034)     bx:=2.0; bxspeed:=-bxspeed;
  46 ( 2049)   end;

----------------------------------------------------------------------

R65 COMPILE 4.3: program SCRAMBLE         13/2/24 page 2

  47 ( 2062)   { check for reflection on ceiling }
  48 ( 2062)   if by>=conv((floor+1)*vfloors-4) then begin
  49 ( 2083)     by:=conv((floor+1)*vfloors-4);
  50 ( 2099)     byspeed:=reflection*byspeed;
  51 ( 2112)   end;
  52 ( 2125)   { check for hole }
  53 ( 2125)   if (bx>=conv(holes[floor])) and
  54 ( 2141)       (bx<=conv(holes[floor]+holesize-4)) and
  55 ( 2163)      (by<=conv(floor*vfloors+1)) then begin
  56 ( 2183)      { fall through hole }
  57 ( 2186)     byspeed:=byspeed+gravity;
  58 ( 2198)     if floor>0 then floor:=floor-1;
  59 ( 2221)   end else if by<conv(floor*vfloors+1) then begin
  60 ( 2247)     { reflection on floor }
  61 ( 2250)     by:=conv(floor*vfloors+2); { jump a bit }
  62 ( 2267)     byspeed:=reflection*byspeed;
  63 ( 2273)   end else
  64 ( 2286)     byspeed:=byspeed+gravity;
  65 ( 2301)   { check for border on bottom floor }
  66 ( 2308)   if (by<4.0) and ((bx<=2.0) or (bx>=conv(xsize-4)))
  67 ( 2347)   then begin
  68 ( 2349)     if bx<2.0 then bx:=2.0
  69 ( 2368)     else if bx>=conv(xsize-4) then bx:=conv(xsize-4);
  70 ( 2404)     by:=conv(nfloors*vfloors+1);
  71 ( 2419)     byspeed:=0.0; floor:=nfloors;
  72 ( 2440)   end;
  73 ( 2444) end;
  74 ( 2444) 
  75 ( 2445) func exkey(key:char):boolean;
  76 ( 2445) { check for key typed }
  77 ( 2445) begin
  78 ( 2445)   exkey:=key=chr(0);
  79 ( 2456) end;
  80 ( 2462) 
  81 ( 2463) proc init;
  82 ( 2463) begin
  83 ( 2463)   cleargr;
  84 ( 2472)   bx:=2.0; by:=conv(nfloors*vfloors+1);
  85 ( 2492)   bxs:=bx; bys:=by;
  86 ( 2511)   bxspeed:=2.0; byspeed:=0.0;
  87 ( 2541)   { make and show holes }
  88 ( 2547)   holes[0]:=-holesize;
  89 ( 2551)   for floor:=1 to nfloors do begin
  90 ( 2573)     holes[floor]:=irandom(1,xsize-holesize-1);
  91 ( 2595)     move(0,floor*vfloors);
  92 ( 2614)     draw(xsize-1,floor*vfloors,white);
  93 ( 2634)     move(holes[floor],floor*vfloors);
  94 ( 2655)     draw(holes[floor]+holesize,floor*vfloors,black);
  95 ( 2681)   end;
  96 ( 2681)   { make and show ladders }
  97 ( 2695)   for floor:=0 to nfloors-1 do begin
  98 ( 2715)     repeat
  99 ( 2715)       ladders[floor]:=irandom(2,xsize-laddersize);
 100 ( 2734)       write('.');
 101 ( 2740)     until ((ladders[floor]+laddersize<holes[floor])
 102 ( 2755)       or (ladders[floor]>holes[floor]+holesize)) and
 103 ( 2781)       ((ladders[floor]+laddersize<holes[floor+1])
 104 ( 2799)       or (ladders[floor]>holes[floor+1]+holesize));
 105 ( 2828)       showladder;
 106 ( 2836)   end;

----------------------------------------------------------------------

R65 COMPILE 4.3: program SCRAMBLE         13/2/24 page 3

 107 ( 2836)   ladders[nfloors]:=-laddersize;
 108 ( 2854)   floor:=nfloors;
 109 ( 2861) end;
 110 ( 2865) 
 111 ( 2866) {$I IANIMATE:P}
IANIMATE:P      .0C  SP 0000-0400 000C 12/02/24
{I}    1 ( 2866) { ianimate - run animation in loop
{I}    2 ( 2866)   proc expaint;
{I}    3 ( 2866)     Called to paint one picture and apply motion.
{I}    4 ( 2866)   func exkey(ch:char):boolean;
{I}    5 ( 2866)     Called to check for key and stop loop if true  }
{I}    6 ( 2866) 
{I}    7 ( 2866) proc animate(arepeat:boolean);
{I}    8 ( 2866) { arepeat: auto repeat cursor keys without delay }
{I}    9 ( 2866) const toggle=chr($0c);
{I}   10 ( 2869)       cleft=chr($03); cright=chr($16);
{I}   11 ( 2869)       cup=chr($1a); cdown=chr($18); esc=chr(0);
{I}   12 ( 2869) mem   sflag=$1781:integer&;
{I}   13 ( 2869)       emuflags=$1707:integer&;
{I}   14 ( 2869) var   ch:char;
{I}   15 ( 2869)       dummy:integer;
{I}   16 ( 2869)       stop:boolean;
{I}   17 ( 2869) begin
{I}   18 ( 2869)   repeat
{I}   19 ( 2869)     repeat
{I}   20 ( 2871)       stop:=expaint;
{I}   21 ( 2877)       dummy:=syncscreen; { sleep for up to 30 msec }
{I}   22 ( 2891)       ch:=keypressed; { sleep for 10 msec }
{I}   23 ( 2899)       { sflag bit 8 is escape flag. Pass it through }
{I}   24 ( 2899)     until (ord(ch)<>0) or ((sflag and $80)<>0)
{I}   25 ( 2915)       or stop;
{I}   26 ( 2917)     if not(((ch=cup) or (ch=cdown) or (ch=cleft) or
{I}   27 ( 2947)        (ch=cright)) and
{I}   28 ( 2956)        ((emuflags and 1)<>0) and arepeat) then
{I}   29 ( 2972)        { cursor keys auto repeat without delay }
{I}   30 ( 2973)        keypressed := chr(0);
{I}   31 ( 2978)     sflag:=sflag and $7f; { clear escape flag }
{I}   32 ( 2996)     if ch=toggle then write(toggle);
{I}   33 ( 3009)   until exkey(ch) or stop;
{I}   34 ( 3021) end;
 112 ( 3030) 
 113 ( 3030) begin
 114 ( 3030)   grinit; splitview; init;
 115 ( 3044)   animate(false);
 116 ( 3052)   splitview;
 117 ( 3056) end.

End compile

Code lenght:          3055
Compiler stack size:  50
Ident stack size:     114
Pascal errors:        0
