
R65 COMPILE 4.3: program SCRAMBLE         15/2/24 page 1


   1 (    4) { scramble: climb up the ladders }
   2 (    4) 
   3 (    4) program scramble;
   4 (    4) uses syslib,plotlib;
   5 ( 1566) 
   6 ( 1566) const erase=0; ball=$6ff6;
   7 ( 1569)       nfloors=5; vfloors=20; holesize=22;
   8 ( 1569)       gravity=-0.25; reflection=-0.7;
   9 ( 1569)       laddersize=8; autorepeat=false;
  10 ( 1569)       cleft=chr($03); cright=chr($16);
  11 ( 1569)       cup=chr($1a); cdown=chr($18); esc=chr(0);
  12 ( 1569)       face1=$8b43; face2=$2a48;
  13 ( 1569)       face3=$034a; face4=$084a;
  14 ( 1569) 
  15 ( 1569) var bx,by,bxs,bys,bxspeed,byspeed,fx,fxs: real;
  16 ( 1569)     fxspeed,jump,jumpspeed: real;
  17 ( 1569)     floor,ffloor,fy,fys,fyspeed: integer;
  18 ( 1569)     holes,ladders: array[nfloors] of integer;
  19 ( 1569)     score,count: integer;
  20 ( 1569) 
  21 ( 1569) {$I IRANDOM:P}
IRANDOM:P       .02  SP 0000-0200 0002 12/02/24
{I}    1 ( 1569) { irandom: real and integer random functions with limit
{I}    2 ( 1569) }
{I}    3 ( 1569) 
{I}    4 ( 1569) func rrandom(min,max:real):real;
{I}    5 ( 1569) begin
{I}    6 ( 1569)   rrandom := min + (conv(random)/255.0) * (max - min);
{I}    7 ( 1607) end;
{I}    8 ( 1615) 
{I}    9 ( 1616) func irandom(min,max:integer):integer;
{I}   10 ( 1616) begin
{I}   11 ( 1616)   irandom := trunc(rrandom(conv(min),conv(max)));
{I}   12 ( 1639) end;
{I}   13 ( 1644) 
  22 ( 1645) 
  23 ( 1645) func onfloor(f,y:integer):boolean;
  24 ( 1645) begin
  25 ( 1645)   onfloor:=(f*vfloors+1=y);
  26 ( 1665) end;
  27 ( 1669) 
  28 ( 1670) func onupladder(f:integer;x:real):boolean;
  29 ( 1670) begin
  30 ( 1670)   onupladder:=(trunc(x)>=ladders[f]+1) and
  31 ( 1694)     (trunc(x)<=ladders[f]+2);
  32 ( 1713) end;
  33 ( 1718) 
  34 ( 1719) func ondownladder(f:integer;x:real):boolean;
  35 ( 1719) begin
  36 ( 1719)   if f=0 then ondownladder:=false
  37 ( 1734)   else ondownladder:=(trunc(x)>=ladders[f-1]+1) and
  38 ( 1765)     (trunc(x+0.5)<=ladders[f-1]+2);
  39 ( 1794) end;
  40 ( 1799) 
  41 ( 1800) func onhole(f:integer;x:real):boolean;
  42 ( 1800) begin
  43 ( 1800)   onhole:=(x>=conv(holes[f]-5)) and
  44 ( 1824)       (x<=conv(holes[f]+holesize+1));
  45 ( 1846) end;
  46 ( 1851) 

----------------------------------------------------------------------

R65 COMPILE 4.3: program SCRAMBLE         15/2/24 page 2

  47 ( 1852) proc showface;
  48 ( 1852) var fysum:integer;
  49 ( 1855) begin
  50 ( 1855)   fysum:=fy+trunc(jump);
  51 ( 1867)   plotmap(trunc(fxs),fys,erase);
  52 ( 1892)   plotmap(trunc(fxs)+4,fys,erase);
  53 ( 1914)   plotmap(trunc(fxs),fys+4,erase);
  54 ( 1936)   plotmap(trunc(fxs)+4,fys+4,erase);
  55 ( 1961)   plotmap(trunc(fx),fysum,face1);
  56 ( 1981)   plotmap(trunc(fx)+4,fysum,face2);
  57 ( 2004)   plotmap(trunc(fx),fysum+4,face3);
  58 ( 2027)   plotmap(trunc(fx)+4,fysum+4,face4);
  59 ( 2053)   fxs:=fx; fys:=fysum;
  60 ( 2065) end;
  61 ( 2073) 
  62 ( 2074) proc showladder(f:integer);
  63 ( 2074) var i,x1,x2,y1,y2:integer;
  64 ( 2077) begin
  65 ( 2077)   if f<nfloors then begin
  66 ( 2086)     x1:=ladders[f]; x2:=x1+laddersize;
  67 ( 2107)     y1:=f*vfloors+1; y2:=y1+vfloors-1;
  68 ( 2135)     move(x1,y1); draw(x1,y2,white);
  69 ( 2170)     move(x2,y1); draw(x2,y2,white);
  70 ( 2200)     i:=1;
  71 ( 2202)     for i:=1 to 5 do begin
  72 ( 2223)       move(x1,y1+4*i-1); draw(x2,y1+4*i-1,white);
  73 ( 2275)     end;
  74 ( 2275)   end;
  75 ( 2289) end;
  76 ( 2289) 
  77 ( 2290) proc init; forward;
  78 ( 2293) 
  79 ( 2293) func expaint: boolean;
  80 ( 2293) { paint picture and apply motion }
  81 ( 2293) var f:integer;
  82 ( 2296) begin
  83 ( 2296)   expaint:=false;
  84 ( 2300)   if (ffloor=nfloors) and (trunc(fx)>xsize-10) then
  85 ( 2324)   begin
  86 ( 2325)     score:=score+1; count:=count+1;
  87 ( 2345)     if count>=10 then begin
  88 ( 2357)       expaint:=true; exit;
  89 ( 2367)     end;
  90 ( 2367)     fx:=1.0; fy:=1; fxspeed:=0.0; ffloor:=0;
  91 ( 2399)     move(xsize div 2 - 5*4, ysize-9);
  92 ( 2425)     write(@plotdev,score,' of ',count);
  93 ( 2444)     exit;
  94 ( 2445)   end;
  95 ( 2445)   { check for next floor on ladder }
  96 ( 2445)   if ffloor<nfloors then
  97 ( 2451)     if onfloor(ffloor+1,fy) then begin
  98 ( 2474)       ffloor:=ffloor+1; fyspeed:=0;
  99 ( 2490)     end;
 100 ( 2494)   if ffloor>0 then
 101 ( 2500)     if onfloor(ffloor-1,fy) then begin
 102 ( 2523)       ffloor:=ffloor-1; fyspeed:=0;
 103 ( 2539)     end;
 104 ( 2543)   { paint face }
 105 ( 2543)   showface;
 106 ( 2547)   { paint ball }

----------------------------------------------------------------------

R65 COMPILE 4.3: program SCRAMBLE         15/2/24 page 3

 107 ( 2547)   plotmap(trunc(bxs),trunc(bys),erase);
 108 ( 2569)   plotmap(trunc(bx),trunc(by),ball);
 109 ( 2592)   for f:=0 to nfloors-1 do showladder(f);
 110 ( 2622)   bxs:=bx; bys:=by;
 111 ( 2648)   { move face }
 112 ( 2660)   fx:=fx+fxspeed; fy:=fy+fyspeed;
 113 ( 2683)   if fx>conv(xsize-8) then begin
 114 ( 2705)     fx:=conv(xsize-8); fxspeed:=0.0;
 115 ( 2726)   end;
 116 ( 2732)   if (fx<1.0) then begin
 117 ( 2745)     fx:=1.0; fxspeed:=-0.0;
 118 ( 2766)   end;
 119 ( 2773)   { check for ladder }
 120 ( 2773)   if onupladder(ffloor,fx) or ondownladder(ffloor,fx)
 121 ( 2797)     then fxspeed:=0.0;
 122 ( 2819)   { check for hole (face) and jump over it }
 123 ( 2825)   if (jump<=0.01) and onhole(ffloor,fx) then begin
 124 ( 2857)     jumpspeed:=1.3; jump:=jump+jumpspeed;
 125 ( 2878)   end else if jump>0.0 then begin
 126 ( 2907)     jump:=jump+jumpspeed;
 127 ( 2916)     jumpspeed:=jumpspeed+gravity;
 128 ( 2941)   end;
 129 ( 2948)   if jump<=0.0 then jump:=0.0;
 130 ( 2970)   { move ball }
 131 ( 2976)   bx:=bx+bxspeed; by:=by+byspeed;
 132 ( 3001)   { check for borders }
 133 ( 3014)   if bx>=conv(xsize-4) then begin
 134 ( 3027)     bx:=conv(xsize-4); bxspeed:=-bxspeed;
 135 ( 3042)   end else if bx<2.0 then begin
 136 ( 3071)     bx:=2.0; bxspeed:=-bxspeed;
 137 ( 3086)   end;
 138 ( 3099)   { check for reflection on ceiling }
 139 ( 3099)   if by>=conv((floor+1)*vfloors-4) then begin
 140 ( 3120)     by:=conv((floor+1)*vfloors-4);
 141 ( 3136)     byspeed:=reflection*byspeed;
 142 ( 3149)   end;
 143 ( 3162)   { check for hole (ball) }
 144 ( 3162)   if (bx>=conv(holes[floor])) and
 145 ( 3178)       (bx<=conv(holes[floor]+holesize-4)) and
 146 ( 3200)      (by<=conv(floor*vfloors+1)) then begin
 147 ( 3220)      { fall through hole }
 148 ( 3223)     byspeed:=byspeed+gravity;
 149 ( 3235)     if floor>0 then floor:=floor-1;
 150 ( 3258)   end else if by<conv(floor*vfloors+1) then begin
 151 ( 3284)     { reflection on floor }
 152 ( 3287)     by:=conv(floor*vfloors+2); { jump a bit }
 153 ( 3304)     byspeed:=reflection*byspeed;
 154 ( 3310)   end else
 155 ( 3323)     byspeed:=byspeed+gravity;
 156 ( 3338)   { check for border on bottom floor }
 157 ( 3345)   if (by<4.0) and ((bx<=2.0) or (bx>=conv(xsize-4)))
 158 ( 3384)   then begin
 159 ( 3386)     if bx<2.0 then bx:=2.0
 160 ( 3405)     else if bx>=conv(xsize-4) then bx:=conv(xsize-4);
 161 ( 3441)     by:=conv(nfloors*vfloors+1);
 162 ( 3456)     byspeed:=0.0; floor:=nfloors;
 163 ( 3477)   end;
 164 ( 3481)   { check for hit }
 165 ( 3481)   if (bx>=fx-4.0) and (bx<=fx+8.0) and
 166 ( 3521)      (trunc(by)>=fy-4) and (trunc(by)<=fy+8)

----------------------------------------------------------------------

R65 COMPILE 4.3: program SCRAMBLE         15/2/24 page 4

 167 ( 3551)     then begin
 168 ( 3554)       count:=count+1;
 169 ( 3563)       move(xsize div 2 - 5*4, ysize-9);
 170 ( 3590)       write(@plotdev,score,' of ',count);
 171 ( 3609)       if count>=10 then expaint:=true;
 172 ( 3621)       init;
 173 ( 3629)     end;
 174 ( 3629) end;
 175 ( 3629) 
 176 ( 3630) proc ladderup;
 177 ( 3630) begin
 178 ( 3630)   if (ffloor<nfloors) and onupladder(ffloor,fx)
 179 ( 3648)   then begin
 180 ( 3661)     fx:=conv(ladders[ffloor]+1);
 181 ( 3675)     fyspeed:=1; fxspeed:=0.0;
 182 ( 3694)   end;
 183 ( 3700) end;
 184 ( 3700) 
 185 ( 3701) proc ladderdown;
 186 ( 3701) begin
 187 ( 3701)   if (ffloor>0) and ondownladder(ffloor,fx)
 188 ( 3719)   then begin
 189 ( 3732)     fx:=conv(ladders[ffloor-1]+1);
 190 ( 3749)     fyspeed:=-1; fxspeed:=0.0;
 191 ( 3769)   end;
 192 ( 3775) end;
 193 ( 3775) 
 194 ( 3776) func exkey(key:char):boolean;
 195 ( 3776) { check for key typed }
 196 ( 3776) begin
 197 ( 3776)   exkey:=(key=esc);
 198 ( 3788)   case key of
 199 ( 3792)    cup:    ladderup;
 200 ( 3807)    cdown:  ladderdown;
 201 ( 3821)    cleft:  if onfloor(ffloor,fy) then
 202 ( 3847)              if fxspeed>1.0 then fxspeed:=0.0
 203 ( 3866)              else fxspeed:=-2.0;
 204 ( 3887)    cright: if onfloor(ffloor,fy) then
 205 ( 3920)              if fxspeed<-1.0 then fxspeed:=0.0
 206 ( 3940)              else fxspeed:=2.0
 207 ( 3955)    end {case};
 208 ( 3969) end;
 209 ( 3969) 
 210 ( 3970) proc init;
 211 ( 3970) begin
 212 ( 3970)   cleargr;
 213 ( 3979)   move(xsize div 2 - 5*4, ysize-9);
 214 ( 4001)   write(@plotdev,score,' of ',count);
 215 ( 4020)   bx:=2.0; by:=conv(nfloors*vfloors+1);
 216 ( 4040)   bxs:=bx; bys:=by;
 217 ( 4059)   bxspeed:=2.0; byspeed:=0.0;
 218 ( 4089)   fx:=1.0; fy:=1; jump:=0.0;  jumpspeed:=0.0;
 219 ( 4131)   fxs:=fx; fys:=fy;
 220 ( 4149)   fxspeed:=0.0; fyspeed:=0;
 221 ( 4171)   { make and show holes }
 222 ( 4175)   holes[0]:=-50;
 223 ( 4179)   move(0,0); draw(xsize,0,white);
 224 ( 4206)   for floor:=1 to nfloors do begin
 225 ( 4223)     holes[floor]:=irandom(1,xsize-holesize-1);
 226 ( 4245)     move(0,floor*vfloors);

----------------------------------------------------------------------

R65 COMPILE 4.3: program SCRAMBLE         15/2/24 page 5

 227 ( 4264)     draw(xsize-1,floor*vfloors,white);
 228 ( 4284)     move(holes[floor],floor*vfloors);
 229 ( 4305)     draw(holes[floor]+holesize,floor*vfloors,black);
 230 ( 4331)   end;
 231 ( 4331)   { make and show ladders }
 232 ( 4345)   for floor:=0 to nfloors-1 do begin
 233 ( 4365)     repeat
 234 ( 4365)       ladders[floor]:=irandom(2,xsize-laddersize-2);
 235 ( 4387)     until ((ladders[floor]+laddersize<holes[floor])
 236 ( 4406)       or (ladders[floor]>holes[floor]+holesize)) and
 237 ( 4432)       ((ladders[floor]+laddersize<holes[floor+1])
 238 ( 4450)       or (ladders[floor]>holes[floor+1]+holesize));
 239 ( 4479)       showladder(floor);
 240 ( 4493)   end;
 241 ( 4493)   ladders[nfloors]:=-laddersize;
 242 ( 4511)   floor:=nfloors;
 243 ( 4518)   ffloor:=0;
 244 ( 4524) end;
 245 ( 4528) 
 246 ( 4529) {$I IANIMATE:P}
IANIMATE:P      .0C  SP 0000-0400 000C 12/02/24
{I}    1 ( 4529) { ianimate - run animation in loop
{I}    2 ( 4529)   proc expaint;
{I}    3 ( 4529)     Called to paint one picture and apply motion.
{I}    4 ( 4529)   func exkey(ch:char):boolean;
{I}    5 ( 4529)     Called to check for key and stop loop if true  }
{I}    6 ( 4529) 
{I}    7 ( 4529) proc animate(arepeat:boolean);
{I}    8 ( 4529) { arepeat: auto repeat cursor keys without delay }
{I}    9 ( 4529) const toggle=chr($0c);
{I}   10 ( 4532)       cleft=chr($03); cright=chr($16);
{I}   11 ( 4532)       cup=chr($1a); cdown=chr($18); esc=chr(0);
{I}   12 ( 4532) mem   sflag=$1781:integer&;
{I}   13 ( 4532)       emuflags=$1707:integer&;
{I}   14 ( 4532) var   ch:char;
{I}   15 ( 4532)       dummy:integer;
{I}   16 ( 4532)       stop:boolean;
{I}   17 ( 4532) begin
{I}   18 ( 4532)   repeat
{I}   19 ( 4532)     repeat
{I}   20 ( 4534)       stop:=expaint;
{I}   21 ( 4540)       dummy:=syncscreen; { sleep for up to 30 msec }
{I}   22 ( 4554)       ch:=keypressed; { sleep for 10 msec }
{I}   23 ( 4562)       { sflag bit 8 is escape flag. Pass it through }
{I}   24 ( 4562)     until (ord(ch)<>0) or ((sflag and $80)<>0)
{I}   25 ( 4578)       or stop;
{I}   26 ( 4580)     if not(((ch=cup) or (ch=cdown) or (ch=cleft) or
{I}   27 ( 4610)        (ch=cright)) and
{I}   28 ( 4619)        ((emuflags and 1)<>0) and arepeat) then
{I}   29 ( 4635)        { cursor keys auto repeat without delay }
{I}   30 ( 4636)        keypressed := chr(0);
{I}   31 ( 4641)     sflag:=sflag and $7f; { clear escape flag }
{I}   32 ( 4659)     if ch=toggle then write(toggle);
{I}   33 ( 4672)   until exkey(ch) or stop;
{I}   34 ( 4684) end;
 247 ( 4693) 
 248 ( 4693) begin
 249 ( 4693)   score:=0; count:=0;
 250 ( 4703)   grinit; fullview;
 251 ( 4715)   init;
 252 ( 4719)   animate(autorepeat);

----------------------------------------------------------------------

R65 COMPILE 4.3: program SCRAMBLE         15/2/24 page 6

 253 ( 4727)   splitview;
 254 ( 4731)   move(xsize div 2 - 5*4, ysize-9);
 255 ( 4753)   write(@plotdev,score,' of ',count);
 256 ( 4772)   writeln('Score ',score,' of ',count);
 257 ( 4800) end.

End compile

Code lenght:          4799
Compiler stack size:  69
Ident stack size:     146
Pascal errors:        0
