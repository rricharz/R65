
R65 COMPILE 4.3: program SCRAMBLE         14/2/24 page 1


   1 (    4) { scramble: climb up the ladders }
   2 (    4) 
   3 (    4) program scramble;
   4 (    4) uses syslib,plotlib;
   5 ( 1566) 
   6 ( 1566) const erase=0; ball=$6ff6;
   7 ( 1569)       nfloors=5; vfloors=20; holesize=22;
   8 ( 1569)       gravity=-0.25; reflection=-0.7;
   9 ( 1569)       laddersize=8; autorepeat=false;
  10 ( 1569)       cleft=chr($03); cright=chr($16);
  11 ( 1569)       cup=chr($1a); cdown=chr($18); esc=chr(0);
  12 ( 1569)       face1=$8b43; face2=$2a48;
  13 ( 1569)       face3=$034a; face4=$084a;
  14 ( 1569) 
  15 ( 1569) var bx,by,bxs,bys,bxspeed,byspeed,fx,fxs: real;
  16 ( 1569)     fxspeed,jump: real;
  17 ( 1569)     floor,ffloor,fy,fys,fyspeed: integer;
  18 ( 1569)     holes,ladders: array[nfloors] of integer;
  19 ( 1569) 
  20 ( 1569) {$I IRANDOM:P}
IRANDOM:P       .02  SP 0000-0200 0002 12/02/24
{I}    1 ( 1569) { irandom: real and integer random functions with limit
{I}    2 ( 1569) }
{I}    3 ( 1569) 
{I}    4 ( 1569) func rrandom(min,max:real):real;
{I}    5 ( 1569) begin
{I}    6 ( 1569)   rrandom := min + (conv(random)/255.0) * (max - min);
{I}    7 ( 1607) end;
{I}    8 ( 1615) 
{I}    9 ( 1616) func irandom(min,max:integer):integer;
{I}   10 ( 1616) begin
{I}   11 ( 1616)   irandom := trunc(rrandom(conv(min),conv(max)));
{I}   12 ( 1639) end;
{I}   13 ( 1644) 
  21 ( 1645) 
  22 ( 1645) func onfloor(f,y:integer):boolean;
  23 ( 1645) begin
  24 ( 1645)   onfloor:=(f*vfloors+1=y);
  25 ( 1665) end;
  26 ( 1669) 
  27 ( 1670) func onupladder(f:integer;x:real):boolean;
  28 ( 1670) begin
  29 ( 1670)   onupladder:=(trunc(x)>=ladders[f]+1) and
  30 ( 1694)     (trunc(x)<=ladders[f]+2);
  31 ( 1713) end;
  32 ( 1718) 
  33 ( 1719) func ondownladder(f:integer;x:real):boolean;
  34 ( 1719) begin
  35 ( 1719)   ondownladder:=(trunc(x+0.5)>=ladders[f-1]+2) and
  36 ( 1753)     (trunc(x+0.5)<=ladders[f-1]+4);
  37 ( 1782) end;
  38 ( 1787) 
  39 ( 1788) func onhole(f:integer;x:real):boolean;
  40 ( 1788) begin
  41 ( 1788)   onhole:=(x>=conv(holes[f]+2)) and
  42 ( 1812)       (x<=conv(holes[f]+holesize-6));
  43 ( 1834) end;
  44 ( 1839) 
  45 ( 1840) proc showface;
  46 ( 1840) var fysum:integer;

----------------------------------------------------------------------

R65 COMPILE 4.3: program SCRAMBLE         14/2/24 page 2

  47 ( 1843) begin
  48 ( 1843)   fysum:=fy+trunc(jump);
  49 ( 1855)   plotmap(trunc(fxs),fys,erase);
  50 ( 1880)   plotmap(trunc(fxs)+4,fys,erase);
  51 ( 1902)   plotmap(trunc(fxs),fys+4,erase);
  52 ( 1924)   plotmap(trunc(fxs)+4,fys+4,erase);
  53 ( 1949)   plotmap(trunc(fx),fysum,face1);
  54 ( 1969)   plotmap(trunc(fx)+4,fysum,face2);
  55 ( 1992)   plotmap(trunc(fx),fysum+4,face3);
  56 ( 2015)   plotmap(trunc(fx)+4,fysum+4,face4);
  57 ( 2041)   fxs:=fx; fys:=fysum;
  58 ( 2053) end;
  59 ( 2061) 
  60 ( 2062) proc showladder(f:integer);
  61 ( 2062) var i,x1,x2,y1,y2:integer;
  62 ( 2065) begin
  63 ( 2065)   if f<nfloors then begin
  64 ( 2074)     x1:=ladders[f]; x2:=x1+laddersize;
  65 ( 2095)     y1:=f*vfloors+1; y2:=y1+vfloors-1;
  66 ( 2123)     move(x1,y1); draw(x1,y2,white);
  67 ( 2158)     move(x2,y1); draw(x2,y2,white);
  68 ( 2188)     i:=1;
  69 ( 2190)     for i:=1 to 5 do begin
  70 ( 2211)       move(x1,y1+4*i-1); draw(x2,y1+4*i-1,white);
  71 ( 2263)     end;
  72 ( 2263)   end;
  73 ( 2277) end;
  74 ( 2277) 
  75 ( 2278) func expaint: boolean;
  76 ( 2278) { paint picture and apply motion }
  77 ( 2278) var f:integer;
  78 ( 2281) begin
  79 ( 2281)   expaint:=false;
  80 ( 2285)   { check for next floor on ladder }
  81 ( 2289)   if ffloor<nfloors then
  82 ( 2295)     if onfloor(ffloor+1,fy) then begin
  83 ( 2318)       ffloor:=ffloor+1; fyspeed:=0;
  84 ( 2334)     end;
  85 ( 2338)   if ffloor>0 then
  86 ( 2344)     if onfloor(ffloor-1,fy) then begin
  87 ( 2367)       ffloor:=ffloor-1; fyspeed:=0;
  88 ( 2383)     end;
  89 ( 2387)   { paint face }
  90 ( 2387)   showface;
  91 ( 2391)   { paint ball }
  92 ( 2391)   plotmap(trunc(bxs),trunc(bys),erase);
  93 ( 2413)   plotmap(trunc(bx),trunc(by),ball);
  94 ( 2436)   for f:=0 to nfloors-1 do showladder(f);
  95 ( 2466)   bxs:=bx; bys:=by;
  96 ( 2492)   { move face }
  97 ( 2504)   fx:=fx+fxspeed; fy:=fy+fyspeed;
  98 ( 2527)   if fx>conv(xsize-8) then begin
  99 ( 2549)     fx:=conv(xsize-8); fxspeed:=0.0;
 100 ( 2570)   end;
 101 ( 2576)   if (fx<1.0) then begin
 102 ( 2589)     fx:=1.0; fxspeed:=-0.0;
 103 ( 2610)   end;
 104 ( 2617)   { check for ladder }
 105 ( 2617)   if onupladder(ffloor,fx) or ondownladder(ffloor,fx)
 106 ( 2641)     then fxspeed:=0.0;

----------------------------------------------------------------------

R65 COMPILE 4.3: program SCRAMBLE         14/2/24 page 3

 107 ( 2663)   { check for hole (face) }
 108 ( 2669)   if (jump<=0.0) and onhole(ffloor,fx) then jump:=4.5
 109 ( 2704)   else jump:=jump-0.3;
 110 ( 2731)   if jump<=0.0 then jump:=0.0;
 111 ( 2760)   { move ball }
 112 ( 2766)   bx:=bx+bxspeed; by:=by+byspeed;
 113 ( 2791)   { check for borders }
 114 ( 2804)   if bx>=conv(xsize-4) then begin
 115 ( 2817)     bx:=conv(xsize-4); bxspeed:=-bxspeed;
 116 ( 2832)   end else if bx<2.0 then begin
 117 ( 2861)     bx:=2.0; bxspeed:=-bxspeed;
 118 ( 2876)   end;
 119 ( 2889)   { check for reflection on ceiling }
 120 ( 2889)   if by>=conv((floor+1)*vfloors-4) then begin
 121 ( 2910)     by:=conv((floor+1)*vfloors-4);
 122 ( 2926)     byspeed:=reflection*byspeed;
 123 ( 2939)   end;
 124 ( 2952)   { check for hole (ball) }
 125 ( 2952)   if (bx>=conv(holes[floor])) and
 126 ( 2968)       (bx<=conv(holes[floor]+holesize-4)) and
 127 ( 2990)      (by<=conv(floor*vfloors+1)) then begin
 128 ( 3010)      { fall through hole }
 129 ( 3013)     byspeed:=byspeed+gravity;
 130 ( 3025)     if floor>0 then floor:=floor-1;
 131 ( 3048)   end else if by<conv(floor*vfloors+1) then begin
 132 ( 3074)     { reflection on floor }
 133 ( 3077)     by:=conv(floor*vfloors+2); { jump a bit }
 134 ( 3094)     byspeed:=reflection*byspeed;
 135 ( 3100)   end else
 136 ( 3113)     byspeed:=byspeed+gravity;
 137 ( 3128)   { check for border on bottom floor }
 138 ( 3135)   if (by<4.0) and ((bx<=2.0) or (bx>=conv(xsize-4)))
 139 ( 3174)   then begin
 140 ( 3176)     if bx<2.0 then bx:=2.0
 141 ( 3195)     else if bx>=conv(xsize-4) then bx:=conv(xsize-4);
 142 ( 3231)     by:=conv(nfloors*vfloors+1);
 143 ( 3246)     byspeed:=0.0; floor:=nfloors;
 144 ( 3267)   end;
 145 ( 3271)   { check for hit }
 146 ( 3271)   if (bx>=fx-4.0) and (bx<=fx+8.0) and
 147 ( 3311)      (trunc(by)>=fy-4) and (trunc(by)<=fy+8)
 148 ( 3341)     then begin
 149 ( 3344)      writeln('Hit');
 150 ( 3357)      expaint:=true;
 151 ( 3359)     end;
 152 ( 3363) end;
 153 ( 3363) 
 154 ( 3364) proc ladderup;
 155 ( 3364) begin
 156 ( 3364)   if (ffloor<nfloors) and onupladder(ffloor,fx)
 157 ( 3382)   then begin
 158 ( 3395)     fyspeed:=1; fxspeed:=0.0;
 159 ( 3410)   end;
 160 ( 3416) end;
 161 ( 3416) 
 162 ( 3417) proc ladderdown;
 163 ( 3417) begin
 164 ( 3417)   if (ffloor>0) and ondownladder(ffloor,fx)
 165 ( 3435)   then begin
 166 ( 3448)     fyspeed:=-1; fxspeed:=0.0;

----------------------------------------------------------------------

R65 COMPILE 4.3: program SCRAMBLE         14/2/24 page 4

 167 ( 3464)   end;
 168 ( 3470) end;
 169 ( 3470) 
 170 ( 3471) func exkey(key:char):boolean;
 171 ( 3471) { check for key typed }
 172 ( 3471) begin
 173 ( 3471)   exkey:=(key=esc);
 174 ( 3483)   case key of
 175 ( 3487)    ' ':    write('*');
 176 ( 3500)    cup:    ladderup;
 177 ( 3514)    cdown:  ladderdown;
 178 ( 3528)    cleft:  if onfloor(ffloor,fy) then fxspeed:=-2.0;
 179 ( 3563)    cright: if onfloor(ffloor,fy) then fxspeed:=2.0
 180 ( 3599)    end {case};
 181 ( 3613) end;
 182 ( 3613) 
 183 ( 3614) proc init;
 184 ( 3614) begin
 185 ( 3614)   cleargr;
 186 ( 3623)   bx:=2.0; by:=conv(nfloors*vfloors+1);
 187 ( 3643)   bxs:=bx; bys:=by;
 188 ( 3662)   bxspeed:=2.0; byspeed:=0.0;
 189 ( 3692)   fx:=1.0; fy:=1; jump:=0.0;
 190 ( 3722)   fxs:=fx; fys:=fy;
 191 ( 3740)   fxspeed:=0.0; fyspeed:=0;
 192 ( 3762)   { make and show holes }
 193 ( 3766)   holes[0]:=-holesize;
 194 ( 3770)   for floor:=1 to nfloors do begin
 195 ( 3792)     holes[floor]:=irandom(1,xsize-holesize-1);
 196 ( 3814)     move(0,floor*vfloors);
 197 ( 3833)     draw(xsize-1,floor*vfloors,white);
 198 ( 3853)     move(holes[floor],floor*vfloors);
 199 ( 3874)     draw(holes[floor]+holesize,floor*vfloors,black);
 200 ( 3900)   end;
 201 ( 3900)   { make and show ladders }
 202 ( 3914)   for floor:=0 to nfloors-1 do begin
 203 ( 3934)     repeat
 204 ( 3934)       ladders[floor]:=irandom(2,xsize-laddersize);
 205 ( 3953)     until ((ladders[floor]+laddersize<holes[floor])
 206 ( 3972)       or (ladders[floor]>holes[floor]+holesize)) and
 207 ( 3998)       ((ladders[floor]+laddersize<holes[floor+1])
 208 ( 4016)       or (ladders[floor]>holes[floor+1]+holesize));
 209 ( 4045)       showladder(floor);
 210 ( 4059)   end;
 211 ( 4059)   ladders[nfloors]:=-laddersize;
 212 ( 4077)   floor:=nfloors;
 213 ( 4084)   ffloor:=0;
 214 ( 4090) end;
 215 ( 4094) 
 216 ( 4095) {$I IANIMATE:P}
IANIMATE:P      .0C  SP 0000-0400 000C 12/02/24
{I}    1 ( 4095) { ianimate - run animation in loop
{I}    2 ( 4095)   proc expaint;
{I}    3 ( 4095)     Called to paint one picture and apply motion.
{I}    4 ( 4095)   func exkey(ch:char):boolean;
{I}    5 ( 4095)     Called to check for key and stop loop if true  }
{I}    6 ( 4095) 
{I}    7 ( 4095) proc animate(arepeat:boolean);
{I}    8 ( 4095) { arepeat: auto repeat cursor keys without delay }
{I}    9 ( 4095) const toggle=chr($0c);
{I}   10 ( 4098)       cleft=chr($03); cright=chr($16);

----------------------------------------------------------------------

R65 COMPILE 4.3: program SCRAMBLE         14/2/24 page 5

{I}   11 ( 4098)       cup=chr($1a); cdown=chr($18); esc=chr(0);
{I}   12 ( 4098) mem   sflag=$1781:integer&;
{I}   13 ( 4098)       emuflags=$1707:integer&;
{I}   14 ( 4098) var   ch:char;
{I}   15 ( 4098)       dummy:integer;
{I}   16 ( 4098)       stop:boolean;
{I}   17 ( 4098) begin
{I}   18 ( 4098)   repeat
{I}   19 ( 4098)     repeat
{I}   20 ( 4100)       stop:=expaint;
{I}   21 ( 4106)       dummy:=syncscreen; { sleep for up to 30 msec }
{I}   22 ( 4120)       ch:=keypressed; { sleep for 10 msec }
{I}   23 ( 4128)       { sflag bit 8 is escape flag. Pass it through }
{I}   24 ( 4128)     until (ord(ch)<>0) or ((sflag and $80)<>0)
{I}   25 ( 4144)       or stop;
{I}   26 ( 4146)     if not(((ch=cup) or (ch=cdown) or (ch=cleft) or
{I}   27 ( 4176)        (ch=cright)) and
{I}   28 ( 4185)        ((emuflags and 1)<>0) and arepeat) then
{I}   29 ( 4201)        { cursor keys auto repeat without delay }
{I}   30 ( 4202)        keypressed := chr(0);
{I}   31 ( 4207)     sflag:=sflag and $7f; { clear escape flag }
{I}   32 ( 4225)     if ch=toggle then write(toggle);
{I}   33 ( 4238)   until exkey(ch) or stop;
{I}   34 ( 4250) end;
 217 ( 4259) 
 218 ( 4259) begin
 219 ( 4259)   grinit; fullview; init;
 220 ( 4273)   animate(autorepeat);
 221 ( 4281)   splitview;
 222 ( 4285) end.

End compile

Code lenght:          4284
Compiler stack size:  70
Ident stack size:     143
Pascal errors:        0
