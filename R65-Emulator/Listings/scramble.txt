
R65 COMPILE 4.3: program SCRAMBLE         13/2/24 page 1


   1 (    4) { scramble: climb up the ladders }
   2 (    4) 
   3 (    4) program scramble;
   4 (    4) uses syslib,plotlib;
   5 ( 1566) 
   6 ( 1566) const erase=0; ball=$6ff6;
   7 ( 1569)       nfloors=5; vfloors=19; holesize=20;
   8 ( 1569)       gravity=-0.25; reflection=-0.4;
   9 ( 1569) 
  10 ( 1569) var bx,by,bxs,bys,bxspeed,byspeed: real;
  11 ( 1569)     floor: integer;
  12 ( 1569)     holes: array[nfloors] of integer;
  13 ( 1569) 
  14 ( 1569) {$I IRANDOM:P}
IRANDOM:P       .02  SP 0000-0200 0002 12/02/24
{I}    1 ( 1569) { irandom: real and integer random functions with limit
{I}    2 ( 1569) }
{I}    3 ( 1569) 
{I}    4 ( 1569) func rrandom(min,max:real):real;
{I}    5 ( 1569) begin
{I}    6 ( 1569)   rrandom := min + (conv(random)/255.0) * (max - min);
{I}    7 ( 1607) end;
{I}    8 ( 1615) 
{I}    9 ( 1616) func irandom(min,max:integer):integer;
{I}   10 ( 1616) begin
{I}   11 ( 1616)   irandom := trunc(rrandom(conv(min),conv(max)));
{I}   12 ( 1639) end;
{I}   13 ( 1644) 
  15 ( 1645) 
  16 ( 1645) func expaint: boolean;
  17 ( 1645) { paint picture and apply motion }
  18 ( 1645) begin
  19 ( 1645)   { paint }
  20 ( 1648)   expaint:=false;
  21 ( 1652)   plotmap(trunc(bxs),trunc(bys),erase);
  22 ( 1678)   plotmap(trunc(bx),trunc(by),ball);
  23 ( 1701)   bxs:=bx; bys:=by;
  24 ( 1713)   { motion }
  25 ( 1725)   bx:=bx+bxspeed; by:=by+byspeed;
  26 ( 1750)   if bx>=conv(xsize-4) then begin
  27 ( 1776)     bx:=conv(xsize-4); bxspeed:=-bxspeed;
  28 ( 1791)   end else if bx<2.0 then begin
  29 ( 1820)     bx:=2.0; bxspeed:=-bxspeed;
  30 ( 1835)   end;
  31 ( 1848)   if (bx>=conv(holes[floor])) and
  32 ( 1864)       (bx<=conv(holes[floor]+holesize-4)) then begin
  33 ( 1887)     byspeed:=byspeed+gravity;
  34 ( 1902)     if floor>0 then floor:=floor-1;
  35 ( 1925)   end else if by<=conv(floor*vfloors+1) then begin
  36 ( 1951)     by:=conv(floor*vfloors+2);
  37 ( 1964)     byspeed:=reflection*byspeed;
  38 ( 1977)     if byspeed>4.0 then byspeed:=4.0;
  39 ( 2012)   end else byspeed:=byspeed+gravity;
  40 ( 2033)   if (by<2.5) and ((bx<=2.0) or (bx>=conv(xsize-4)))
  41 ( 2079)   then begin
  42 ( 2081)     if bx<2.0 then bx:=2.0
  43 ( 2100)     else if bx>=conv(xsize-4) then bx:=conv(xsize-4);
  44 ( 2136)     by:=conv(nfloors*vfloors+1);
  45 ( 2151)     byspeed:=0.0; floor:=nfloors;
  46 ( 2172)   end;

----------------------------------------------------------------------

R65 COMPILE 4.3: program SCRAMBLE         13/2/24 page 2

  47 ( 2176) end;
  48 ( 2176) 
  49 ( 2177) func exkey(key:char):boolean;
  50 ( 2177) { check for key typed }
  51 ( 2177) begin
  52 ( 2177)   exkey:=key=chr(0);
  53 ( 2188) end;
  54 ( 2194) 
  55 ( 2195) proc init;
  56 ( 2195) begin
  57 ( 2195)   cleargr;
  58 ( 2204)   bx:=2.0; by:=conv(nfloors*vfloors+1);
  59 ( 2224)   bxs:=bx; bys:=by;
  60 ( 2243)   bxspeed:=2.0; byspeed:=0.0;
  61 ( 2273)   holes[0]:=-holesize;
  62 ( 2283)   for floor:=1 to nfloors do begin
  63 ( 2305)     holes[floor]:=irandom(10,xsize-holesize-10);
  64 ( 2327)     move(0,floor*vfloors);
  65 ( 2346)     draw(xsize-1,floor*vfloors,white);
  66 ( 2366)     move(holes[floor],floor*vfloors);
  67 ( 2387)     draw(holes[floor]+holesize,floor*vfloors,black);
  68 ( 2413)   end;
  69 ( 2413)   floor:=nfloors;
  70 ( 2429) end;
  71 ( 2433) 
  72 ( 2434) {$I IANIMATE:P}
IANIMATE:P      .0C  SP 0000-0400 000C 12/02/24
{I}    1 ( 2434) { ianimate - run animation in loop
{I}    2 ( 2434)   proc expaint;
{I}    3 ( 2434)     Called to paint one picture and apply motion.
{I}    4 ( 2434)   func exkey(ch:char):boolean;
{I}    5 ( 2434)     Called to check for key and stop loop if true  }
{I}    6 ( 2434) 
{I}    7 ( 2434) proc animate(arepeat:boolean);
{I}    8 ( 2434) { arepeat: auto repeat cursor keys without delay }
{I}    9 ( 2434) const toggle=chr($0c);
{I}   10 ( 2437)       cleft=chr($03); cright=chr($16);
{I}   11 ( 2437)       cup=chr($1a); cdown=chr($18); esc=chr(0);
{I}   12 ( 2437) mem   sflag=$1781:integer&;
{I}   13 ( 2437)       emuflags=$1707:integer&;
{I}   14 ( 2437) var   ch:char;
{I}   15 ( 2437)       dummy:integer;
{I}   16 ( 2437)       stop:boolean;
{I}   17 ( 2437) begin
{I}   18 ( 2437)   repeat
{I}   19 ( 2437)     repeat
{I}   20 ( 2439)       stop:=expaint;
{I}   21 ( 2445)       dummy:=syncscreen; { sleep for up to 30 msec }
{I}   22 ( 2459)       ch:=keypressed; { sleep for 10 msec }
{I}   23 ( 2467)       { sflag bit 8 is escape flag. Pass it through }
{I}   24 ( 2467)     until (ord(ch)<>0) or ((sflag and $80)<>0)
{I}   25 ( 2483)       or stop;
{I}   26 ( 2485)     if not(((ch=cup) or (ch=cdown) or (ch=cleft) or
{I}   27 ( 2515)        (ch=cright)) and
{I}   28 ( 2524)        ((emuflags and 1)<>0) and arepeat) then
{I}   29 ( 2540)        { cursor keys auto repeat without delay }
{I}   30 ( 2541)        keypressed := chr(0);
{I}   31 ( 2546)     sflag:=sflag and $7f; { clear escape flag }
{I}   32 ( 2564)     if ch=toggle then write(toggle);
{I}   33 ( 2577)   until exkey(ch) or stop;
{I}   34 ( 2589) end;

----------------------------------------------------------------------

R65 COMPILE 4.3: program SCRAMBLE         13/2/24 page 3

  73 ( 2598) 
  74 ( 2598) begin
  75 ( 2598)   grinit; splitview; init;
  76 ( 2612)   animate(false);
  77 ( 2620)   splitview;
  78 ( 2624) end.

End compile

Code lenght:          2623
Compiler stack size:  50
Ident stack size:     111
Pascal errors:        0
