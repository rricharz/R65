
R65 COMPILE 4.3: program BOUNCE1          12/2/24 page 1


   1 (    4) {
   2 (    4)         ******************
   3 (    4)         *                *
   4 (    4)         *     BOUNCE1    *
   5 (    4)         *                *
   6 (    4)         ******************
   7 (    4) 
   8 (    4) A bouncing ball simulation for the
   9 (    4) R65 Graphics display.
  10 (    4) 
  11 (    4) With circle in the center of the canvas
  12 (    4) 
  13 (    4)     Original    1979 rricharz
  14 (    4)     New version 2024 rricharz
  15 (    4)                                 }
  16 (    4) 
  17 (    4) program bounce1;
  18 (    4) uses syslib,plotlib,mathlib;
  19 ( 5287) 
  20 ( 5287) const gravity=0.15;
  21 ( 5290)       keyfactor=1.05;
  22 ( 5290)       erase=0; ball=$6ff6;
  23 ( 5290)       autorepeat=false;
  24 ( 5290) 
  25 ( 5290) var x,y,xspeed,yspeed: real;
  26 ( 5290)     xi,yi,xl,yl,keycode: integer;
  27 ( 5290)     xc,yc,rc: real;
  28 ( 5290) 
  29 ( 5290) {$I IRANDOM:P}
IRANDOM:P       .02  SP 0000-0200 0002 12/02/24
{I}    1 ( 5290) { irandom: real and integer random functions with limit
{I}    2 ( 5290) }
{I}    3 ( 5290) 
{I}    4 ( 5290) func rrandom(min,max:real):real;
{I}    5 ( 5290) begin
{I}    6 ( 5290)   rrandom := min + (conv(random)/255.0) * (max - min);
{I}    7 ( 5328) end;
{I}    8 ( 5336) 
{I}    9 ( 5337) func irandom(min,max:integer):integer;
{I}   10 ( 5337) begin
{I}   11 ( 5337)   irandom := trunc(rrandom(conv(min),conv(max)));
{I}   12 ( 5360) end;
{I}   13 ( 5365) 
  30 ( 5366) 
  31 ( 5366) func expaint:boolean;
  32 ( 5366) var radx,rady,l,sp1,sp2,mx,my,rx,ry:real;
  33 ( 5369) begin
  34 ( 5369)   expaint:=false;
  35 ( 5373)   yspeed:=yspeed-gravity;
  36 ( 5389)   x:=x+xspeed;
  37 ( 5402)   y:=y+yspeed;
  38 ( 5421)   if x<1.5 then begin
  39 ( 5447)     x:=1.5;
  40 ( 5456)     xspeed:=-xspeed;
  41 ( 5462)   end else if x>conv(xsize-4) then begin
  42 ( 5491)     x:=conv(xsize-4);
  43 ( 5499)     xspeed:=-xspeed;
  44 ( 5506)   end;
  45 ( 5519)   if y<1.5 then begin
  46 ( 5532)     y:=1.5;

----------------------------------------------------------------------

R65 COMPILE 4.3: program BOUNCE1          12/2/24 page 2

  47 ( 5541)     yspeed:=-yspeed+0.5*gravity;
  48 ( 5566)   end else if y>conv(ysize-18) then begin
  49 ( 5590)     yspeed:=-0.95*yspeed;
  50 ( 5599)     y:=conv(ysize-18);
  51 ( 5618)   end;
  52 ( 5625) 
  53 ( 5625)   { handle circle in center }
  54 ( 5625)   if (xc-x)*(xc-x)+(yc-y)*(yc-y) < (rc+4.0)*(rc+4.0)
  55 ( 5705)   then begin
  56 ( 5708)     { calculate radius vector }
  57 ( 5711)     rx:=xc-x; ry:=yc-y;
  58 ( 5736)     { normalize this vector, make lenght = 1 }
  59 ( 5749)     l:=sqrt(rx*rx+ry*ry);
  60 ( 5784)     rx:=rx/l; ry:=ry/l;
  61 ( 5815)     { calculate dot product of radius and motion }
  62 ( 5828)     sp1:=rx*xspeed+ry*yspeed;
  63 ( 5847)     { calculate dot product of tangent and motion }
  64 ( 5861)     sp2:=ry*xspeed-rx*yspeed;
  65 ( 5880)     { project motion vector on radius and tangent }
  66 ( 5894)     { invert radial component}
  67 ( 5894)     xspeed:=-rx*sp1+ry*sp2; yspeed:=-ry*sp1-rx*sp2;
  68 ( 5948)     { put ball outside of circle }
  69 ( 5962)     x:=x+xspeed;
  70 ( 5968)     y:=y+yspeed;
  71 ( 5987)   end;
  72 ( 6000)   xi:=trunc(x);
  73 ( 6006)   yi:=trunc(y);
  74 ( 6017)   plotmap(xl,yl,erase);
  75 ( 6038)   plotmap(xi,yi,ball);
  76 ( 6055)   xl:=xi;
  77 ( 6055)   yl:=yi;
  78 ( 6063) end;
  79 ( 6071) 
  80 ( 6072) func exkey(ch:char):boolean;
  81 ( 6072) begin
  82 ( 6072)   exkey:=false
  83 ( 6077)   case ord(ch) of
  84 ( 6087)     26: yspeed:=yspeed*keyfactor;
  85 ( 6106)     03: xspeed:=xspeed/keyfactor;
  86 ( 6135)     22: xspeed:=xspeed*keyfactor;
  87 ( 6164)     24: yspeed:=yspeed/keyfactor;
  88 ( 6193)     0:  exkey:=true
  89 ( 6210)   end {case};
  90 ( 6218)   if xspeed>4.0 then xspeed:=4.0
  91 ( 6234)   else if xspeed<-4.0 then xspeed:=-4.0;
  92 ( 6272)   if yspeed>6.0 then yspeed:=6.0
  93 ( 6295)   else if yspeed<-6.0 then yspeed:=-6.0;
  94 ( 6333) end;
  95 ( 6340) 
  96 ( 6341) {$I ICIRCLE:P }
ICIRCLE:P       .04  SP 0000-0200 0000 12/02/24
{I}    1 ( 6341) proc circle(x,y,r,c:integer);
{I}    2 ( 6341) var step,rr,angle:real;
{I}    3 ( 6344) begin
{I}    4 ( 6344)  rr:=conv(r); step:=180.0/rr; angle:=0.0;
{I}    5 ( 6382)  if step>22.5 then step:=22.5;
{I}    6 ( 6410)  move(x+r,y);
{I}    7 ( 6435)  repeat
{I}    8 ( 6435)    angle:=angle+step;
{I}    9 ( 6441)    draw(x+trunc(rr*cos(angle)+0.5),
{I}   10 ( 6486)         y+trunc(rr*sin(angle)+0.5),c);

----------------------------------------------------------------------

R65 COMPILE 4.3: program BOUNCE1          12/2/24 page 3

{I}   11 ( 6532)  until angle>=360.0;
{I}   12 ( 6544) end;
  97 ( 6549) {$I IANIMATE:P}
IANIMATE:P      .0C  SP 0000-0400 000E 12/02/24
{I}    1 ( 6549) { ianimate - run animation in loop
{I}    2 ( 6549)   proc expaint;
{I}    3 ( 6549)     Called to paint one picture and apply motion.
{I}    4 ( 6549)   func exkey(ch:char):boolean;
{I}    5 ( 6549)     Called to check for key and stop loop if true  }
{I}    6 ( 6549) 
{I}    7 ( 6549) proc animate(arepeat:boolean);
{I}    8 ( 6549) { arepeat: auto repeat cursor keys without delay }
{I}    9 ( 6549) const toggle=chr($0c);
{I}   10 ( 6552)       cleft=chr($03); cright=chr($16);
{I}   11 ( 6552)       cup=chr($1a); cdown=chr($18); esc=chr(0);
{I}   12 ( 6552) mem   sflag=$1781:integer&;
{I}   13 ( 6552)       emuflags=$1707:integer&;
{I}   14 ( 6552) var   ch:char;
{I}   15 ( 6552)       dummy:integer;
{I}   16 ( 6552)       stop:boolean;
{I}   17 ( 6552) begin
{I}   18 ( 6552)   repeat
{I}   19 ( 6552)     repeat
{I}   20 ( 6554)       stop:=expaint;
{I}   21 ( 6560)       dummy:=syncscreen; { sleep for up to 30 msec }
{I}   22 ( 6574)       ch:=keypressed; { sleep for 10 msec }
{I}   23 ( 6582)       { sflag bit 8 is escape flag. Pass it through }
{I}   24 ( 6582)     until (ord(ch)<>0) or ((sflag and $80)<>0)
{I}   25 ( 6598)       or stop;
{I}   26 ( 6600)     if not(((ch=cup) or (ch=cdown) or (ch=cleft) or
{I}   27 ( 6630)        (ch=cright)) and
{I}   28 ( 6639)        ((emuflags and 1)<>0) and arepeat) then
{I}   29 ( 6655)        { cursor keys auto repeat without delay }
{I}   30 ( 6656)        keypressed := chr(0);
{I}   31 ( 6661)     sflag:=sflag and $7f; { clear escape flag }
{I}   32 ( 6679)     if ch=toggle then write(toggle);
{I}   33 ( 6692)   until exkey(ch) or stop;
{I}   34 ( 6704) end;
  98 ( 6713) 
  99 ( 6713) begin
 100 ( 6713)   grinit;
 101 ( 6719)   cleargr;
 102 ( 6723)   xspeed:=rrandom(0.4,4.0);
 103 ( 6743)   yspeed:=rrandom(0.4,3.0);
 104 ( 6769)   x:=1.5;
 105 ( 6781)   y:=conv(ysize)/2.0;
 106 ( 6796)   xl:=trunc(x);
 107 ( 6809)   yl:=trunc(y);
 108 ( 6820) 
 109 ( 6825)   move(0,ysize);
 110 ( 6835)   draw(0,0,white);
 111 ( 6847)   draw(xsize,0,white);
 112 ( 6859)   draw(xsize,ysize,white);
 113 ( 6871)   draw(0,ysize,white);
 114 ( 6883)   move(0,ysize-14);
 115 ( 6896)   draw(xsize,ysize-14,white);
 116 ( 6911) 
 117 ( 6911)   move(6,ysize-11);
 118 ( 6924)   write(@plotdev,
 119 ( 6926)     'Use arrows to change speed');
 120 ( 6955) 

----------------------------------------------------------------------

R65 COMPILE 4.3: program BOUNCE1          12/2/24 page 4

 121 ( 6955)   xc:=conv(xsize) * 0.5;
 122 ( 6964)   yc:=conv(ysize-14) * 0.5;
 123 ( 6983)   rc:=conv(ysize-14) * 0.25;
 124 ( 7002) 
 125 ( 7009)   circle(trunc(xc),trunc(yc),trunc(rc),white);
 126 ( 7038) 
 127 ( 7038)   animate(autorepeat);
 128 ( 7046)   splitview;
 129 ( 7050) end.
 130 ( 7050) 

End compile

Code lenght:          7049
Compiler stack size:  97
Ident stack size:     136
Pascal errors:        0
